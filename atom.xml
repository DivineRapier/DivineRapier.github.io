<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>お可愛いこと</title>
  
  
  <link href="http://divinerapier.github.io/atom.xml" rel="self"/>
  
  <link href="http://divinerapier.github.io/"/>
  <updated>2020-09-05T02:46:08.181Z</updated>
  <id>http://divinerapier.github.io/</id>
  
  <author>
    <name>divinerapier</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Windows Terminal</title>
    <link href="http://divinerapier.github.io/2020/09/05/windows-terminal/"/>
    <id>http://divinerapier.github.io/2020/09/05/windows-terminal/</id>
    <published>2020-09-05T01:41:34.000Z</published>
    <updated>2020-09-05T02:46:08.181Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.microsoft.com/en-us/windows/terminal/" target="_blank" rel="noopener"><code>Windows Terminal</code></a> 是继 <code>WSL</code> 之后出品的又一个开发者友好的现代化应用程序。在支持原有的 <code>CMD</code>、<code>Powershell</code> 之外，还支持 <code>WSL</code> 子系统。其主要特性包括: 多 <code>tab</code>，多 <code>panes</code>，支持显示 <code>Unicode</code> 与 <code>UTF-8</code> 字符，使用 <code>GPU</code> 加速的文本渲染引擎，内置 <code>SSH</code> 客户端，更允许用户自定义主题及文本样式，颜色，背景，快捷键等。</p><p>更多内容请阅读<a href="https://docs.microsoft.com/en-us/windows/terminal/" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="我的配置文件"><a href="#我的配置文件" class="headerlink" title="我的配置文件"></a>我的配置文件</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"$schema"</span>: <span class="string">"https://aka.ms/terminal-profiles-schema"</span>,</span><br><span class="line">    <span class="attr">"defaultProfile"</span>: <span class="string">"&#123;a5a97cb8-8961-5535-816d-772efe0c6a3f&#125;"</span>,</span><br><span class="line">    <span class="attr">"copyOnSelect"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"copyFormatting"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"theme"</span>: <span class="string">"dark"</span>,</span><br><span class="line">    <span class="attr">"tabWidthMode"</span>: <span class="string">"titleLength"</span>,</span><br><span class="line">    <span class="attr">"profiles"</span>: &#123;</span><br><span class="line">        <span class="attr">"defaults"</span>: &#123;</span><br><span class="line">            <span class="attr">"colorScheme"</span>: <span class="string">"Dracula"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"list"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"guid"</span>: <span class="string">"&#123;61c54bbd-c2c6-5271-96e7-009a87ff44bf&#125;"</span>,</span><br><span class="line">                <span class="attr">"name"</span>: <span class="string">"Windows PowerShell"</span>,</span><br><span class="line">                <span class="attr">"commandline"</span>: <span class="string">"powershell.exe"</span>,</span><br><span class="line">                <span class="attr">"hidden"</span>: <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"guid"</span>: <span class="string">"&#123;0caa0dad-35be-5f56-a8ff-afceeeaa6101&#125;"</span>,</span><br><span class="line">                <span class="attr">"name"</span>: <span class="string">"Command Prompt"</span>,</span><br><span class="line">                <span class="attr">"commandline"</span>: <span class="string">"cmd.exe"</span>,</span><br><span class="line">                <span class="attr">"hidden"</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"guid"</span>: <span class="string">"&#123;a5a97cb8-8961-5535-816d-772efe0c6a3f&#125;"</span>,</span><br><span class="line">                <span class="attr">"hidden"</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">"name"</span>: <span class="string">"Arch"</span>,</span><br><span class="line">                <span class="attr">"tabTitle"</span>: <span class="string">"Arch"</span>,</span><br><span class="line">                <span class="attr">"suppressApplicationTitle"</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">"antialiasingMode"</span>: <span class="string">"cleartype"</span>, <span class="comment">// "grayscale"、"cleartype"、"aliased"</span></span><br><span class="line">                <span class="attr">"icon"</span>: <span class="string">"ms-appdata:///roaming/archlinux-512.webp"</span>,</span><br><span class="line">                <span class="attr">"source"</span>: <span class="string">"Windows.Terminal.Wsl"</span>,</span><br><span class="line">                <span class="attr">"acrylicOpacity"</span>: <span class="number">0.8</span>,</span><br><span class="line">                <span class="attr">"useAcrylic"</span>: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"schemes"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Dracula"</span>,</span><br><span class="line">            <span class="attr">"cursorColor"</span>: <span class="string">"#F8F8F2"</span>,</span><br><span class="line">            <span class="attr">"selectionBackground"</span>: <span class="string">"#44475A"</span>,</span><br><span class="line">            <span class="attr">"background"</span>: <span class="string">"#282A36"</span>,</span><br><span class="line">            <span class="attr">"foreground"</span>: <span class="string">"#F8F8F2"</span>,</span><br><span class="line">            <span class="attr">"black"</span>: <span class="string">"#21222C"</span>,</span><br><span class="line">            <span class="attr">"blue"</span>: <span class="string">"#BD93F9"</span>,</span><br><span class="line">            <span class="attr">"cyan"</span>: <span class="string">"#8BE9FD"</span>,</span><br><span class="line">            <span class="attr">"green"</span>: <span class="string">"#50FA7B"</span>,</span><br><span class="line">            <span class="attr">"purple"</span>: <span class="string">"#FF79C6"</span>,</span><br><span class="line">            <span class="attr">"red"</span>: <span class="string">"#FF5555"</span>,</span><br><span class="line">            <span class="attr">"white"</span>: <span class="string">"#F8F8F2"</span>,</span><br><span class="line">            <span class="attr">"yellow"</span>: <span class="string">"#F1FA8C"</span>,</span><br><span class="line">            <span class="attr">"brightBlack"</span>: <span class="string">"#6272A4"</span>,</span><br><span class="line">            <span class="attr">"brightBlue"</span>: <span class="string">"#D6ACFF"</span>,</span><br><span class="line">            <span class="attr">"brightCyan"</span>: <span class="string">"#A4FFFF"</span>,</span><br><span class="line">            <span class="attr">"brightGreen"</span>: <span class="string">"#69FF94"</span>,</span><br><span class="line">            <span class="attr">"brightPurple"</span>: <span class="string">"#FF92DF"</span>,</span><br><span class="line">            <span class="attr">"brightRed"</span>: <span class="string">"#FF6E6E"</span>,</span><br><span class="line">            <span class="attr">"brightWhite"</span>: <span class="string">"#FFFFFF"</span>,</span><br><span class="line">            <span class="attr">"brightYellow"</span>: <span class="string">"#FFFFA5"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"keybindings"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"command"</span>: &#123;</span><br><span class="line">                <span class="attr">"action"</span>: <span class="string">"copy"</span>,</span><br><span class="line">                <span class="attr">"singleLine"</span>: <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"keys"</span>: <span class="string">"ctrl+c"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"command"</span>: <span class="string">"paste"</span>,</span><br><span class="line">            <span class="attr">"keys"</span>: <span class="string">"ctrl+v"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"command"</span>: <span class="string">"find"</span>,</span><br><span class="line">            <span class="attr">"keys"</span>: <span class="string">"ctrl+shift+f"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"command"</span>: &#123;</span><br><span class="line">                <span class="attr">"action"</span>: <span class="string">"splitPane"</span>,</span><br><span class="line">                <span class="attr">"split"</span>: <span class="string">"auto"</span>,</span><br><span class="line">                <span class="attr">"splitMode"</span>: <span class="string">"duplicate"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"keys"</span>: <span class="string">"alt+shift+d"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"command"</span>: &#123;</span><br><span class="line">                <span class="attr">"action"</span>: <span class="string">"splitPane"</span>,</span><br><span class="line">                <span class="attr">"split"</span>: <span class="string">"horizontal"</span>,</span><br><span class="line">                <span class="attr">"splitMode"</span>: <span class="string">"duplicate"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"keys"</span>: <span class="string">"alt+shift+-"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"command"</span>: &#123;</span><br><span class="line">                <span class="attr">"action"</span>: <span class="string">"splitPane"</span>,</span><br><span class="line">                <span class="attr">"split"</span>: <span class="string">"vertical"</span>,</span><br><span class="line">                <span class="attr">"splitMode"</span>: <span class="string">"duplicate"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"keys"</span>: <span class="string">"alt+shift+|"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h2><ul><li><a href="https://docs.microsoft.com/en-us/windows/terminal/customize-settings/global-settings#default-profile" target="_blank" rel="noopener"><strong>defaultProfile</strong></a>: 默认使用的终端配置，可以是 <code>profiles.list</code> 中的某一个。</li><li><a href="https://docs.microsoft.com/en-us/windows/terminal/customize-settings/global-settings#darklight-theme" target="_blank" rel="noopener"><strong>theme</strong></a>: 窗体配色，可以是 <code>system</code>, <code>dark</code>, <code>light</code></li><li><a href="https://docs.microsoft.com/en-us/windows/terminal/customize-settings/global-settings#tab-width-mode" target="_blank" rel="noopener"><strong>tabWidthMode</strong></a>: <code>tab</code> 显示长度，可以是 <code>equal</code>, <code>titleLength</code>, <code>compact</code></li></ul><h2 id="配置终端"><a href="#配置终端" class="headerlink" title="配置终端"></a>配置终端</h2><p><code>profiles</code> 用于配置具体的终端，其包含如下两部分:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"profiles"</span>: &#123;</span><br><span class="line">        <span class="attr">"defaults"</span>: &#123;</span><br><span class="line">            <span class="comment">// SETTINGS TO APPLY TO ALL PROFILES</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"list"</span>: [</span><br><span class="line">            <span class="comment">// PROFILE OBJECTS</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="默认终端配置"><a href="#默认终端配置" class="headerlink" title="默认终端配置"></a>默认终端配置</h3><ul><li><p><strong>profiles.defaults</strong>: 中的配置对所有的终端有效。</p></li><li><p><strong>profiles.list</strong>: 包含所有可用的终端，配置只对当前终端。</p></li><li><p><strong>guid</strong>: 配置文件可将 <code>GUID</code> 用作唯一标识符。 若要将某个配置文件设置为默认配置文件，则需要 <code>defaultProfile</code> 全局设置的 <code>GUID</code>，为必填项</p></li><li><p><strong>colorScheme</strong>: 终端使用的配色方案，需要在 <code>schemes</code> 中目标配色方案</p></li><li><p><strong>hidden</strong>: 在下拉列表中是否隐藏，默认为 <code>false</code></p></li><li><p><strong>name</strong>: “在下拉列表中显示的名字</p></li><li><p><strong>tabTitle</strong>: 在 <code>tab</code> 上显示的名字，会覆盖 <strong>name</strong>，需要与 <strong>suppressApplicationTitle</strong> 一起使用才会生效。若要了解如何使 shell 设置标题，请访问<a href="https://docs.microsoft.com/en-us/windows/terminal/tutorials/tab-title" target="_blank" rel="noopener">tab title tutorial</a></p></li><li><p><strong>suppressApplicationTitle</strong>: 设置为 <strong>true</strong> 时，<strong>tabTitle</strong> 会替代 <code>tab</code> 的默认标题，并将禁止应用程序的任何标题更改消息。 如果未设置 <strong>tabTitle</strong>，将改为使用 <strong>name</strong></p></li><li><p><strong>antialiasingMode</strong>: 抗锯齿模式，可以为 <strong>grayscale</strong>、<strong>cleartype</strong>、<strong>aliased</strong></p></li><li><p><strong>icon</strong>: 显示图标，”ms-appdata:///roaming/archlinux-512.webp”</p></li><li><p><strong>acrylicOpacity</strong>: 窗口透明度，<strong>[0, 1]</strong> 之内的浮点数，需要配合 <strong>useAcrylic</strong> 一起使用</p></li><li><p><strong>useAcrylic</strong>: 是否是否透明效果</p></li><li><p><strong>startingDirectory</strong>: 起始目录位置，比如 <code>\\\\wsl$\\Ubuntu-20.04\\home\\alice</code></p></li></ul><h4 id="ms-appdata-在什么位置"><a href="#ms-appdata-在什么位置" class="headerlink" title="ms-appdata 在什么位置"></a>ms-appdata 在什么位置</h4><p><code>Windows Terminal</code> 是一个 <code>UWP</code> 应用(如果是在应用商店下载的话)，会有属于自己的 <strong>appdata</strong> 目录，位于:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%LOCALAPPDATA%\Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\RoamingState</span><br></pre></td></tr></table></figure><p>在文件管理器中打开这个目录放入数据，<code>Windows Terminal</code> 即可通过 <code>ms-appdata:\\\</code> 的方式获取到。</p><h2 id="配色方案"><a href="#配色方案" class="headerlink" title="配色方案"></a>配色方案</h2><p>可以在 <strong>themes</strong> 定义一系列的配色方案，要求每个配色方案要有一个唯一的 <strong>name</strong>。除 <strong>name</strong> 以外，每个设置都接受十六进制格式 (<strong>#rgb</strong> 或 <strong>#rrggbb</strong>) 的字符串形式的颜色。 <strong>cursorColor</strong> 和 <strong>selectionBackground</strong> 设置是可选的。</p><p>如果要在一个命令行配置文件中设置配色方案，请添加 <strong>colorScheme</strong> 属性，并将配色方案的 <strong>name</strong> 作为值。</p><h2 id="自定义快捷键"><a href="#自定义快捷键" class="headerlink" title="自定义快捷键"></a>自定义快捷键</h2><p>内容太多，请查看<a href="https://docs.microsoft.com/en-us/windows/terminal/customize-settings/key-bindings" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://docs.microsoft.com/en-us/windows/terminal/" target="_blank" rel="noopener">Windows Terminal</a></li><li><a href="https://www.howtogeek.com/426346/how-to-customize-the-new-windows-terminal-app/" target="_blank" rel="noopener">How to Customize the New Windows Terminal App</a></li><li><a href="https://docs.microsoft.com/en-us/windows/terminal/customize-settings/key-bindings" target="_blank" rel="noopener">Custom key bindings in Windows Terminal</a></li><li><a href="https://draculatheme.com/windows-terminal/" target="_blank" rel="noopener">draculatheme</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/terminal/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;Windows Terminal&lt;/code&gt;&lt;/a&gt; 是继 &lt;code&gt;WS</summary>
      
    
    
    
    
    <category term="windows" scheme="http://divinerapier.github.io/tags/windows/"/>
    
    <category term="terminal" scheme="http://divinerapier.github.io/tags/terminal/"/>
    
  </entry>
  
  <entry>
    <title>投射数据卷 (TBC)</title>
    <link href="http://divinerapier.github.io/2020/09/04/projected-volumes/"/>
    <id>http://divinerapier.github.io/2020/09/04/projected-volumes/</id>
    <published>2020-09-04T00:39:17.000Z</published>
    <updated>2020-09-09T15:02:46.783Z</updated>
    
    <content type="html"><![CDATA[<p><strong>投射数据卷</strong> 的官方名称为: <code>projected volume</code>。<code>Project</code> 在这里的意思为 <a href="https://cn.bing.com/dict/search?q=project&qs=n&form=Z9LH5&sp=-1&pq=project&sc=8-7&sk=&cvid=A2B01F96E5A847E7A67FEC9AE0A97060" target="_blank" rel="noopener"><strong>投射</strong></a>。感谢 <code>k8s</code> 帮助我学习英语。</p><p><a href="https://kubernetes.io/docs/concepts/storage/volumes/#projected" target="_blank" rel="noopener">官方定义为</a>:</p><blockquote><p>A projected volume maps several existing volume sources into the same directory.</p></blockquote><p><code>Projected Volumes</code> 存在的意义不是为了存放容器里的数据，也不是用来进行容器和宿主机之间的数据交换。而是为容器提供预先定义好的数据。所以，从容器的角度来看，这些 <code>Volume</code> 里的信息就是仿佛是被 <code>Kubernetes</code> <strong>投射</strong> (Project) 进入容器当中的。到目前为止，Kubernetes 支持的 Projected Volume 一共有四种:</p><ul><li>Secret</li><li>ConfigMap</li><li>Downward API</li><li>ServiceAccountToken。</li></ul><p>下面是官方给出的一个<a href="https://kubernetes.io/docs/concepts/storage/volumes/#example-pod-with-a-secret-a-downward-api-and-a-configmap" target="_blank" rel="noopener">例子</a>:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">volume-test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">container-test</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">all-in-one</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">"/projected-volume"</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">all-in-one</span></span><br><span class="line">    <span class="attr">projected:</span></span><br><span class="line">      <span class="attr">sources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">secret:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">mysecret</span></span><br><span class="line">          <span class="attr">items:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">username</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">my-group/my-username</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">downwardAPI:</span></span><br><span class="line">          <span class="attr">items:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">"labels"</span></span><br><span class="line">              <span class="attr">fieldRef:</span></span><br><span class="line">                <span class="attr">fieldPath:</span> <span class="string">metadata.labels</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">"cpu_limit"</span></span><br><span class="line">              <span class="attr">resourceFieldRef:</span></span><br><span class="line">                <span class="attr">containerName:</span> <span class="string">container-test</span></span><br><span class="line">                <span class="attr">resource:</span> <span class="string">limits.cpu</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">configMap:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">myconfigmap</span></span><br><span class="line">          <span class="attr">items:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">config</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">my-group/my-config</span></span><br></pre></td></tr></table></figure><p>首先，可以看到 <code>volumes</code> 与 <code>containers</code> 是同级的属性字段，同属于 <code>pod</code> 的信息。其次，在上述示例中，使用了三种 <code>Projected Volume</code>。</p><p>在有了初步认识之后，接下来对每一种 <code>Projected Volume</code> 做出更详细的说明。</p><h2 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h2><p><code>Secret</code> 最常见的用法是保存认证信息，比如数据库等。这些数据会被保存在内部的 <code>ETCD</code> 中，可以通过将 <code>Secret</code> 以 <code>Volume</code> 的形式挂载到 <code>Pod</code> 上的方式，允许 <code>Pod</code> 使用 <code>Secret</code> 中的数据。</p><p>接下来介绍两种创建 <code>Secret</code> 以及使用的方式。</p><h3 id="命令行方式"><a href="#命令行方式" class="headerlink" title="命令行方式"></a>命令行方式</h3><h4 id="通过命令行创建-Secret"><a href="#通过命令行创建-Secret" class="headerlink" title="通过命令行创建 Secret"></a>通过命令行创建 Secret</h4><p>使用如下命令创建两个 <code>Secret</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'admin'</span> &gt; ./user.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'password'</span> &gt; ./pass.txt</span><br><span class="line"></span><br><span class="line">kubectl create secret generic user --from-file=./user.txt</span><br><span class="line">kubectl create secret generic pass --from-file=./pass.txt</span><br></pre></td></tr></table></figure><h4 id="查询-Secret"><a href="#查询-Secret" class="headerlink" title="查询 Secret"></a>查询 Secret</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get secrets</span><br><span class="line">NAME                  TYPE                                  DATA   AGE</span><br><span class="line">pass                  Opaque                                1      13s</span><br><span class="line">user                  Opaque                                1      18s</span><br></pre></td></tr></table></figure><h4 id="在-Pod-中使用-Secret"><a href="#在-Pod-中使用-Secret" class="headerlink" title="在 Pod 中使用 Secret"></a>在 Pod 中使用 Secret</h4><p>生成一个 <code>yaml</code> 文件，引用上面的 <code>Secret</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成 yaml，在 volumes.projected 中指定上面的 user 与 pass</span></span><br><span class="line">$ cat &lt;&lt; EOF &gt;&gt; busybox.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: <span class="built_in">test</span>-projected-volume</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: <span class="built_in">test</span>-secret-volume</span><br><span class="line">    image: busybox</span><br><span class="line">    args:</span><br><span class="line">    - sleep</span><br><span class="line">    - <span class="string">"86400"</span></span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: mysql-cred</span><br><span class="line">      mountPath: <span class="string">"/projected-volume"</span></span><br><span class="line">      readOnly: <span class="literal">true</span></span><br><span class="line">  volumes:</span><br><span class="line">  - name: mysql-cred</span><br><span class="line">    projected:</span><br><span class="line">      sources:</span><br><span class="line">      - secret:</span><br><span class="line">          name: user</span><br><span class="line">      - secret:</span><br><span class="line">          name: pass</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 pod</span></span><br><span class="line">$ kubectl apply -f ./busybox.yaml</span><br><span class="line">pod/<span class="built_in">test</span>-projected-volume created</span><br></pre></td></tr></table></figure><h4 id="在-Pod-中查看-Secret-数据"><a href="#在-Pod-中查看-Secret-数据" class="headerlink" title="在 Pod 中查看 Secret 数据"></a>在 Pod 中查看 Secret 数据</h4><p>进入到 <code>Pod</code> 中:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="built_in">exec</span> -ti <span class="built_in">test</span>-projected-volume -- sh</span><br><span class="line">/ <span class="comment">#</span></span><br></pre></td></tr></table></figure><p>查看 <code>Secret</code> 数据:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># ls /projected-volume/</span></span><br><span class="line">user.txt</span><br><span class="line">pass.txt</span><br><span class="line">/ <span class="comment"># cat /projected-volume/user.txt</span></span><br><span class="line">admin</span><br><span class="line">/ <span class="comment"># cat /projected-volume/pass.txt</span></span><br><span class="line">password</span><br></pre></td></tr></table></figure><p>可以看到，在 <code>mountPath</code> 指定的路径下面有预先定义好的 <code>Secret</code>，并且文件名就是 <code>--from-file</code> 指定的参数。</p><h3 id="yaml-方式"><a href="#yaml-方式" class="headerlink" title="yaml 方式"></a>yaml 方式</h3><h4 id="通过-yaml-创建-Secret"><a href="#通过-yaml-创建-Secret" class="headerlink" title="通过 yaml 创建 Secret"></a>通过 yaml 创建 Secret</h4><p>创建 <code>Secret</code> 的配置文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt;&lt; EOF &gt;&gt; secret.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: mysecret</span><br><span class="line"><span class="built_in">type</span>: Opaque</span><br><span class="line">data:</span><br><span class="line">  user: YWRtaW4=</span><br><span class="line">  pass: cGFzc3dvcmQ=</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>在 <code>Kubernetes</code> 中创建 <code>Secret</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f ./secret.yml</span><br><span class="line">secret/mysecret created</span><br></pre></td></tr></table></figure><h4 id="查询-Secret-1"><a href="#查询-Secret-1" class="headerlink" title="查询 Secret"></a>查询 Secret</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get secrets</span><br><span class="line">NAME                  TYPE                                  DATA   AGE</span><br><span class="line">mysecret              Opaque                                2      3m23s</span><br></pre></td></tr></table></figure><p>结果与使用命令行的方式有一些区别。</p><h4 id="在-Pod-中使用-Secret-1"><a href="#在-Pod-中使用-Secret-1" class="headerlink" title="在 Pod 中使用 Secret"></a>在 Pod 中使用 Secret</h4><p>生成一个 <code>yaml</code> 文件，引用上面的 <code>Secret</code>，需要注意 <code>secret.name</code> 应使用 <code>mysecret</code>，同时，数量从刚才的 <strong>2个</strong> 变成了 <strong>1个</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt;&lt; EOF &gt;&gt; busybox.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: <span class="built_in">test</span>-projected-volume</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: <span class="built_in">test</span>-secret-volume</span><br><span class="line">    image: busybox</span><br><span class="line">    args:</span><br><span class="line">    - sleep</span><br><span class="line">    - <span class="string">"86400"</span></span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: mysql-cred</span><br><span class="line">      mountPath: <span class="string">"/projected-volume"</span></span><br><span class="line">      readOnly: <span class="literal">true</span></span><br><span class="line">  volumes:</span><br><span class="line">  - name: mysql-cred</span><br><span class="line">    projected:</span><br><span class="line">      sources:</span><br><span class="line">      - secret:</span><br><span class="line">          name: mysecret</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 pod</span></span><br><span class="line">$ kubectl apply -f ./busybox.yaml</span><br><span class="line">pod/<span class="built_in">test</span>-projected-volume created</span><br></pre></td></tr></table></figure><h4 id="在-Pod-中查看-Secret-数据-1"><a href="#在-Pod-中查看-Secret-数据-1" class="headerlink" title="在 Pod 中查看 Secret 数据"></a>在 Pod 中查看 Secret 数据</h4><p>进入到 <code>Pod</code> 中:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="built_in">exec</span> -ti <span class="built_in">test</span>-projected-volume -- sh</span><br><span class="line">/ <span class="comment">#</span></span><br></pre></td></tr></table></figure><p>查看 <code>Secret</code> 数据:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># ls /projected-volume/</span></span><br><span class="line">pass  user</span><br><span class="line">/ <span class="comment"># cat /projected-volume/user</span></span><br><span class="line">admin</span><br><span class="line">/ <span class="comment"># cat /projected-volume/pass.txt</span></span><br><span class="line">password</span><br></pre></td></tr></table></figure><p>可以看到，在 <code>mountPath</code> 指定的路径下面有预先定义好的 <code>Secret</code>，并且文件名就是创建 <code>Secret</code> 的 <code>yaml</code> 文件中，<code>data</code> 字段的 <code>key</code>，内容为对应 <code>value</code> 经过 <code>base64</code> 解码之后的结果。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://kubernetes.io/docs/concepts/storage/volumes/#projected" target="_blank" rel="noopener">Projected Volumes</a></li><li><a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-projected-volume-storage/" target="_blank" rel="noopener">Configure a Pod to Use a Projected Volume for Storage</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;投射数据卷&lt;/strong&gt; 的官方名称为: &lt;code&gt;projected volume&lt;/code&gt;。&lt;code&gt;Project&lt;/code&gt; 在这里的意思为 &lt;a href=&quot;https://cn.bing.com/dict/search?q=proj</summary>
      
    
    
    
    
    <category term="k8s" scheme="http://divinerapier.github.io/tags/k8s/"/>
    
    <category term="pod" scheme="http://divinerapier.github.io/tags/pod/"/>
    
  </entry>
  
  <entry>
    <title>Play with Kubernetes</title>
    <link href="http://divinerapier.github.io/2020/09/04/play-with-k8s/"/>
    <id>http://divinerapier.github.io/2020/09/04/play-with-k8s/</id>
    <published>2020-09-04T00:08:52.000Z</published>
    <updated>2020-09-04T11:28:29.493Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://labs.play-with-k8s.com/" target="_blank" rel="noopener">Play with Kubernetes</a> 是一个可以在浏览器使用的 <code>CentOS</code> 虚拟机环境，允许用户通过 <code>github</code> 账号登录。在这里，用户可以部署，学习使用 <code>k8s</code>。</p><p>跳过前面一些很简单的操作。在左侧添加 4 台虚拟机。每一台新创建的虚拟机控制台界面会有如下的提示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> 1. Initializes cluster master node:</span><br><span class="line"></span><br><span class="line"> kubeadm init --apiserver-advertise-address $(hostname -i) --pod-network-cidr 10.5.0.0&#x2F;16</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 2. Initialize cluster networking:</span><br><span class="line"></span><br><span class="line">kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;cloudnativelabs&#x2F;kube-router&#x2F;master&#x2F;daemonset&#x2F;kubeadm-kuberouter.yaml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 3. (Optional) Create an nginx deployment:</span><br><span class="line"></span><br><span class="line"> kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;kubernetes&#x2F;website&#x2F;master&#x2F;content&#x2F;en&#x2F;examples&#x2F;application&#x2F;nginx-app.yaml</span><br></pre></td></tr></table></figure><h2 id="搭建-Kubernetes-环境"><a href="#搭建-Kubernetes-环境" class="headerlink" title="搭建 Kubernetes 环境"></a>搭建 Kubernetes 环境</h2><p>在 <code>node-1</code> 中执行第一条命令，创建 <code>Master</code> 节点(虽然有 BLM 运动，但我不在乎)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm init --apiserver-advertise-address $(hostname -i) --pod-network-cidr 10.5.0.0/16</span><br><span class="line">...</span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run <span class="string">"kubectl apply -f [podnetwork].yaml"</span> with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 192.168.0.38:6443 --token xguam5.v5vgzeifjipno115 \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:6ea81a284c1b7a5aeec9eb01c8856602f1f3e6f2edd5593816c27224bbccb960</span><br><span class="line">Waiting <span class="keyword">for</span> api server to startup</span><br><span class="line">Warning: kubectl apply should be used on resource created by either kubectl create --save-config or kubectl apply</span><br><span class="line">daemonset.apps/kube-proxy configured</span><br><span class="line">No resources found</span><br></pre></td></tr></table></figure><p>然后，从上述命令的输出中找到 <code>Worker</code> 节点加入 <code>Master</code> 节点的命令，在 <code>node[2-4]</code> 节点分别执行命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 192.168.0.38:6443 --token xguam5.v5vgzeifjipno115 \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:6ea81a284c1b7a5aeec9eb01c8856602f1f3e6f2edd5593816c27224bbccb960</span><br></pre></td></tr></table></figure><p>执行完成之后，<code>node[2-4]</code> 就成功加入了 <code>Kubernetes</code> 集群中。在 <code>Master</code> 节点，即 <code>node-1</code> 上执行命令验证:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes</span><br><span class="line">NAME    STATUS     ROLES    AGE   VERSION</span><br><span class="line">node1   Ready      master   14m   v1.18.4</span><br><span class="line">node2   Ready      &lt;none&gt;   12m   v1.18.4</span><br><span class="line">node3   NotReady   &lt;none&gt;   13s   v1.18.4</span><br><span class="line">node4   NotReady   &lt;none&gt;   5s    v1.18.4</span><br></pre></td></tr></table></figure><p>最后部署网络插件 <code>kube-router</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f https://raw.githubusercontent.com/cloudnativelabs/kube-router/master/daemonset/kubeadm-kuberouter.yaml</span><br><span class="line">configmap/kube-router-cfg unchanged</span><br><span class="line">daemonset.apps/kube-router configured</span><br><span class="line">serviceaccount/kube-router unchanged</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/kube-router unchanged</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/kube-router unchanged</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>部署完了，用去吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://labs.play-with-k8s.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Play with Kubernetes&lt;/a&gt; 是一个可以在浏览器使用的 &lt;code&gt;CentOS&lt;/code&gt; 虚拟机环境，允</summary>
      
    
    
    
    
    <category term="k8s" scheme="http://divinerapier.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Pod 的基本概念</title>
    <link href="http://divinerapier.github.io/2020/09/02/the-basics-of-pods/"/>
    <id>http://divinerapier.github.io/2020/09/02/the-basics-of-pods/</id>
    <published>2020-09-02T13:06:17.000Z</published>
    <updated>2020-09-04T00:42:23.296Z</updated>
    
    <content type="html"><![CDATA[<p>前文提到，可以类比于虚拟机与应用程序之间的关系来理解 <code>Pod</code> 与 <code>Container</code> 之间的关系。这样就可以容易理解 <strong>凡是调度、网络、存储，以及安全相关的属性，基本都是 Pod 级别的</strong>。</p><p>这些属性有一个共同点: 描述 <strong>机器</strong> 这个整体，而不是里面运行的 <strong>程序</strong>。比如:</p><ul><li>配置这个 <strong>机器</strong> 的网卡: <code>Pod</code> 的网络定义</li><li>配置这个 <strong>机器</strong> 的磁盘: <code>Pod</code> 的存储定义</li><li>配置这个 <strong>机器</strong> 的防火墙: <code>Pod</code> 的安全定义</li><li>这台 <strong>机器</strong> 运行在哪个服务器之上: <code>Pod</code> 的调度</li></ul><h2 id="NodeSelector"><a href="#NodeSelector" class="headerlink" title="NodeSelector"></a>NodeSelector</h2><p><code>NodeSelector</code> 是一个供用户将 <code>Pod</code> 与 <code>Node</code> 进行绑定的字段，用法如下所示:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="attr">nodeSelector:</span></span><br><span class="line">   <span class="attr">disktype:</span> <span class="string">ssd</span></span><br></pre></td></tr></table></figure><p>这样的一个配置，意味着这个 <code>Pod</code> 永远只能运行在携带了 <code>disktype: ssd</code> 标签 <code>(Label)</code> 的节点上。否则，将调度失败。</p><h2 id="NodeName"><a href="#NodeName" class="headerlink" title="NodeName"></a>NodeName</h2><p>当 <code>Kubernetes</code> 将 <code>Pod</code> 调度到某个 <code>Node</code> 上之后，会自动设置 <code>Pod</code> 的 <code>NodeName</code> 字段。即，<code>Kubernetes</code> 会认为所有已被赋值 <code>NodeName</code> 字段的 <code>Pod</code> 都是被调度过的。因此，通过用户也可以设置该字段来 <strong>骗过</strong> 调度器，比如在测试或者调试阶段。</p><h2 id="HostAliases"><a href="#HostAliases" class="headerlink" title="HostAliases"></a>HostAliases</h2><p><code>HostAliases</code> 定义 <code>Pod</code> 的 <code>hosts</code> 文件 <code>(比如 /etc/hosts)</code> 里的内容。</p><p>比如，在这个 <code>Pod</code> 的 <code>YAML</code> 文件中设置了一组 <code>IP</code> 和 <code>Hostname</code> 的数据。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hostAliases:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">ip:</span> <span class="string">"10.1.2.3"</span></span><br><span class="line">    <span class="attr">hostnames:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"foo.remote"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"bar.remote"</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>在 <code>Pod</code> 启动后，<code>/etc/hosts</code> 文件的内容将如下所示:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/hosts</span><br><span class="line"><span class="comment"># Kubernetes-managed hosts file.</span></span><br><span class="line">127.0.0.1 localhost</span><br><span class="line">...</span><br><span class="line">10.244.135.10 hostaliases-pod</span><br><span class="line">10.1.2.3 foo.remote</span><br><span class="line">10.1.2.3 bar.remote</span><br></pre></td></tr></table></figure><p>其中，最下面两行记录，就是通过 <code>HostAliases</code> 字段写入的。</p><p><strong>特别注意</strong>: 在 <code>Kubernetes</code> 中，强烈建议使用这种方式设置 hosts 文件里的内容。如果使用直接修改 <code>hosts</code> 文件的方式，在 <code>Pod</code> 被删除重建之后，<code>kubelet</code> 会还原被修改的内容。</p><h2 id="ShareProcessNamespace"><a href="#ShareProcessNamespace" class="headerlink" title="ShareProcessNamespace"></a>ShareProcessNamespace</h2><p><strong>凡是跟容器的 <code>Linux Namespace</code> 相关的属性，也一定是 <code>Pod</code> 级别的</strong>。</p><p>设计 <code>Pod</code> 的初衷，就是要让里面的容器尽可能多地共享 <code>Linux Namespace</code>，仅保留必要的隔离和限制能力。这样，<code>Pod</code> 之于 <code>Container</code> 就会更近似于虚拟机之于程序。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">shareProcessNamespace:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">shell</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">stdin:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><code>shareProcessNamespace: true</code> 表示: <code>Pod</code> 里的 <code>Containers</code> 要共享 <code>PID Namespace</code>。</p><h2 id="共享宿主机的-Namespace"><a href="#共享宿主机的-Namespace" class="headerlink" title="共享宿主机的 Namespace"></a>共享宿主机的 Namespace</h2><ul><li><strong>HostPID</strong> - 控制 Pod 中容器是否可以共享宿主上的进程 ID 空间。 注意，如果与 ptrace 相结合，这种授权可能被利用，导致向容器外的特权逃逸 (默认情况下 ptrace 是被禁止的)。</li><li><strong>HostIPC</strong> - 控制 Pod 容器是否可共享宿主上的 IPC 名字空间。</li><li><strong>HostNetwork</strong> - 控制是否 Pod 可以使用节点的网络名字空间。 此类授权将允许 Pod 访问本地回路 (loopback) 设备、在本地主机 (localhost) 上监听的服务、还可能用来监听同一节点上其他 Pod 的网络活动。</li><li><strong>HostPorts</strong> -提供可以在宿主网络名字空间中可使用的端口范围列表。 该属性定义为一组 HostPortRange 对象的列表，每个对象中包含 min(含) 与 max(含) 值的设置。 默认不允许访问宿主端口。</li></ul><p>例如:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hostIPC:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hostPID:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">shell</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">stdin:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h2><p><code>Container Lifecycle Hooks</code>。顾名思义，是在容器状态发生变化时触发一系列 <strong>钩子</strong>。我们来看这样一个例子:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">lifecycle-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">lifecycle-demo-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">lifecycle:</span></span><br><span class="line">      <span class="attr">postStart:</span></span><br><span class="line">        <span class="attr">exec:</span></span><br><span class="line">          <span class="attr">command:</span> <span class="string">["/bin/sh",</span> <span class="string">"-c"</span><span class="string">,</span> <span class="string">"echo Hello from the postStart handler &gt; /usr/share/message"</span><span class="string">]</span></span><br><span class="line">      <span class="attr">preStop:</span></span><br><span class="line">        <span class="attr">exec:</span></span><br><span class="line">          <span class="attr">command:</span> <span class="string">["/usr/sbin/nginx","-s","quit"]</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>PostStart</strong>: 这个回调在创建容器之后立即执行。 但是，不能保证回调会在容器入口点 <code>(ENTRYPOINT)</code> 之前执行。没有参数传递给处理程序。</p></li><li><p><strong>PreStop</strong>: 在容器因 API 请求或者管理事件 <strong>(诸如存活态探针失败、资源抢占、资源竞争等)</strong> 而被终止之前，此回调会被调用。如果容器已经处于终止或者完成状态，则对 preStop 回调的调用将失败。此调用是阻塞的，也是同步调用，因此必须在删除容器的调用之前完成。没有参数传递给处理程序。</p></li></ul><blockquote><p><code>Kubernetes</code> 只有在 <code>Pod</code> 结束 <strong>(Terminated)</strong> 的时候才会发送 preStop 事件，这意味着在 Pod 完成 <strong>(Completed)</strong> 时 preStop 的事件处理逻辑不会被触发。这个限制在 <a href="https://github.com/kubernetes/kubernetes/issues/55807" target="_blank" rel="noopener">issue #55087</a> 中被追踪。</p></blockquote><p>有关终止行为的更详细描述，请参见 <a href="https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-lifecycle/#termination-of-pods" target="_blank" rel="noopener">终止 Pod</a>。</p><h2 id="Status"><a href="#Status" class="headerlink" title="Status"></a>Status</h2><p>Pending。Pod 已被 Kubernetes 系统接受 <strong>(YAML 文件已经提交给了 Kubernetes)</strong>，但有一个或者多个容器尚未创建亦未运行。此阶段包括等待 Pod 被调度的时间和通过网络下载镜像的时间，</p><p>Running。Pod 已经绑定到了某个节点，Pod 中所有的容器都已被创建。至少有一个容器仍在运行，或者正处于启动或重启状态。</p><p>Succeeded。Pod 中的所有容器都已成功终止，并且不会再重启。这种情况在运行一次性任务时最为常见。</p><p>Failed。Pod 中的所有容器都已终止，并且至少有一个容器是因为失败终止。也就是说，容器以非 <code>0</code> 状态退出或者被系统终止。这个状态的出现，意味着你得想办法 Debug 这个容器的应用，比如查看 Pod 的 Events 和日志。</p><p>Unknown。这是一个异常状态，意味着 Pod 的状态不能持续地被 kubelet 汇报给 kube-apiserver，这很有可能是主从节点(Master 和 Kubelet)间的通信出现了问题。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://kubernetes.io/zh/docs/tasks/configure-pod-container/share-process-namespace/" target="_blank" rel="noopener">在 Pod 中的容器之间共享进程命名空间</a></li><li><a href="https://kubernetes.io/docs/tasks/configure-pod-container/share-process-namespace/" target="_blank" rel="noopener">Share Process Namespace between Containers in a Pod</a></li><li><a href="https://kubernetes.io/zh/docs/concepts/policy/pod-security-policy/" target="_blank" rel="noopener">Pod 安全策略</a></li><li><a href="https://kubernetes.io/docs/concepts/policy/pod-security-policy/" target="_blank" rel="noopener">Pod Security Policies</a></li><li><a href="https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-lifecycle/" target="_blank" rel="noopener">Pod 的生命周期</a></li><li><a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/" target="_blank" rel="noopener">Pod Lifecycle</a></li><li><a href="https://kubernetes.io/zh/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/" target="_blank" rel="noopener">为容器的生命周期事件设置处理函数</a></li><li><a href="https://kubernetes.io/zh/docs/concepts/containers/container-lifecycle-hooks/" target="_blank" rel="noopener">容器生命周期回调</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前文提到，可以类比于虚拟机与应用程序之间的关系来理解 &lt;code&gt;Pod&lt;/code&gt; 与 &lt;code&gt;Container&lt;/code&gt; 之间的关系。这样就可以容易理解 &lt;strong&gt;凡是调度、网络、存储，以及安全相关的属性，基本都是 Pod 级别的&lt;/strong&gt;。&lt;</summary>
      
    
    
    
    
    <category term="k8s" scheme="http://divinerapier.github.io/tags/k8s/"/>
    
    <category term="pod" scheme="http://divinerapier.github.io/tags/pod/"/>
    
  </entry>
  
  <entry>
    <title>让你的 Hexo 博客支持 RSS</title>
    <link href="http://divinerapier.github.io/2020/09/02/enable-rss-on-hexo/"/>
    <id>http://divinerapier.github.io/2020/09/02/enable-rss-on-hexo/</id>
    <published>2020-09-02T12:37:46.000Z</published>
    <updated>2020-09-02T12:50:44.937Z</updated>
    
    <content type="html"><![CDATA[<p>让博客支持 <code>RSS</code> 是一种美好的品德。</p><ul><li><p>安装 <code>RSS</code> 插件</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed</span><br></pre></td></tr></table></figure></li><li><p>配置博客 <code>_config.uml</code></p>  <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="attr">plugins:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo-generator-feed</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Feed Atom</span></span><br><span class="line"><span class="attr">feed:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure></li><li><p>配置主题 <code>_config.yml</code></p>  <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RSS订阅</span></span><br><span class="line"><span class="attr">rss:</span> <span class="string">/atom.xml</span></span><br></pre></td></tr></table></figure></li><li><p>客户端订阅</p><p>  使用 <code>RSS</code> 客户端订阅 <code>http(s)://${YOUR_BLOG_HOST}/atom.xml</code>。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;让博客支持 &lt;code&gt;RSS&lt;/code&gt; 是一种美好的品德。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安装 &lt;code&gt;RSS&lt;/code&gt; 插件&lt;/p&gt;
  &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter</summary>
      
    
    
    
    
    <category term="hexo" scheme="http://divinerapier.github.io/tags/hexo/"/>
    
    <category term="rss" scheme="http://divinerapier.github.io/tags/rss/"/>
    
  </entry>
  
  <entry>
    <title>Pod 的意义</title>
    <link href="http://divinerapier.github.io/2020/08/31/why-do-we-need-pods/"/>
    <id>http://divinerapier.github.io/2020/08/31/why-do-we-need-pods/</id>
    <published>2020-08-31T08:34:52.000Z</published>
    <updated>2020-09-01T09:43:04.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="容器的局限性"><a href="#容器的局限性" class="headerlink" title="容器的局限性"></a>容器的局限性</h2><p>既然要讨论 <code>Pod</code> 的意义，或许可以想象一个如果没有 <code>Pod</code> 会是什么样子。</p><p>假设，有如下需求: 使用容器化来部署一个支持自动更新数据的文件服务。可以使用如下方法解决:</p><ol><li>在一个容器中，同时运行两个进程，一个进程提供文件服务，一个进程定时更新数据。<ul><li>优点:<ol><li>无论是编码，还是部署都十分的容易，就像在物理机或者虚拟机里面一样</li></ol></li><li>缺点:<ol><li>容器的本质是进程，对操作系统而言是那个由 <code>entrypoint</code> 指定的进程，其他进程都是其子进程，或子进程的子进程等。而且，<code>entrypoint</code> 没有回收僵尸进程的能力。</li><li>耦合严重</li></ol></li></ul></li><li>每个进程分别位于各自的容器，两个容器之间通过挂载相同的外部 <code>volume</code> 实现容器间共享文件系统。<ul><li>优点:<ol><li>将两个容器解耦，保证功能单一性</li></ol></li><li>缺点:<ol><li>通过共享外部 <code>volume</code> 的方式无法保证数据安全性，其他容器，或宿主机也能直接访问 <code>volume</code></li></ol></li></ul></li><li>在上一个方法的基础上，通过 <code>--volume-from</code> 指定从其他的 <code>container</code> 挂载 <code>volume</code>。<ul><li>优点:<ol><li>避免对外直接暴露 <code>volume</code></li></ol></li></ul></li></ol><p>到此为止，一切似乎很顺利，没有在创建 <code>Pod</code> 这样一个新的概念。</p><p>但上述方案有一个局限性，<code>--volume-from</code> 的目标容器只能是本地的其他 <code>container</code>。</p><p>假设，使用 <code>Docker Swarm</code> 部署服务。为了便于叙述，做出如下定义:</p><ul><li>集群中存在两个节点。<strong><code>node-0</code></strong> 剩余 <code>2G</code> 内存，<strong><code>node-1</code></strong> 剩余 <code>1.5G</code> 内存</li><li>两个容器 <code>container-0</code> 与 <code>container-1</code> 各需要 <code>1G</code> 内存</li><li>部署过程，先启动 <code>container-0</code>，后启动 <code>container-1</code></li></ul><p>因此，为了让两个容器能够运行在同一个 <code>Node</code> 上，需要在启动 <code>container-1</code> 时增加限制 <code>affinity=container-0</code>。</p><p>此时，如果 <code>container-0</code> 被调度到了 <code>node-1</code> 上，<code>node-1</code> 将剩余 <code>0.5G</code> 内存。接下来，调度 <code>container-1</code> 时，<code>Docker Swarm</code> 就会发现无法找到一个合适的 <code>Node</code> 来启动 <code>container-1</code>。</p><p>以上问题被称作 <a href="https://en.wikipedia.org/wiki/Gang_scheduling" target="_blank" rel="noopener">Gang Scheduling</a>。</p><p>而 <code>Kuberntes</code> 则通过 <code>Pod</code> 解决了这个问题。</p><p><code>Pod</code> 是 <code>Kubernetes</code> 中最小的可调度计算单元。在处理上述问题中，如果将 <code>container-0</code> 与 <code>container-1</code> 同时包含在一个 <code>Pod</code> 中，<code>Kubernetes</code> 在调度这个 <code>Pod</code> 时就只会考虑剩余内存不小于 <code>2G</code> 的 <code>node-0</code>。</p><p>对于上面这种，相互之间直接访问文件系统、使用 <code>localhost</code> 或 <code>socket</code> 文件进行本地通信，共享某些 <code>Namespace</code> 的一组容器，称之为 <strong>超亲密关系</strong>。</p><h2 id="Pod-实现原理"><a href="#Pod-实现原理" class="headerlink" title="Pod 实现原理"></a>Pod 实现原理</h2><p><code>Pod</code> 是一个逻辑概念。其本质是一组共享了 <code>Network Namespace</code>，并且可以声明共享同一个 <code>Volume</code> 的容器。</p><p>比如，一个包含了 <code>A</code> 与 <code>B</code> 两个容器的 <code>Pod</code>，按照 <a href="https://kubernetes.io/docs/concepts/workloads/pods/#what-is-a-pod" target="_blank" rel="noopener">定义</a> 的描述，可以使用如下 <code>Docker</code> 命令模拟:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># start container A</span></span><br><span class="line">$ docker run --net=B --volumes-from=B --name=A image-A ...</span><br></pre></td></tr></table></figure><p>但此时会发现，<code>Pod</code> 内的一组容器要遵循某个特定的顺序启动，容器与容器之间不再是对等关系，而是拓扑关系。</p><p>所以，在 <code>Kubernetes</code> 项目里，通过增加一个被称作 <code>Infra</code> 的容器作为 <code>Pod</code> 里第一个启动的容器。用户定义的其他容器通过 <code>Join Network Namespace</code> 的方式，关联到 <code>Infra</code> 容器。这样的组织关系，可以用下面这样一个示意图来表达:</p><p><img src="/images/why-do-we-need-pods/01.png" alt="pause container"></p><p>如上图所示，这个 <code>Pod</code> 里有两个用户容器 <code>A</code> 和 <code>B</code>，还有一个 <code>Infra</code> 容器。这个特殊容器的镜像地址为 <code>k8s.gcr.io/pause</code>，源代码位于 <a href="https://github.com/kubernetes/kubernetes/blob/master/build/pause/pause.c" target="_blank" rel="noopener">github</a>。同时，<code>kubelet</code> 提供参数 <code>--pod-infra-container-image</code> 支持自定义镜像。</p><p>所以，当容器 <code>A</code>、<code>B</code> 加入到 <code>Infra</code> 容器的 <code>Network Namespace</code> 后，对于容器 <code>A</code>、<code>B</code> 而言:</p><ul><li>可以直接使用 <code>localhost</code> 进行通信</li><li>看到的网络设备跟 <code>Infra</code> 容器看到的完全一样</li><li>一个 <code>Pod</code> 只有一个 <code>IP</code> 地址，也就是这个 <code>Pod</code> 的 <code>Network Namespace</code> 对应的 <code>IP</code> 地址</li><li>其他的所有网络资源，都是一个 <code>Pod</code> 一份，并且被该 <code>Pod</code> 中的所有容器共享</li><li><code>Pod</code> 的生命周期只跟 <code>Infra</code> 容器一致，而与容器 <code>A</code>、<code>B</code> 无关。</li></ul><p>而对于同一个 <code>Pod</code> 里面的所有用户容器来说，它们的进出流量，也可以认为都是通过 <code>Infra</code> 容器完成的。这一点很重要，因此为 <code>Kubernetes</code> 开发网络插件时，应该重点考虑的是如何配置这个 <code>Pod</code> 的 <code>Network Namespace</code>，而不是每一个用户容器如何使用网络配置。</p><p>而且，在这这个设计模型之下，可以方便的共享 <code>volume</code>: <code>Kubernetes</code> 项目只要把所有 <code>volume</code> 的定义都设计在 <code>Pod</code> 层级即可。之后，<code>Pod</code> 内的容器再声明挂载这个 <code>volume</code> 从而达到共享 <code>volume</code> 的目的。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">two-containers</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">shared-data</span></span><br><span class="line">    <span class="attr">hostPath:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/data</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">shared-data</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">debian-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">debian</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">shared-data</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/pod-data</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">["/bin/sh"]</span></span><br><span class="line">    <span class="attr">args:</span> <span class="string">["-c",</span> <span class="string">"echo Hello from the debian container &gt; /pod-data/index.html"</span><span class="string">]</span></span><br></pre></td></tr></table></figure><h2 id="容器设计模式"><a href="#容器设计模式" class="headerlink" title="容器设计模式"></a>容器设计模式</h2><p><code>Pod</code> 这种 <strong>超亲密关系</strong> 容器的设计思想，实际上就是希望，当用户想在一个容器里运行多个功能并不相关的应用时，应该优先考虑它们是不是更应该被描述成一个 <code>Pod</code> 里的多个容器。</p><p>要理解这个概念，也很容易。只需要将 <code>Pod</code> 理解为原来的虚拟机即可。</p><p>在虚拟机时代，服务之间也存在一定的关系。有上述那样需要共享本地文件系统的关系，也有 <code>API Service</code> 与 <code>DB</code> 之间的关系。</p><p>当需要考虑是否需要将多个容器描述成一个 <code>Pod</code> 时，可以想象一下: 如果使用虚拟机部署，是否应该将这些服务部署在同一台虚拟机上。如果需要部署在一台虚拟机才能工作，那么就需要描述为一个 <code>Pod</code>。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://kubernetes.io/docs/concepts/workloads/pods/" target="_blank" rel="noopener">Kuberntes Documentation: Pod</a></li><li><a href="https://cloud.tencent.com/developer/article/1513369" target="_blank" rel="noopener">为什么说容器是单进程模型</a></li><li><a href="https://forums.docker.com/t/use-affinity-filter-in-docker-service-create/78402" target="_blank" rel="noopener">Use “affinity filter” in “docker service create”</a></li><li><a href="https://www.ianlewis.org/en/almighty-pause-container" target="_blank" rel="noopener">The Almighty Pause Container</a></li><li><a href="https://developers.redhat.com/blog/2019/01/15/podman-managing-containers-pods/" target="_blank" rel="noopener">Podman: Managing pods and containers in a local container runtime</a></li><li><a href="https://www.usenix.org/system/files/conference/hotcloud16/hotcloud16_burns.pdf" target="_blank" rel="noopener">Design patterns for container-based distributed systems</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;容器的局限性&quot;&gt;&lt;a href=&quot;#容器的局限性&quot; class=&quot;headerlink&quot; title=&quot;容器的局限性&quot;&gt;&lt;/a&gt;容器的局限性&lt;/h2&gt;&lt;p&gt;既然要讨论 &lt;code&gt;Pod&lt;/code&gt; 的意义，或许可以想象一个如果没有 &lt;code&gt;Pod&lt;/cod</summary>
      
    
    
    
    
    <category term="kubernetes" scheme="http://divinerapier.github.io/tags/kubernetes/"/>
    
    <category term="pod" scheme="http://divinerapier.github.io/tags/pod/"/>
    
  </entry>
  
  <entry>
    <title>Log Structured Merge Trees</title>
    <link href="http://divinerapier.github.io/2020/08/26/log-structured-merge-trees/"/>
    <id>http://divinerapier.github.io/2020/08/26/log-structured-merge-trees/</id>
    <published>2020-08-26T13:37:03.000Z</published>
    <updated>2020-09-02T12:59:36.887Z</updated>
    
    <content type="html"><![CDATA[<p>转自 <a href="https://medium.com/swlh/log-structured-merge-trees-9c8e2bea89e8" target="_blank" rel="noopener">Log Structured Merge Trees</a>。</p><p>LSM tree is at the heart of most storage systems that provide high write throughput, be it a key-value storage like dynamodb/cassandra or a messaging system like pulsar which is backed by bookkeeper.</p><p>The various components of a typical LSM backed system are shown below.</p><p><img src="/images/log-structured-merge-trees/01.png" alt="01"></p><p>The main reason why LSM provides high write throughput is that every write request is actually performed only <strong>in-memory</strong> in contrast to traditional B-Tree based implementation where the updates are done to disk which can trigger an update to an index making it very expensive.</p><p>So the obvious question is, how does LSM achieve durability? that’s where WAL comes into the picture.</p><h2 id="WAL"><a href="#WAL" class="headerlink" title="WAL"></a>WAL</h2><p>WAL is a write-ahead log that is used to provide the durability of data during system failures, what it means is that when a request for write comes in, the data is first added to a WAL file (sometimes called journal) and flushed to the disk (using <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/5/html/global_file_system/s1-manage-direct-io" target="_blank" rel="noopener">direct io</a>) before updating the in-memory data structure.</p><p>This allows for systems to recover from the WAL if it crashes before persisting the in-memory data structure to disk.</p><p>Why not directly update the write to the disk instead of updating WAL? it’s because WAL updates are cheaper as it’s append-only and doesn’t require any restructuring of data on disk.</p><h2 id="MemTable"><a href="#MemTable" class="headerlink" title="MemTable"></a>MemTable</h2><p>The in-memory data structure is called a memtable, there are various implementations of memtable, but you can think of memtable as just a binary search tree for the sake of simplicity.</p><p>So now for every write request, the data is appended to WAL and the memtable is updated and a successful response is returned to the client.</p><p>For java implementations, the memtable is usually stored off-heap (direct memory) to avoid GC load</p><h2 id="SSTable-Sorted-Strings-Table"><a href="#SSTable-Sorted-Strings-Table" class="headerlink" title="SSTable (Sorted Strings Table)"></a>SSTable (Sorted Strings Table)</h2><p>As it’s obvious that we cannot keep adding data to memtable to bloat the RAM, the memtable is frequently flushed to disk as an SSTable.</p><p>SSTable, as the name indicates, is a sorted array of keys persisted on disk.</p><p>The reason it is sorted is to make it easy to look up the data for readings.</p><p>Okay, now that is the essence of how LSM provides high throughput using a WAL, MemTable &amp; SSTable.</p><p>Usually, even every delete request for a key is also added to memtable with a marker indicating it’s deleted and the same information is flushed to the SSTable.</p><h2 id="Compactor"><a href="#Compactor" class="headerlink" title="Compactor"></a>Compactor</h2><p>As we keep flushing SSTables to disk, the same key may be present in multiple SSTables, although the latest data of a key is present in the most recent SSTable, it’s presence in all previous SSTable needs to be cleaned up.</p><p>This is the job of a compactor which usually runs in the background, It merges SSTables by removing redundant &amp; deleted keys and creating a compacted/merged SSTables.</p><p>the compactor also is responsible for updating an index (typical B-Tree based index) to locate SSTable a key is present in.</p><h2 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><p>The index data structure created is used to locate the correct SSTable for a key, once an SSTable is located, it is easy to locate the actual key inside the SSTable as it’s sorted, a binary search in-memory is sufficient.</p><p>Also, the size of SSTables is chosen in such a way that it corresponds to the operating system <a href="https://en.wikipedia.org/wiki/Page_(computer_memory)" target="_blank" rel="noopener">page size</a> (usually multiples of disk bock size) making it easier to load the data to memory faster.</p><p>Although the Index along with SSTable help in faster lookup of keys, all read requests are first consulted in the memtable as it should contain the most recent change. If the key is not in the memtable, then the index is used to identify the possible SSTable the key may be present and then search inside the SSTable in-memory.</p><p>Since every read has to check the memtable, index &amp; SSTable to look for a key, it makes read requests very expensive especially for keys that are not present!</p><p>For keys that are recently updated, the read request will easily locate it in the memtable, but for keys not recently updated, and for keys that are not present in the system the read path is expensive!</p><p>Bloom Filters are used to improve read performance especially for the cases where the key is not present in the system.</p><h2 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h2><p>A Bloom filter is a probabilistic data structure, which at a high level helps you check if a key is present or not in the system with O(1) complexity in memory.</p><p>With bloom filter, False positive match is possible, which means, it may indicate a key is present although it’s not in the system. But false-negative match won’t happen, which means if bloom filter indicates a key is not present, then it is definitely not present in the system, so we could avoid taking the expensive read path.</p><p>So the presence of a bloom filter improves the read performance for keys that are missing in the system but for the keys that are present in the system, the read is still expensive as we have to look into the memtable, index and the SSTable.</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>So every time you come across a system that promises high write throughput, you can assume there will be a variant of LSM tree underneath that helps achieve the throughput and also understand why reads are expensive.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;转自 &lt;a href=&quot;https://medium.com/swlh/log-structured-merge-trees-9c8e2bea89e8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Log Structured Merge Trees&lt;/a</summary>
      
    
    
    
    
    <category term="lsm tree" scheme="http://divinerapier.github.io/tags/lsm-tree/"/>
    
    <category term="sstable" scheme="http://divinerapier.github.io/tags/sstable/"/>
    
    <category term="storage engine" scheme="http://divinerapier.github.io/tags/storage-engine/"/>
    
  </entry>
  
  <entry>
    <title>容器编排与 Kubernetes</title>
    <link href="http://divinerapier.github.io/2020/08/24/container-orchestration-and-kubernetes/"/>
    <id>http://divinerapier.github.io/2020/08/24/container-orchestration-and-kubernetes/</id>
    <published>2020-08-24T12:58:07.000Z</published>
    <updated>2020-08-26T14:32:00.065Z</updated>
    
    <content type="html"><![CDATA[<p><code>Docker</code> 容器依托于 <code>Linux Namespace</code>、<code>Cgroup</code>、<code>rootfs</code> 三方面，在宿主机之上为用户构建出互相隔离的进程运行环境。</p><ul><li><code>rootfs</code> 作为容器镜像，是静态视图；</li><li><code>Namespace</code> + <code>Cgroup</code> 提供运行时隔离环境，是动态视图。</li></ul><p>显而易见，对于开发者而言，他们更关注于容器镜像。容器镜像，可以看做是以前的应用程序，它由开发者负责构建，并在开发、测试、发布等各个环节之间作为最核心的组件。</p><p>在这种前提之下，云服务提供商的职责就从原来的 <strong>将用户提交的应用在虚拟机上运行起来</strong>，转变为 <strong>将用户提交的镜像以容器的方式运行起来</strong>。</p><p>因此，整个生态必将以容器镜像为核心连接点，在生态链路的各个节点，如 <code>CI/CD</code>、监控、安全、网络、存储等，都需要转变为以容器镜像为根本。这将是一次云服务平台的结构化升级。</p><p>容器从一个开发者手里的小工具，一跃成为了云计算领域的绝对主角；而能够定义容器组织和管理规范的 <strong>容器编排</strong> 技术，则当仁不让地坐上了容器技术领域的 <strong>头把交椅</strong>。这其中，其中翘楚当属 <code>Docker</code> 公司的 <code>Compose+Swarm</code> 组合，以及 <code>Google</code> 与 <code>RedHat</code> 公司共同主导的 <code>Kubernetes</code> 项目。</p><h2 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h2><p><code>Kubernetes</code> 项目脱胎于 <code>Google</code> 的核心系统 <code>Borg</code>，在项目初期有有着很强的技术理论指导。</p><p><code>Borg</code> 系统，一直以来都被誉为 <code>Google</code> 公司内部最强大的 <strong>秘密武器</strong>。虽然略显夸张，但这个说法倒不算是吹牛。因为，相比于 <code>Spanner</code>、<code>BigTable</code> 等相对上层的项目，<code>Borg</code> 要承担的责任，是承载 <code>Google</code> 公司整个基础设施的核心依赖。在 <code>Google</code> 公司已经公开发表的基础设施体系论文中，<code>Borg</code> 项目当仁不让地位居整个基础设施技术栈的最底层。</p><p><img src="/images/container-orchestration-and-kubernetes/google-stack.png" alt="google-stack"></p><p>上图，来自于 <code>Google Omega</code> 论文的第一作者的博士毕业论文。它描绘了当时 <code>Google</code> 已经公开发表的整个基础设施栈。在这个图里，你既可以找到 <code>MapReduce</code>、<code>BigTable</code> 等知名项目，也能看到 <code>Borg</code> 和它的继任者 <code>Omega</code> 位于整个技术栈的最底层。</p><p>正是由于这样的定位，<code>Borg</code> 可以说是 <code>Google</code> 最不可能开源的一个项目。而幸运的是，得益于 <code>Docker</code> 项目和容器技术的风靡，它终于得以以另一种方式与开源社区见面，这个方式就是 <code>Kubernetes</code> 项目。</p><p>所以，相比于 <strong>小打小闹</strong> 的 <code>Docker</code> 公司、<strong>旧瓶装新酒</strong> 的 <code>Mesos</code> 社区，<strong><code>Kubernetes</code> 项目从一开始就比较幸运地站上了一个他人难以企及的高度</strong>: 在它的成长阶段，这个项目每一个核心特性的提出，几乎都脱胎于 <code>Borg/Omega</code> 系统的设计与经验。更重要的是，这些特性在开源社区落地的过程中，又在整个社区的合力之下得到了极大的改进，修复了很多当年遗留在 <code>Borg</code> 体系中的缺陷和问题。</p><p>所以，尽管在发布之初被批评是 <strong>曲高和寡</strong>，但是在逐渐觉察到 <code>Docker</code> 技术栈的 <strong>稚嫩</strong> 和 <code>Mesos</code> 社区的 <strong>老迈</strong> 之后，这个社区很快就明白了: <code>Kubernetes</code> 项目在 <code>Borg</code> 体系的指导下，体现出了一种独有的 <strong>先进性</strong> 与 <strong>完备性</strong>，而这些特质才是一个基础设施领域开源项目赖以生存的核心价值。</p><h2 id="Kubernetes-解决了什么问题"><a href="#Kubernetes-解决了什么问题" class="headerlink" title="Kubernetes 解决了什么问题"></a>Kubernetes 解决了什么问题</h2><p>在说明 <code>Kubernetes</code> 解决了什么问题之前，先来讨论一下，用户期望 <code>Kubernetes</code> 有什么样的功能。</p><p>对于大多数用户来说，他们希望 <code>Kubernetes</code> 项目带来的体验是确定的: 现在我有了应用的容器镜像，请帮我在一个给定的集群上把这个应用运行起来。</p><p>更进一步地说，还希望 <code>Kubernetes</code> 能给我提供路由 <strong>网关</strong>、<strong>水平扩展</strong>、<strong>监控</strong>、<strong>备份</strong>、<strong>灾难恢复</strong> 等一系列运维能力。</p><p>解决发现，这就是对于 <code>PaaS(Cloud Foundry)</code> 同等的诉求。</p><p>但是，这些功能完全可以通过 <code>Docker</code> 及其生态圈 <code>Docker Compose</code> + <code>Docker Swarm</code> 自行实现，完全不知道实现一个 <strong>百万行代码量级</strong> 的 <code>Kubernetes</code></p><p>所以说，如果 <code>Kubernetes</code> 项目只是停留在拉取用户镜像、运行容器，以及提供常见的运维功能的话，那么别说跟 <strong>原生</strong> 的 <code>Docker Swarm</code> 项目竞争了，哪怕跟经典的 <code>PaaS</code> 项目相比也难有什么优势可言。</p><p>而实际上，在定义核心功能的过程中，<code>Kubernetes</code> 项目是站在巨人 <code>Borg</code> 项目的肩膀之上，凭借 <code>Borg</code> 超前的理论优势，在短短几个月内迅速站稳了脚跟，进而确定了一个如下图所示的全局架构:</p><p><img src="/images/container-orchestration-and-kubernetes/k8s-architecture.png" alt="k8s-architecture"></p><p>可以看到，<code>Kubernetes</code> 项目的架构与原型项目 <code>Borg</code> 非常类似，都由 <code>Master</code> 和 <code>Node</code> 两种节点组成，分别用作控制节点和计算节点。</p><p>其中，控制节点，即 <code>Master</code> 节点，由 <strong>三个</strong> 紧密协作的独立组件组合而成，它们分别是<strong>负责 <code>API</code> 服务的 <code>kube-apiserver</code></strong>、<strong>负责调度的 <code>kube-scheduler</code></strong>，以及 <strong>负责容器编排的 <code>kube-controller-manager</code></strong>。整个集群的持久化数据，由 <code>kube-apiserver</code> 处理后保存在 <code>ETCD</code> 中。</p><p>而计算节点上最核心的部分，则是一个叫作 <code>kubelet</code> 的组件。</p><p>在 <code>Kubernetes</code> 项目中，<code>kubelet</code> 主要负责同容器运行时(比如 <code>Docker</code> 项目)打交道。而这个交互所依赖的，是一个称作 <code>CRI(Container Runtime Interface)</code> 的远程调用接口，这个接口定义了容器运行时的各项核心操作，比如: 启动一个容器需要的所有参数。</p><p>这也是为何，<code>Kubernetes</code> 项目并不关心你部署的是什么容器运行时、使用的什么技术实现，只要你的这个容器运行时能够运行标准的容器镜像，它就可以通过实现 <code>CRI</code> 接入到 <code>Kubernetes</code> 项目当中。</p><p>而具体的容器运行时，比如 <code>Docker</code> 项目，则一般通过 <code>OCI</code> 这个容器运行时规范同底层的 <code>Linux</code> 操作系统进行交互，即: 把 <code>CRI</code> 请求翻译成对 <code>Linux</code> 操作系统的调用(操作 <code>Linux Namespace</code> 和 <code>Cgroups</code> 等)。</p><p>此外，<code>kubelet</code> 还通过 <code>gRPC</code> 协议同一个叫作 <code>Device Plugin</code> 的插件进行交互。这个插件，是 <code>Kubernetes</code> 项目用来管理 <code>GPU</code> 等宿主机物理设备的主要组件，也是基于 <code>Kubernetes</code> 项目进行机器学习训练、高性能作业支持等工作必须关注的功能。</p><p>而 <code>kubelet</code> 的另一个重要功能，则是调用网络插件和存储插件为容器配置网络和持久化存储。这两个插件与 <code>kubelet</code> 进行交互的接口，分别是 <code>CNI(Container Networking Interface)</code>和 <code>CSI(Container Storage Interface)</code>。</p><p>实际上，<code>kubelet</code> 这个奇怪的名字，来自于 <code>Borg</code> 项目里的同源组件 <code>Borglet</code>。不过，如果你浏览过 <code>Borg</code> 论文的话，就会发现，这个命名方式可能是 <code>kubelet</code> 组件与 <code>Borglet</code> 组件的唯一相似之处。因为 <code>Borg</code> 项目，并不支持我们这里所讲的容器技术，而只是简单地使用了 <code>Linux Cgroups</code> 对进程进行限制。</p><p>这就意味着，像 <code>Docker</code> 这样的“容器镜像”在 <code>Borg</code> 中是不存在的，<code>Borglet</code> 组件也自然不需要像 <code>kubelet</code> 这样考虑如何同 <code>Docker</code> 进行交互、如何对容器镜像进行管理的问题，也不需要支持 <code>CRI</code>、<code>CNI</code>、<code>CSI</code> 等诸多容器技术接口。</p><p>可以说，<code>kubelet</code> 完全就是为了实现 <code>Kubernetes</code> 项目对容器的管理能力而重新实现的一个组件，与 <code>Borg</code> 之间并没有直接的传承关系。</p><p>那么，<code>Borg</code> 对于 <code>Kubernetes</code> 项目的指导作用又体现在哪里呢？</p><p>答案是，<code>Master</code> 节点。</p><p>虽然在 <code>Master</code> 节点的实现细节上 <code>Borg</code> 项目与 <code>Kubernetes</code> 项目不尽相同，但它们的出发点却高度一致，即: <strong>如何编排、管理、调度用户提交的作业</strong>。</p><p>所以，<code>Borg</code> 项目完全可以把 <code>Docker</code> 镜像看作一种新的应用打包方式。这样，<code>Borg</code> 团队过去在大规模作业管理与编排上的经验就可以直接 <strong>套</strong> 在 <code>Kubernetes</code> 项目上了。</p><p>这些经验最主要的表现就是，从一开始，<code>Kubernetes</code> 项目就没有像同时期的各种 <strong>容器云</strong> 项目那样，把 <code>Docker</code> 作为整个架构的核心，而仅仅把它作为最底层的一个容器运行时实现。</p><p>而 <code>Kubernetes</code> 项目要着重解决的问题，则来自于 <code>Borg</code> 的研究人员在论文中提到的一个非常重要的观点:</p><blockquote><p>运行在大规模集群中的各种任务之间，实际上存在着各种各样的关系。这些关系的处理，才是作业编排和管理系统最困难的地方。</p></blockquote><p>事实也正是如此。</p><p>其实，这种任务与任务之间的关系，在我们平常的各种技术场景中随处可见。比如，一个 <code>Web</code> 应用与数据库之间的访问关系，一个负载均衡器和它的后端服务之间的代理关系，一个门户应用与授权组件之间的调用关系。</p><p>更进一步地说，同属于一个服务单位的不同功能之间，也完全可能存在这样的关系。比如，一个 <code>Web</code> 应用与日志搜集组件之间的文件交换关系。</p><p>而在容器技术普及之前，传统虚拟机环境对这种关系的处理方法都是比较“粗粒度”的。你会经常发现很多功能并不相关的应用被一股脑儿地部署在同一台虚拟机中，只是因为它们之间偶尔会互相发起几个 <code>HTTP</code> 请求。</p><p>更常见的情况则是，一个应用被部署在虚拟机里之后，你还得手动维护很多跟它协作的守护进程 <code>(Daemon)</code>，用来处理它的日志搜集、灾难恢复、数据备份等辅助工作。</p><p>但容器技术出现以后，你就不难发现，在 <strong>功能单位</strong> 的划分上，容器有着独一无二的 <strong>细粒度</strong> 优势: 毕竟容器的本质，只是一个进程而已。</p><p>也就是说，只要你愿意，那些原先拥挤在同一个虚拟机里的各个应用、组件、守护进程，都可以被分别做成镜像，然后运行在一个个专属的容器中。它们之间互不干涉，拥有各自的资源配额，可以被调度在整个集群里的任何一台机器上。而这，正是一个 <code>PaaS</code> 系统最理想的工作状态，也是所谓“微服务”思想得以落地的先决条件。</p><p>当然，如果只做到 <strong>封装微服务、调度单容器</strong> 这一层次，<code>Docker Swarm</code> 项目就已经绰绰有余了。如果再加上 <code>Compose</code> 项目，你甚至还具备了处理一些简单依赖关系的能力，比如：一个 <strong>Web 容器</strong> 和它要访问的数据库 <strong>DB 容器</strong>。</p><p>在 <code>Compose</code> 项目中，你可以为这样的两个容器定义一个 <code>link</code>，而 <code>Docker</code> 项目则会负责维护这个 <strong>link</strong> 关系，其具体做法是: <code>Docker</code> 会在 <code>Web</code> 容器中，将 <code>DB</code> 容器的 <code>IP</code> 地址、端口等信息以环境变量的方式注入进去，供应用进程使用，比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DB_NAME&#x3D;&#x2F;web&#x2F;db</span><br><span class="line">DB_PORT&#x3D;tcp:&#x2F;&#x2F;172.17.0.5:5432</span><br><span class="line">DB_PORT_5432_TCP&#x3D;tcp:&#x2F;&#x2F;172.17.0.5:5432</span><br><span class="line">DB_PORT_5432_TCP_PROTO&#x3D;tcp</span><br><span class="line">DB_PORT_5432_TCP_PORT&#x3D;5432</span><br><span class="line">DB_PORT_5432_TCP_ADDR&#x3D;172.17.0.5</span><br></pre></td></tr></table></figure><p>而当 DB 容器发生变化时(比如，镜像更新，被迁移到其他宿主机上等等)，这些环境变量的值会由 <code>Docker</code> 项目自动更新。这就是平台项目自动地处理容器间关系的典型例子。</p><p>可是，如果我们现在的需求是，要求这个项目能够处理前面提到的所有类型的关系，甚至还要能够支持未来可能出现的更多种类的关系呢？</p><p>这时，<code>link</code> 这种单独针对一种案例设计的解决方案就太过简单了。如果你做过架构方面的工作，就会深有感触：一旦要追求项目的普适性，那就一定要从顶层开始做好设计。</p><p>所以，<code>Kubernetes</code> 项目最主要的设计思想是，从更宏观的角度，以统一的方式来定义任务之间的各种关系，并且为将来支持更多种类的关系留有余地。</p><p>比如，<code>Kubernetes</code> 项目对容器间的 <strong>访问</strong> 进行了分类，首先总结出了一类非常常见的“紧密交互”的关系，即：这些应用之间需要非常频繁的交互和访问；又或者，它们会直接通过本地文件进行信息交换。</p><p>在常规环境下，这些应用往往会被直接部署在同一台机器上，通过 <code>Localhost</code> 通信，通过本地磁盘目录交换文件。而在 <code>Kubernetes</code> 项目中，这些容器则会被划分为一个 <strong>Pod</strong>，<code>Pod</code> 里的容器共享同一个 <code>Network Namespace</code>、同一组数据卷，从而达到高效率交换信息的目的。</p><p><code>Pod</code> 是 <code>Kubernetes</code> 项目中最基础的一个对象，源自于 <code>Google Borg</code> 论文中一个名叫 <code>Alloc</code> 的设计。在后续的章节中，我们会对 <code>Pod</code> 做更进一步地阐述。</p><p>而对于另外一种更为常见的需求，比如 <strong>Web 应用</strong> 与 <strong>数据库</strong> 之间的访问关系，<code>Kubernetes</code> 项目则提供了一种叫作“Service”的服务。像这样的两个应用，往往故意不部署在同一台机器上，这样即使 <code>Web</code> 应用所在的机器宕机了，数据库也完全不受影响。可是，我们知道，对于一个容器来说，它的 <code>IP</code> 地址等信息不是固定的，那么 <code>Web</code> 应用又怎么找到数据库容器的 <code>Pod</code> 呢？</p><p>所以，Kubernetes 项目的做法是给 <code>Pod</code> 绑定一个 <code>Service</code> 服务，而 <code>Service</code> 服务声明的 <code>IP</code> 地址等信息是 <strong>终生不变</strong> 的。这个 <code>Service</code> 服务的主要作用，就是作为 <code>Pod</code> 的代理入口 <code>(Portal)</code>，从而代替 <code>Pod</code> 对外暴露一个固定的网络地址。</p><p>这样，对于 <code>Web</code> 应用的 <code>Pod</code> 来说，它需要关心的就是数据库 <code>Pod</code> 的 <code>Service</code> <code>信息。不难想象，Service</code> 后端真正代理的 <code>Pod</code> 的 <code>IP</code> 地址、端口等信息的自动更新、维护，则是 <code>Kubernetes</code> 项目的职责。</p><p>像这样，围绕着容器和 <code>Pod</code> 不断向真实的技术场景扩展，我们就能够摸索出一幅如下所示的 <code>Kubernetes</code> 项目核心功能的“全景图”。</p><p><img src="/images/container-orchestration-and-kubernetes/k8s-overview.png" alt="k8s-overview"></p><p>按照这幅图的线索，我们从容器这个最基础的概念出发，首先遇到了容器间“紧密协作”关系的难题，于是就扩展到了 <code>Pod</code>: 有了 <code>Pod</code> 之后，我们希望能一次启动多个应用的实例，这样就需要 <code>Deployment</code> 这个 <code>Pod</code> 的多实例管理器；而有了这样一组相同的 <code>Pod</code> 后，我们又需要通过一个固定的 <code>IP</code> 地址和端口以负载均衡的方式访问它，于是就有了 <code>Service</code>。</p><p>可是，如果现在两个不同 <code>Pod</code> 之间不仅有“访问关系”，还要求在发起时加上授权信息。最典型的例子就是 <code>Web</code> 应用对数据库访问时需要 <code>Credential</code>(数据库的用户名和密码)信息。那么，在 <code>Kubernetes</code> 中这样的关系又如何处理呢？</p><p><code>Kubernetes</code> 项目提供了一种叫作 <code>Secret</code> 的对象，它其实是一个保存在 <code>Etcd</code> 里的键值对数据。这样，你把 <code>Credential</code> 信息以 <code>Secret</code> 的方式存在 <code>Etcd</code> <code>里，Kubernetes</code> 就会在你指定的 <code>Pod</code>(比如，<code>Web</code> 应用的 <code>Pod</code>)启动时，自动把 <code>Secret</code> 里的数据以 <code>Volume</code> 的方式挂载到容器里。这样，这个 <code>Web</code> 应用就可以访问数据库了。</p><p>除了应用与应用之间的关系外，应用运行的形态是影响 <strong>如何容器化这个应用</strong> 的第二个重要因素。</p><p>为此，<code>Kubernetes</code> 定义了新的、基于 <code>Pod</code> 改进后的对象。比如 <code>Job</code>，用来描述一次性运行的 <code>Pod</code>(比如，大数据任务): 再比如 <code>DaemonSet</code>，用来描述每个宿主机上必须且只能运行一个副本的守护进程服务: 又比如 <code>CronJob</code>，则用于描述定时任务等等。</p><p>如此种种，正是 <code>Kubernetes</code> 项目定义容器间关系和形态的主要方法。</p><p>可以看到，<code>Kubernetes</code> 项目并没有像其他项目那样，为每一个管理功能创建一个指令，然后在项目中实现其中的逻辑。这种做法，的确可以解决当前的问题，但是在更多的问题来临之后，往往会力不从心。</p><p>相比之下，在 <code>Kubernetes</code> 项目中，我们所推崇的使用方法是：</p><ul><li>首先，通过一个 <strong>编排对象</strong>，比如 <code>Pod</code>、<code>Job</code>、<code>CronJob</code> 等，来描述你试图管理的应用；</li><li>然后，再为它定义一些“服务对象”，比如 <code>Service</code>、<code>Secret</code>、<code>Horizontal Pod Autoscaler</code>(自动水平扩展器)等。这些对象，会负责具体的平台级功能。</li></ul><p>这种使用方法，就是所谓的 <strong>声明式 API</strong> 。这种 <code>API</code> 对应的 <strong>编排对象</strong> 和 <strong>服务对象</strong>，都是 <code>Kubernetes</code> 项目中的 <code>API</code> 对象<code>(API Object)</code>。</p><p>这就是 <code>Kubernetes</code> 最核心的设计理念，也是接下来我会重点剖析的关键技术点。</p><p>最后，我来回答一个更直接的问题: <code>Kubernetes</code> 项目如何启动一个容器化任务呢？</p><p>比如，我现在已经制作好了一个 <code>Nginx</code> 容器镜像，希望让平台帮我启动这个镜像。并且，我要求平台帮我运行两个完全相同的 <code>Nginx</code> 副本，以负载均衡的方式共同对外提供服务。</p><p>如果是自己 <code>DIY</code> 的话，可能需要启动两台虚拟机，分别安装两个 <code>Nginx</code>，然后使用 <code>keepalived</code> 为这两个虚拟机做一个虚拟 <code>IP</code>。</p><p>而如果使用 <code>Kubernetes</code> 项目呢？你需要做的则是编写如下这样一个 <code>YAML</code> 文件(比如名叫 nginx-deployment.yaml):</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.7.9</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>在上面这个 <code>YAML</code> 文件中，我们定义了一个 <code>Deployment</code> 对象，它的主体部分 <code>(spec.template 部分)</code> 是一个使用 <code>Nginx</code> 镜像的 <code>Pod</code>，而这个 <code>Pod</code> 的副本数是 2(replicas=2)。</p><p>然后执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f nginx-deployment.yaml</span><br></pre></td></tr></table></figure><p>这样，两个完全相同的 <code>Nginx</code> 容器副本就被启动了。</p><p>不过，这么看来，做同样一件事情，<code>Kubernetes</code> 用户要做的工作也不少嘛。</p><p>别急，在后续的讲解中，我会陆续介绍 <code>Kubernetes</code> 项目这种 <strong>声明式 API</strong> 的种种好处，以及基于它实现的强大的编排能力。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Kubernetes</code> 项目的本质，是为用户提供一个具有普遍意义的容器编排工具。</p><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><ul><li><a href="http://malteschwarzkopf.de/research/assets/google-stack.pdf" target="_blank" rel="noopener">The Google Stack</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;Docker&lt;/code&gt; 容器依托于 &lt;code&gt;Linux Namespace&lt;/code&gt;、&lt;code&gt;Cgroup&lt;/code&gt;、&lt;code&gt;rootfs&lt;/code&gt; 三方面，在宿主机之上为用户构建出互相隔离的进程运行环境。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    
    <category term="container orchestration" scheme="http://divinerapier.github.io/tags/container-orchestration/"/>
    
    <category term="kubernetes" scheme="http://divinerapier.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>CPU 平均工作负载</title>
    <link href="http://divinerapier.github.io/2020/08/22/load-average/"/>
    <id>http://divinerapier.github.io/2020/08/22/load-average/</id>
    <published>2020-08-22T14:48:39.000Z</published>
    <updated>2020-08-23T09:42:05.003Z</updated>
    
    <content type="html"><![CDATA[<p>当程序的性能未达到预期时，大多数开发者会选择使用 <code>top</code> 指令查看指标 <code>CPU</code> 使用率。其实，还有另一个有关 <code>CPU</code> 的重要指标: 平均负责 <code>(load average)</code>。</p><p>可以使用 <code>top</code> 指令，或者 <code>uptime</code> 指令查看:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$top</span></span><br><span class="line"></span><br><span class="line">top - 23:11:02 up 19 days, 12:05,  1 user,  load average: 1.25, 1.42, 1.29</span><br><span class="line">Tasks: 258 total,   2 running, 197 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  9.1 us,  6.8 sy,  0.3 ni, 78.1 id,  5.2 wa,  0.0 hi,  0.5 si,  0.0 st</span><br><span class="line">KiB Mem : 15871204 total,   508880 free,  1675924 used, 13686400 buff/cache</span><br><span class="line">KiB Swap:  2097148 total,  2096112 free,     1036 used. 14133480 avail Mem</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line"> 4812 root      20   0  271208 155208  36668 S  14.6  1.0   1078:57 rancher</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ uptime</span><br><span class="line"> 23:10:12 up 19 days, 12:05,  1 user,  load average: 1.65, 1.50, 1.31</span><br></pre></td></tr></table></figure><p>可以发现，<code>uptime</code> 指令的输出与 <code>top</code> 指令输出的第一行几乎一致。具体每一部分的含义为:</p><ul><li><strong>当前时间</strong>: 23:10:12</li><li><strong>运行时间</strong>: up 19 days, 12:05</li><li><strong>登录用户数量</strong>: 1 user</li><li><strong>平均负载</strong>: 过去 <strong>1min</strong>，<strong>3min</strong>，<strong>5min</strong> 的平均负载</li></ul><h2 id="什么是平均负载"><a href="#什么是平均负载" class="headerlink" title="什么是平均负载"></a>什么是平均负载</h2><p>首先，需要强调:</p><ul><li><strong>平均负载不等于 <code>CPU</code> 使用率！！！</strong></li><li><strong>平均负载不等于 <code>CPU</code> 使用率！！！</strong></li><li><strong>平均负载不等于 <code>CPU</code> 使用率！！！</strong></li></ul><p>而是，系统处于 <strong>可运行状态</strong> 和 <strong>不可中断状态</strong> 的平均进程数，即 <strong>平均活跃进程数</strong>。与 <code>CPU</code> 使用率没有直接关系。</p><ul><li><strong>可运行状态</strong>: 正在使用 <code>CPU</code> 或者正在等待 <code>CPU</code> 的进程。即 <code>ps</code> 指令显示为 <code>R</code> 状态 <code>(Running/Runable)</code> 的进程。</li><li><strong>不可中断状态</strong>: 处于内核态关键流程中的进程，且不可打断。比如最常见的是等待硬件设备的 <code>I/O</code> 响应，即 <code>ps</code> 指令中中看到的 <code>D</code> 状态 <code>(Uninterruptible Sleep/Disk Sleep)</code> 的进程。</li></ul><p>比如，当一个进程向磁盘读写数据时，为了保证数据的一致性，在得到磁盘回复前，它是不能被其他 <strong>进程</strong> 或者 <strong>中断</strong> 打断的，这个时候的进程就处于不可中断状态。如果此时的进程被打断了，就容易出现磁盘数据与进程数据不一致的问题。</p><p>所以，<strong>不可中断状态实际上是系统对进程和硬件设备的一种保护机制</strong>。</p><h2 id="评估平均负载"><a href="#评估平均负载" class="headerlink" title="评估平均负载"></a>评估平均负载</h2><p>可以简单的认为，平均负载就是活跃的进程数。所以，最理想的场景是每个 <code>CPU</code> 都只需要处理一个进程，即 <code>CPU</code> 数量等于平均负载值。</p><p>因此，在分析系统平均负载是否合理时，首先应该知道当前系统的 <code>CPU</code> 数量。</p><p>平均负载可以简单的认为是活跃进程数:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/cpuinfo | grep -i <span class="string">'model name'</span> | wc -l</span><br><span class="line">16</span><br></pre></td></tr></table></figure><p>之后，就可以通过比较 <code>CPU</code> 的数量与平均负载大小关系，确认系统是否过载。</p><p>同时，结合过去 <code>1min</code>，<code>5min</code>，<code>15min</code> 的系统负载，就可以推测出系统负载的变化趋势。</p><p>当平均负载超过 <code>CPU</code> <code>50%</code> 时，可以认为负载较高；当超过 <code>70%</code> 时，就应该开发分析导致高负载的原因。同时，也应该将平均负载作为一项监控指标。只有结合历史数据来分析才更有意义。</p><h2 id="平均负载与-CPU-使用率"><a href="#平均负载与-CPU-使用率" class="headerlink" title="平均负载与 CPU 使用率"></a>平均负载与 CPU 使用率</h2><p><strong>平均负载</strong> 表示为一定时间内，处于 <strong>可运行状态</strong> 和 <strong>不可中断状态</strong> 的进程数量。核心在于 <strong>进程数量</strong>。</p><ul><li><code>R</code> 状态: 运行状态，会使用到 <code>CPU</code></li><li><code>D</code> 状态: 不可中断状态，处于内核态等待 <code>I/O</code> 响应，不使用 <code>CPU</code>。</li></ul><p><strong><code>CPU</code> 使用率</strong> 表示为一定时间内 <code>CPU</code> 的繁忙情况。核心在于进程占用 <code>CPU</code> 的时间占总时间的百分比。</p><p>因此，应该将二者结合一起使用:</p><ul><li><code>CPU</code> 密集型进程，使用大量 <code>CPU</code> 会导致平均负载升高，此时这两者是一致的</li><li><code>I/O</code> 密集型进程，等待 <code>I/O</code> 会导致平均负载升高，但 <code>CPU</code> 使用率不一定很高</li><li>大量等待 <code>CPU</code> 的进程调度也会导致平均负载升高，此时的 <code>CPU</code> 使用率也会比较高。</li></ul><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>系统初始状态为:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ uptime</span><br><span class="line"> 16:39:57 up 1 day,  2:52,  0 users,  load average: 0.10, 0.05, 0.06</span><br></pre></td></tr></table></figure><h3 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S stress sysstat</span><br></pre></td></tr></table></figure><h3 id="CPU-密集型"><a href="#CPU-密集型" class="headerlink" title="CPU 密集型"></a>CPU 密集型</h3><p>首先，在 <code>Terminal No.1</code> 使用 <code>stress</code> 模拟一个 <code>CPU</code> 密集型进程:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ stress --cpu 1 --timeout 6000</span><br><span class="line">stress: info: [5049] dispatching hogs: 1 cpu, 0 io, 0 vm, 0 hdd</span><br></pre></td></tr></table></figure><p>然后，在 <code>Terminal No.2</code> 查看平均负载:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ watch -d uptime</span><br><span class="line">Every 2.0s: uptime                zephyrus: Sun Aug 23 16:44:30 2020</span><br><span class="line"></span><br><span class="line"> 16:44:30 up 1 day,  2:56,  0 users,  load average: 0.99, 0.62, 0.30</span><br></pre></td></tr></table></figure><p>可以观察到，<code>1min</code> 的平均负载有较大的变化。</p><p>接着，在 <code>Terminal No.3</code> 监控 <code>CPU</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ mpstat -P ALL 5</span><br><span class="line">Linux 4.19.104-microsoft-standard (zephyrus)    08/23/2020      _x86_64_        (16 CPU)</span><br><span class="line"></span><br><span class="line">04:44:59 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">04:45:04 PM  all    6.29    0.00    0.06    0.00    0.00    0.08    0.00    0.00    0.00   93.57</span><br><span class="line">04:45:04 PM    0    0.00    0.00    0.00    0.00    0.00    1.19    0.00    0.00    0.00   98.81</span><br><span class="line">04:45:04 PM    1  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line">04:45:04 PM    2    0.00    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00   99.80</span><br><span class="line">04:45:04 PM    3    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00</span><br><span class="line">04:45:04 PM    4    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00</span><br><span class="line">04:45:04 PM    5    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00</span><br><span class="line">04:45:04 PM    6    0.00    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00   99.80</span><br><span class="line">04:45:04 PM    7    0.40    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00   99.60</span><br><span class="line">04:45:04 PM    8    0.00    0.00    0.40    0.00    0.00    0.00    0.00    0.00    0.00   99.60</span><br><span class="line">04:45:04 PM    9    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00</span><br><span class="line">04:45:04 PM   10    0.20    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00   99.80</span><br><span class="line">04:45:04 PM   11    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00</span><br><span class="line">04:45:04 PM   12    0.00    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00   99.80</span><br><span class="line">04:45:04 PM   13    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00</span><br><span class="line">04:45:04 PM   14    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00</span><br><span class="line">04:45:04 PM   15    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00</span><br></pre></td></tr></table></figure><p><code>#1 CPU</code> 的 <code>%usr</code> 使用率为 <code>100。00</code>，而 <code>%sys</code> 与 <code>%iowait</code> 都是 <code>0.00</code>，说明 <code>#1 CPU</code> 正在处理 <code>CPU</code> 密集型的任务。</p><p>最后，在 <code>Terminal No.4</code> 中查找占用 <code>CPU</code> 的进程:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ pidstat -u 5 1</span><br><span class="line">Linux 4.19.104-microsoft-standard (zephyrus)    08/23/2020      _x86_64_        (16 CPU)</span><br><span class="line"></span><br><span class="line">04:46:58 PM   UID       PID    %usr %system  %guest   %<span class="built_in">wait</span>    %CPU   CPU  Command</span><br><span class="line">04:47:03 PM   977      5050  100.00    0.00    0.00    0.00  100.00     1  stress</span><br><span class="line">04:47:03 PM   977      5054    0.00    0.20    0.00    0.00    0.20     4  watch</span><br><span class="line"></span><br><span class="line">Average:      UID       PID    %usr %system  %guest   %<span class="built_in">wait</span>    %CPU   CPU  Command</span><br><span class="line">Average:      977      5050  100.00    0.00    0.00    0.00  100.00     -  stress</span><br><span class="line">Average:      977      5054    0.00    0.20    0.00    0.00    0.20     -  watch</span><br></pre></td></tr></table></figure><p>确认 <code>pid=5050</code> 的 <code>stress</code> 进程占用了 <code>100%</code> 的 <code>CPU</code>。</p><h3 id="I-O-密集型"><a href="#I-O-密集型" class="headerlink" title="I/O 密集型"></a>I/O 密集型</h3><p>等待一段时间，平均负载恢复正常之后。</p><p>首先，在 <code>Terminal No.1</code> 使用 <code>stress</code> 模拟一个 <code>I/O</code> 密集型进程:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ stress -i 1</span><br><span class="line">stress: info: [7126] dispatching hogs: 0 cpu, 1 io, 0 vm, 0 hdd</span><br></pre></td></tr></table></figure><p>然后，在 <code>Terminal No.2</code> 查看平均负载:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ watch -d uptime</span><br><span class="line">Every 2.0s: uptime                zephyrus: Sun Aug 23 17:11:31 2020</span><br><span class="line"></span><br><span class="line"> 17:11:31 up 1 day,  3:23,  0 users,  load average: 0.98, 0.60, 0.54</span><br></pre></td></tr></table></figure><p><code>1min</code> 的平均负载有所增加。</p><p>接着，在 <code>Terminal No.3</code> 监控 <code>CPU</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ mpstat -P ALL 5</span><br><span class="line">Linux 4.19.104-microsoft-standard (zephyrus)    08/23/2020      _x86_64_        (16 CPU)</span><br><span class="line"></span><br><span class="line">05:11:53 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">05:11:58 PM  all    0.09    0.00    0.64    0.01    0.00    0.05    0.00    0.00    0.00   99.21</span><br><span class="line">05:11:58 PM    0    0.00    0.00    0.20    0.00    0.00    0.20    0.00    0.00    0.00   99.59</span><br><span class="line">05:11:58 PM    1    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00</span><br><span class="line">05:11:58 PM    2    0.20    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00   99.60</span><br><span class="line">05:11:58 PM    3    0.00    0.00    6.76    0.20    0.00    0.00    0.00    0.00    0.00   93.04</span><br><span class="line">05:11:58 PM    4    0.00    0.00    0.43    0.00    0.00    0.65    0.00    0.00    0.00   98.92</span><br><span class="line">05:11:58 PM    5    0.00    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00   99.80</span><br><span class="line">05:11:58 PM    6    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00</span><br><span class="line">05:11:58 PM    7    1.00    0.00    1.40    0.00    0.00    0.00    0.00    0.00    0.00   97.60</span><br><span class="line">05:11:58 PM    8    0.00    0.00    0.40    0.00    0.00    0.00    0.00    0.00    0.00   99.60</span><br><span class="line">05:11:58 PM    9    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00</span><br><span class="line">05:11:58 PM   10    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00</span><br><span class="line">05:11:58 PM   11    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00</span><br><span class="line">05:11:58 PM   12    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00</span><br><span class="line">05:11:58 PM   13    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00</span><br><span class="line">05:11:58 PM   14    0.00    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00   99.80</span><br><span class="line">05:11:58 PM   15    0.20    0.00    0.40    0.00    0.00    0.00    0.00    0.00    0.00   99.40</span><br></pre></td></tr></table></figure><p>很遗憾，相比于 <code>CPU</code> 密集型的测试，<code>I/O</code> 本次测试的 <code>CPU</code> 变化不是特别明显。不过，还是可以发现 <code>#3 CPU</code> 的数据与其他 <code>CPU</code> 有一定的差别。</p><ol><li><code>%idle</code> 为 <code>93.04</code>，而其他的 <code>CPU</code> 该项数值均处于较高的水平</li><li><code>%sys</code> 为 <code>6.76</code>，远高于其他 <code>CPU</code></li><li><code>%iowait</code> 为 <code>0.20</code>，相对于其他 <code>CPU</code> 最高只有 <code>0.01</code>，可谓是高出了 <code>2000%</code></li></ol><p>最后，使用 <code>pidstat</code> 查找具体进程:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ pidstat -u 5 1</span><br><span class="line">Linux 4.19.104-microsoft-standard (zephyrus)    08/23/2020      _x86_64_        (16 CPU)</span><br><span class="line"></span><br><span class="line">05:13:36 PM   UID       PID    %usr %system  %guest   %<span class="built_in">wait</span>    %CPU   CPU  Command</span><br><span class="line">05:13:41 PM   977      3196    0.20    0.00    0.00    0.00    0.20     7  node</span><br><span class="line">05:13:41 PM   977      7127    0.00   15.00    0.00    0.20   15.00     3  stress</span><br><span class="line"></span><br><span class="line">Average:      UID       PID    %usr %system  %guest   %<span class="built_in">wait</span>    %CPU   CPU  Command</span><br><span class="line">Average:      977      3196    0.20    0.00    0.00    0.00    0.20     -  node</span><br><span class="line">Average:      977      7127    0.00   15.00    0.00    0.20   15.00     -  stress</span><br></pre></td></tr></table></figure><p>发现 <code>stress</code> 进程的指标为 <code>%system = 15.00</code>，<code>%wait = 0.20</code>，<code>%CPU = 15.00</code>。</p><h3 id="大量进程"><a href="#大量进程" class="headerlink" title="大量进程"></a>大量进程</h3><p>因为，测试机有 16 个 <code>CPU</code> 核心，所以，在 <code>Terminal 1</code> 上模拟 <code>64</code> 个进程:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ stress -c 64 --timeout 6000</span><br><span class="line">stress: info: [7847] dispatching hogs: 64 cpu, 0 io, 0 vm, 0 hdd</span><br></pre></td></tr></table></figure><p>然后，在 <code>Terminal 2</code> 上查看平均负载:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ watch -d uptime</span><br><span class="line">Every 2.0s: uptime                      zephyrus: Sun Aug 23 17:32:28 2020</span><br><span class="line"></span><br><span class="line"> 17:32:28 up 1 day,  3:44,  0 users,  load average: 62.89, 35.44, 14.80</span><br></pre></td></tr></table></figure><p>接着，在 <code>Terminal 3</code> 查看 <code>CPU</code> 的状态:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ mpstat -P ALL 5</span><br><span class="line">Linux 4.19.104-microsoft-standard (zephyrus)    08/23/2020      _x86_64_        (16 CPU)</span><br><span class="line"></span><br><span class="line">05:31:42 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">05:31:47 PM  all   99.92    0.00    0.07    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line">05:31:47 PM    0   99.80    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line">05:31:47 PM    1  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line">05:31:47 PM    2  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line">05:31:47 PM    3   99.80    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line">05:31:47 PM    4  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line">05:31:47 PM    5  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line">05:31:47 PM    6   99.60    0.00    0.40    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line">05:31:47 PM    7  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line">05:31:47 PM    8  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line">05:31:47 PM    9  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line">05:31:47 PM   10  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line">05:31:47 PM   11  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line">05:31:47 PM   12   99.80    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line">05:31:47 PM   13  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line">05:31:47 PM   14   99.80    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line">05:31:47 PM   15  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br></pre></td></tr></table></figure><p>所有的 <code>CPU</code> 都处于满负载工作状态，除了 <code>%usr</code> 之外，只有 <code>%sys</code> 有少量数值。</p><p>最后，在 <code>Terminal 4</code> 查看进程状态:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">$ pidstat -u 5 1</span><br><span class="line">Linux 4.19.104-microsoft-standard (zephyrus)    08/23/2020      _x86_64_        (16 CPU)</span><br><span class="line"></span><br><span class="line">05:33:00 PM   UID       PID    %usr %system  %guest   %<span class="built_in">wait</span>    %CPU   CPU  Command</span><br><span class="line">05:33:05 PM   977      7848   25.00    0.00    0.00   75.00   25.00     4  stress</span><br><span class="line">05:33:05 PM   977      7849   25.00    0.00    0.00   74.60   25.00     3  stress</span><br><span class="line">05:33:05 PM   977      7850   25.00    0.00    0.00   74.40   25.00     9  stress</span><br><span class="line">05:33:05 PM   977      7851   25.00    0.00    0.00   75.00   25.00    13  stress</span><br><span class="line">05:33:05 PM   977      7852   25.00    0.00    0.00   75.20   25.00    15  stress</span><br><span class="line">05:33:05 PM   977      7853   24.80    0.00    0.00   75.20   24.80     6  stress</span><br><span class="line">05:33:05 PM   977      7854   24.80    0.20    0.00   75.40   25.00     0  stress</span><br><span class="line">05:33:05 PM   977      7855   25.00    0.00    0.00   74.80   25.00     4  stress</span><br><span class="line">05:33:05 PM   977      7856   25.00    0.00    0.00   75.20   25.00     6  stress</span><br><span class="line">05:33:05 PM   977      7857   25.20    0.00    0.00   75.20   25.20     9  stress</span><br><span class="line">05:33:05 PM   977      7858   25.00    0.00    0.00   75.00   25.00    10  stress</span><br><span class="line">05:33:05 PM   977      7859   25.00    0.00    0.00   75.00   25.00    13  stress</span><br><span class="line">05:33:05 PM   977      7860   25.00    0.00    0.00   75.00   25.00    15  stress</span><br><span class="line">05:33:05 PM   977      7861   25.00    0.00    0.00   75.00   25.00     1  stress</span><br><span class="line">05:33:05 PM   977      7863   25.00    0.00    0.00   75.00   25.00     5  stress</span><br><span class="line">05:33:05 PM   977      7864   25.00    0.00    0.00   75.40   25.00     7  stress</span><br><span class="line">05:33:05 PM   977      7865   25.00    0.00    0.00   75.00   25.00     3  stress</span><br><span class="line">05:33:05 PM   977      7866   25.00    0.00    0.00   75.00   25.00    11  stress</span><br><span class="line">05:33:05 PM   977      7867   24.80    0.00    0.00   75.00   24.80     2  stress</span><br><span class="line">05:33:05 PM   977      7868   24.80    0.00    0.00   75.00   24.80    14  stress</span><br><span class="line">05:33:05 PM   977      7869   25.00    0.00    0.00   74.80   25.00     0  stress</span><br><span class="line">05:33:05 PM   977      7870   25.00    0.00    0.00   75.00   25.00     5  stress</span><br><span class="line">05:33:05 PM   977      7871   25.00    0.00    0.00   74.40   25.00     6  stress</span><br><span class="line">05:33:05 PM   977      7872   25.00    0.00    0.00   75.20   25.00     9  stress</span><br><span class="line">05:33:05 PM   977      7873   24.80    0.00    0.00   75.40   24.80    10  stress</span><br><span class="line">05:33:05 PM   977      7874   25.00    0.00    0.00   75.40   25.00    12  stress</span><br><span class="line">05:33:05 PM   977      7875   25.00    0.00    0.00   75.00   25.00    15  stress</span><br><span class="line">05:33:05 PM   977      7876   25.00    0.00    0.00   75.00   25.00     1  stress</span><br><span class="line">05:33:05 PM   977      7877   24.60    0.20    0.00   75.00   24.80     2  stress</span><br><span class="line">05:33:05 PM   977      7878   25.00    0.00    0.00   75.40   25.00     7  stress</span><br><span class="line">05:33:05 PM   977      7879   24.80    0.00    0.00   75.60   24.80     8  stress</span><br><span class="line">05:33:05 PM   977      7880   25.00    0.00    0.00   75.00   25.00    11  stress</span><br><span class="line">05:33:05 PM   977      7881   25.00    0.00    0.00   75.00   25.00    12  stress</span><br><span class="line">05:33:05 PM   977      7882   25.00    0.00    0.00   75.80   25.00    14  stress</span><br><span class="line">05:33:05 PM   977      7883   25.20    0.00    0.00   74.80   25.20     1  stress</span><br><span class="line">05:33:05 PM   977      7884   25.00    0.00    0.00   75.00   25.00     4  stress</span><br><span class="line">05:33:05 PM   977      7885   25.00    0.00    0.00   75.20   25.00     6  stress</span><br><span class="line">05:33:05 PM   977      7886   25.00    0.00    0.00   74.80   25.00     8  stress</span><br><span class="line">05:33:05 PM   977      7887   25.00    0.00    0.00   75.40   25.00    11  stress</span><br><span class="line">05:33:05 PM   977      7888   25.20    0.00    0.00   74.80   25.20    12  stress</span><br><span class="line">05:33:05 PM   977      7889   24.80    0.00    0.00   75.20   24.80     2  stress</span><br><span class="line">05:33:05 PM   977      7890   24.80    0.00    0.00   75.20   24.80     0  stress</span><br><span class="line">05:33:05 PM   977      7891   25.00    0.00    0.00   74.80   25.00     5  stress</span><br><span class="line">05:33:05 PM   977      7892   25.00    0.00    0.00   75.40   25.00     3  stress</span><br><span class="line">05:33:05 PM   977      7893   25.00    0.00    0.00   74.80   25.00     8  stress</span><br><span class="line">05:33:05 PM   977      7894   25.20    0.00    0.00   74.60   25.20    10  stress</span><br><span class="line">05:33:05 PM   977      7895   25.00    0.00    0.00   75.20   25.00    13  stress</span><br><span class="line">05:33:05 PM   977      7896   25.00    0.00    0.00   75.00   25.00    14  stress</span><br><span class="line">05:33:05 PM   977      7897   24.80    0.00    0.00   75.60   24.80     2  stress</span><br><span class="line">05:33:05 PM   977      7898   25.00    0.00    0.00   74.80   25.00     7  stress</span><br><span class="line">05:33:05 PM   977      7899   24.80    0.00    0.00   75.20   24.80     8  stress</span><br><span class="line">05:33:05 PM   977      7900   25.00    0.00    0.00   74.80   25.00    10  stress</span><br><span class="line">05:33:05 PM   977      7901   25.00    0.00    0.00   74.80   25.00    13  stress</span><br><span class="line">05:33:05 PM   977      7902   24.80    0.00    0.00   74.80   24.80    14  stress</span><br><span class="line">05:33:05 PM   977      7903   24.80    0.00    0.00   75.20   24.80     1  stress</span><br><span class="line">05:33:05 PM   977      7904   25.00    0.00    0.00   74.80   25.00     3  stress</span><br><span class="line">05:33:05 PM   977      7905   24.80    0.00    0.00   75.00   24.80     4  stress</span><br><span class="line">05:33:05 PM   977      7906   25.00    0.00    0.00   75.00   25.00     7  stress</span><br><span class="line">05:33:05 PM   977      7907   24.80    0.00    0.00   75.00   24.80     9  stress</span><br><span class="line">05:33:05 PM   977      7908   25.00    0.00    0.00   74.40   25.00    11  stress</span><br><span class="line">05:33:05 PM   977      7909   25.00    0.00    0.00   75.20   25.00    12  stress</span><br><span class="line">05:33:05 PM   977      7910   25.00    0.00    0.00   75.00   25.00    15  stress</span><br><span class="line">05:33:05 PM   977      7911   25.00    0.00    0.00   74.80   25.00     0  stress</span><br><span class="line">05:33:05 PM   977      7912   25.00    0.00    0.00   75.20   25.00     5  stress</span><br><span class="line"></span><br><span class="line">Average:      UID       PID    %usr %system  %guest   %<span class="built_in">wait</span>    %CPU   CPU  Command</span><br><span class="line">Average:      977      7848   25.00    0.00    0.00   75.00   25.00     -  stress</span><br><span class="line">Average:      977      7849   25.00    0.00    0.00   74.60   25.00     -  stress</span><br><span class="line">Average:      977      7850   25.00    0.00    0.00   74.40   25.00     -  stress</span><br><span class="line">Average:      977      7851   25.00    0.00    0.00   75.00   25.00     -  stress</span><br><span class="line">Average:      977      7852   25.00    0.00    0.00   75.20   25.00     -  stress</span><br><span class="line">Average:      977      7853   24.80    0.00    0.00   75.20   24.80     -  stress</span><br><span class="line">Average:      977      7854   24.80    0.20    0.00   75.40   25.00     -  stress</span><br><span class="line">Average:      977      7855   25.00    0.00    0.00   74.80   25.00     -  stress</span><br><span class="line">Average:      977      7856   25.00    0.00    0.00   75.20   25.00     -  stress</span><br><span class="line">Average:      977      7857   25.20    0.00    0.00   75.20   25.20     -  stress</span><br><span class="line">Average:      977      7858   25.00    0.00    0.00   75.00   25.00     -  stress</span><br><span class="line">Average:      977      7859   25.00    0.00    0.00   75.00   25.00     -  stress</span><br><span class="line">Average:      977      7860   25.00    0.00    0.00   75.00   25.00     -  stress</span><br><span class="line">Average:      977      7861   25.00    0.00    0.00   75.00   25.00     -  stress</span><br><span class="line">Average:      977      7863   25.00    0.00    0.00   75.00   25.00     -  stress</span><br><span class="line">Average:      977      7864   25.00    0.00    0.00   75.40   25.00     -  stress</span><br><span class="line">Average:      977      7865   25.00    0.00    0.00   75.00   25.00     -  stress</span><br><span class="line">Average:      977      7866   25.00    0.00    0.00   75.00   25.00     -  stress</span><br><span class="line">Average:      977      7867   24.80    0.00    0.00   75.00   24.80     -  stress</span><br><span class="line">Average:      977      7868   24.80    0.00    0.00   75.00   24.80     -  stress</span><br><span class="line">Average:      977      7869   25.00    0.00    0.00   74.80   25.00     -  stress</span><br><span class="line">Average:      977      7870   25.00    0.00    0.00   75.00   25.00     -  stress</span><br><span class="line">Average:      977      7871   25.00    0.00    0.00   74.40   25.00     -  stress</span><br><span class="line">Average:      977      7872   25.00    0.00    0.00   75.20   25.00     -  stress</span><br><span class="line">Average:      977      7873   24.80    0.00    0.00   75.40   24.80     -  stress</span><br><span class="line">Average:      977      7874   25.00    0.00    0.00   75.40   25.00     -  stress</span><br><span class="line">Average:      977      7875   25.00    0.00    0.00   75.00   25.00     -  stress</span><br><span class="line">Average:      977      7876   25.00    0.00    0.00   75.00   25.00     -  stress</span><br><span class="line">Average:      977      7877   24.60    0.20    0.00   75.00   24.80     -  stress</span><br><span class="line">Average:      977      7878   25.00    0.00    0.00   75.40   25.00     -  stress</span><br><span class="line">Average:      977      7879   24.80    0.00    0.00   75.60   24.80     -  stress</span><br><span class="line">Average:      977      7880   25.00    0.00    0.00   75.00   25.00     -  stress</span><br><span class="line">Average:      977      7881   25.00    0.00    0.00   75.00   25.00     -  stress</span><br><span class="line">Average:      977      7882   25.00    0.00    0.00   75.80   25.00     -  stress</span><br><span class="line">Average:      977      7883   25.20    0.00    0.00   74.80   25.20     -  stress</span><br><span class="line">Average:      977      7884   25.00    0.00    0.00   75.00   25.00     -  stress</span><br><span class="line">Average:      977      7885   25.00    0.00    0.00   75.20   25.00     -  stress</span><br><span class="line">Average:      977      7886   25.00    0.00    0.00   74.80   25.00     -  stress</span><br><span class="line">Average:      977      7887   25.00    0.00    0.00   75.40   25.00     -  stress</span><br><span class="line">Average:      977      7888   25.20    0.00    0.00   74.80   25.20     -  stress</span><br><span class="line">Average:      977      7889   24.80    0.00    0.00   75.20   24.80     -  stress</span><br><span class="line">Average:      977      7890   24.80    0.00    0.00   75.20   24.80     -  stress</span><br><span class="line">Average:      977      7891   25.00    0.00    0.00   74.80   25.00     -  stress</span><br><span class="line">Average:      977      7892   25.00    0.00    0.00   75.40   25.00     -  stress</span><br><span class="line">Average:      977      7893   25.00    0.00    0.00   74.80   25.00     -  stress</span><br><span class="line">Average:      977      7894   25.20    0.00    0.00   74.60   25.20     -  stress</span><br><span class="line">Average:      977      7895   25.00    0.00    0.00   75.20   25.00     -  stress</span><br><span class="line">Average:      977      7896   25.00    0.00    0.00   75.00   25.00     -  stress</span><br><span class="line">Average:      977      7897   24.80    0.00    0.00   75.60   24.80     -  stress</span><br><span class="line">Average:      977      7898   25.00    0.00    0.00   74.80   25.00     -  stress</span><br><span class="line">Average:      977      7899   24.80    0.00    0.00   75.20   24.80     -  stress</span><br><span class="line">Average:      977      7900   25.00    0.00    0.00   74.80   25.00     -  stress</span><br><span class="line">Average:      977      7901   25.00    0.00    0.00   74.80   25.00     -  stress</span><br><span class="line">Average:      977      7902   24.80    0.00    0.00   74.80   24.80     -  stress</span><br><span class="line">Average:      977      7903   24.80    0.00    0.00   75.20   24.80     -  stress</span><br><span class="line">Average:      977      7904   25.00    0.00    0.00   74.80   25.00     -  stress</span><br><span class="line">Average:      977      7905   24.80    0.00    0.00   75.00   24.80     -  stress</span><br><span class="line">Average:      977      7906   25.00    0.00    0.00   75.00   25.00     -  stress</span><br><span class="line">Average:      977      7907   24.80    0.00    0.00   75.00   24.80     -  stress</span><br><span class="line">Average:      977      7908   25.00    0.00    0.00   74.40   25.00     -  stress</span><br><span class="line">Average:      977      7909   25.00    0.00    0.00   75.20   25.00     -  stress</span><br><span class="line">Average:      977      7910   25.00    0.00    0.00   75.00   25.00     -  stress</span><br><span class="line">Average:      977      7911   25.00    0.00    0.00   74.80   25.00     -  stress</span><br><span class="line">Average:      977      7912   25.00    0.00    0.00   75.20   25.00     -  stress</span><br></pre></td></tr></table></figure><p>64 个进程，基本都占用了 <code>25%</code> 的 <code>CPU</code> 使用率。与设想中的一致，每个 <code>CPU</code> 核心要服务于 4 个进程。</p><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><p><a href="https://jingwei.link/2018/12/23/linux-cpu-load-d-process.html" target="_blank" rel="noopener">Linux的CPU-Load虚高之进程的D状态</a><br><a href="https://www.cnblogs.com/gatsby123/p/11127158.html" target="_blank" rel="noopener">CPU使用率原理及计算方式</a><br><a href="https://www.cnblogs.com/xiaotengyi/p/7644336.html" target="_blank" rel="noopener">Linux 进程的 Uninterruptible sleep(D) 状态</a><br><a href="https://blog.csdn.net/wudebao5220150/article/details/12919453" target="_blank" rel="noopener">Linux进程状态解析</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当程序的性能未达到预期时，大多数开发者会选择使用 &lt;code&gt;top&lt;/code&gt; 指令查看指标 &lt;code&gt;CPU&lt;/code&gt; 使用率。其实，还有另一个有关 &lt;code&gt;CPU&lt;/code&gt; 的重要指标: 平均负责 &lt;code&gt;(load average)&lt;/code&gt;</summary>
      
    
    
    
    
    <category term="linux performance" scheme="http://divinerapier.github.io/tags/linux-performance/"/>
    
    <category term="cpu performance" scheme="http://divinerapier.github.io/tags/cpu-performance/"/>
    
  </entry>
  
  <entry>
    <title>Linux 性能调优指南</title>
    <link href="http://divinerapier.github.io/2020/08/22/linux-performance-guide/"/>
    <id>http://divinerapier.github.io/2020/08/22/linux-performance-guide/</id>
    <published>2020-08-22T14:38:13.000Z</published>
    <updated>2020-08-22T14:44:46.574Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/linux-performance/01-guide/01-performance-tools.png" alt="01"></p><p><img src="/images/linux-performance/01-guide/02-mind.png" alt="02"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/linux-performance/01-guide/01-performance-tools.png&quot; alt=&quot;01&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/linux-performance/01-guide/02-m</summary>
      
    
    
    
    
    <category term="linux performance" scheme="http://divinerapier.github.io/tags/linux-performance/"/>
    
  </entry>
  
  <entry>
    <title>容器 - 深入理解镜像</title>
    <link href="http://divinerapier.github.io/2020/08/20/docker-image/"/>
    <id>http://divinerapier.github.io/2020/08/20/docker-image/</id>
    <published>2020-08-20T01:50:18.000Z</published>
    <updated>2020-08-21T15:04:32.439Z</updated>
    
    <content type="html"><![CDATA[<p><code>Namespace</code> 与 <code>Cgroup</code> 技术是容器技术的核心点，但 <code>Docker</code> 项目的成功关键点却要归功于 <code>Docker Image</code> 的发明。在 <code>Cloud Foundry</code> 时代，<strong>上云</strong> 的过程需要经过多次 <strong>玄学调参</strong> 才能解决由于本地环境与云主机的差异性所导致的问题。<code>Docker</code> 则通过 <code>Mount Namespace</code> 与 <code>UnionFS</code> 技术，成功的解决了这个问题。</p><h2 id="Mount-Namespace"><a href="#Mount-Namespace" class="headerlink" title="Mount Namespace"></a>Mount Namespace</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ man mount_namespace</span><br><span class="line">MOUNT_NAMESPACES(7)                 Linux Programmer<span class="string">'s Manual                 MOUNT_NAMESPACES(7)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">NAME</span></span><br><span class="line"><span class="string">       mount_namespaces - overview of Linux mount namespaces</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">DESCRIPTION</span></span><br><span class="line"><span class="string">       For an overview of namespaces, see namespaces(7).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       Mount namespaces provide isolation of the list of mount points seen by the processes in each</span></span><br><span class="line"><span class="string">       namespace instance. Thus, the processes in each of the mount namespace instances will see</span></span><br><span class="line"><span class="string">       distinct single-directory hierarchies.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       The views provided by the /proc/[pid]/mounts, /proc/[pid]/mountinfo, and /proc/[pid]/mountstats</span></span><br><span class="line"><span class="string">       files (all described in proc(5)) correspond to the mount namespace in which the process with</span></span><br><span class="line"><span class="string">       the PID [pid] resides. (All of the processes that reside in the same mount namespace will see</span></span><br><span class="line"><span class="string">       the same view in these files.)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       A new mount namespace is created using either clone(2) or unshare(2) with the CLONE_NEWNS flag.</span></span><br><span class="line"><span class="string">       When a new mount namespace is created, its mount point list is initialized as follows:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       * If the namespace is created using clone(2), the mount point list of the child'</span>s namespace is</span><br><span class="line">         a copy of the mount point list <span class="keyword">in</span> the parent<span class="string">'s namespace.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       * If the namespace is created using unshare(2), the mount point list of the new namespace is a</span></span><br><span class="line"><span class="string">         copy of the mount point list in the caller'</span>s previous mount namespace.</span><br><span class="line"></span><br><span class="line">       Subsequent modifications to the mount point list (mount(2) and umount(2)) <span class="keyword">in</span> either mount</span><br><span class="line">       namespace will not (by default) affect the mount point list seen <span class="keyword">in</span> the other namespace (but</span><br><span class="line">       see the following discussion of shared subtrees).</span><br></pre></td></tr></table></figure><p>简单来说，<code>Mount Namepace</code> 为进程提供独立的文件系统视图，即可以将进程的文件系统挂载到指定挂载点，从而是进程只能看到 <code>Mount Namespace</code> 中的文件系统。</p><p>接下来，还是通过代码展示。</p><h3 id="Mount-Namespace-开发"><a href="#Mount-Namespace-开发" class="headerlink" title="Mount Namespace 开发"></a>Mount Namespace 开发</h3><p>下面的代码，使用 <code>Mount Namespace</code> 的方式通过 <code>clone(2)</code> 系统调用，创建一个新的进程。在该进程中执行 <code>/bin/bash</code> 程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mount.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> container_stack[STACK_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *<span class="keyword">const</span> container_args[] = &#123;</span><br><span class="line">        <span class="string">"/bin/bash"</span>,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">container_main</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Container - inside the container!\n"</span>);</span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Something's wrong!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Parent - start a container!\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> container_pid = clone(container_main, container_stack + STACK_SIZE, CLONE_NEWNS | SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (container_pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"failed to create a new process"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    waitpid(container_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Parent - container stopped!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行程序:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gcc main.c -o mn; sudo ./mn</span><br><span class="line">Parent - start a container!</span><br><span class="line">Container - inside the container!</span><br><span class="line">[root@zephyrus 01-mount-namespace]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>如此，就成功的进入到了容器环境内。</p><p><em>注意</em>: 是要使用 <code>root</code> 权限执行这个程序。</p><p>然后，在容器内执行 <code>df -h</code> 指令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@zephyrus 01-mount-namespace]<span class="comment"># df -h</span></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/sdd        251G   39G  200G  17% /</span><br><span class="line">tools           931G  362G  570G  39% /init</span><br><span class="line">none            2.0G     0  2.0G   0% /dev</span><br><span class="line">tmpfs           2.0G     0  2.0G   0% /sys/fs/cgroup</span><br><span class="line">none            2.0G  8.0K  2.0G   1% /run</span><br><span class="line">none            2.0G     0  2.0G   0% /run/lock</span><br><span class="line">none            2.0G     0  2.0G   0% /run/shm</span><br><span class="line">none            2.0G     0  2.0G   0% /run/user</span><br><span class="line">tmpfs           2.0G     0  2.0G   0% /mnt/wsl</span><br><span class="line">/dev/sdc        251G   11G  228G   5% /mnt/wsl/docker-desktop-data/isocache</span><br><span class="line">none            2.0G   12K  2.0G   1% /mnt/wsl/docker-desktop/shared-sockets/host-services</span><br><span class="line">/dev/sdb        251G  117M  239G   1% /mnt/wsl/docker-desktop/docker-desktop-proxy</span><br><span class="line">/dev/loop0      231M  231M     0 100% /mnt/wsl/docker-desktop/cli-tools</span><br><span class="line">C:\             931G  362G  570G  39% /mnt/c</span><br></pre></td></tr></table></figure><p>会发现，解决与在宿主机上执行该命令的结果是相同的。这个结果很不好，甚至可以说很危险。因为，不但容器可以看到宿主机上的文件，甚至于还拥有 <code>root</code> 权限。接下来，尝试通过在容器中设置挂载点的方式解决这个问题。</p><h3 id="Mount-Namespace-指定挂载点"><a href="#Mount-Namespace-指定挂载点" class="headerlink" title="Mount Namespace 指定挂载点"></a>Mount Namespace 指定挂载点</h3><p>修改 <code>container_main</code> 函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">container_main</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Container - inside the container!\n"</span>);</span><br><span class="line">    mount(<span class="string">"none"</span>, <span class="string">"/tmp"</span>, <span class="string">"tmpfs"</span>, <span class="number">0</span>, <span class="string">""</span>);</span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Something's wrong!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>mount(2)</code> 系统调用，在容器进程中，增加一个挂载点。</p><p>使用 <code>ls</code> 指令确认 <code>/tmp</code> 目录为空目录，说明挂载成功:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls /tmp</span><br></pre></td></tr></table></figure><p>之后，在确认一下系统的文件系统:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在原来的文件系统基础之上会多出一个</span></span><br><span class="line">[root@zephyrus 01-mount-namespace]<span class="comment"># df -h</span></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">none            2.0G     0  2.0G   0% /tmp</span><br><span class="line"></span><br><span class="line">[root@zephyrus 01-mount-namespace]<span class="comment"># mount -l | grep tmpfs</span></span><br><span class="line">none on /tmp <span class="built_in">type</span> tmpfs (rw,relatime)</span><br></pre></td></tr></table></figure><p>这些都可以说明，已经成功在容器内挂载了一个文件系统。而且，在宿主机上是无法看到这个挂载点的。到目前为止，一切都是按照预期发展的。</p><h3 id="Mount-Namespace-挂载根目录"><a href="#Mount-Namespace-挂载根目录" class="headerlink" title="Mount Namespace 挂载根目录"></a>Mount Namespace 挂载根目录</h3><p>既然可以在容器内部挂载 <code>/tmp</code>，那么现在来尝试挂载 <code>/</code>。</p><p>首先，准备一下必要的环境:</p><ul><li><strong>bash</strong>: 作为容器的第一个进程，允许在容器执行其他指令</li><li><strong>ls</strong>: 观察容器内的文件系统是否符合预期</li><li><strong>lib</strong>: 存放 <code>bash</code> 与 <code>ls</code> 必须的动态链接库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#/bin/bash</span></span><br><span class="line"></span><br><span class="line">T=root</span><br><span class="line">mkdir -p <span class="variable">$&#123;T&#125;</span>/&#123;bin,etc,lib,usr&#125;</span><br><span class="line">cp -v /bin/&#123;bash,ls&#125; <span class="variable">$&#123;T&#125;</span>/bin</span><br><span class="line">cp -v /etc/profile <span class="variable">$&#123;T&#125;</span>/etc/profile</span><br><span class="line"></span><br><span class="line">list=$(ldd /bin/ls | egrep -o <span class="string">'/lib.*\.[0-9]'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="built_in">echo</span> <span class="variable">$list</span> | awk -F <span class="string">'\n'</span> <span class="string">'&#123;print $1&#125;'</span>); <span class="keyword">do</span></span><br><span class="line">  mkdir -p $(dirname <span class="string">"<span class="variable">$&#123;T&#125;</span><span class="variable">$&#123;i&#125;</span>"</span>) &amp;&amp; cp -v <span class="string">"<span class="variable">$i</span>"</span> <span class="string">"<span class="variable">$&#123;T&#125;</span><span class="variable">$&#123;i&#125;</span>"</span>;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">list=$(ldd /bin/bash | egrep -o <span class="string">'/lib.*\.[0-9]'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="built_in">echo</span> <span class="variable">$list</span> | awk -F <span class="string">'\n'</span> <span class="string">'&#123;print $1&#125;'</span>); <span class="keyword">do</span></span><br><span class="line">  mkdir -p $(dirname <span class="string">"<span class="variable">$&#123;T&#125;</span><span class="variable">$&#123;i&#125;</span>"</span>) &amp;&amp; cp -v <span class="string">"<span class="variable">$i</span>"</span> <span class="string">"<span class="variable">$&#123;T&#125;</span><span class="variable">$&#123;i&#125;</span>"</span>;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>与上一个实验不同的是，现在期望容器内的文件系统与宿主机独立。即，使用不同的根目录。因此，在代码层面需要将之前的 <code>mount(2)</code> 系统调用，改变为 <code>chroot(2)</code> 系统调用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ man 2 chroot</span><br><span class="line">CHROOT(2)                           Linux Programmer<span class="string">'s Manual                           CHROOT(2)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">NAME</span></span><br><span class="line"><span class="string">       chroot - change root directory</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">SYNOPSIS</span></span><br><span class="line"><span class="string">       #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       int chroot(const char *path);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">DESCRIPTION</span></span><br><span class="line"><span class="string">       chroot() changes the root directory of the calling process to that specified in path. This</span></span><br><span class="line"><span class="string">       directory will be used for pathnames beginning with /. The root directory is inherited by</span></span><br><span class="line"><span class="string">       all children of the calling process.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       Only a privileged process (Linux: one with the CAP_SYS_CHROOT capability in its user namespace)</span></span><br><span class="line"><span class="string">       may call chroot().</span></span><br></pre></td></tr></table></figure><p>最终，函数 <code>container_main</code> 的代码为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">container_main</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Container - inside the container!\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> rev = chroot(<span class="string">"./root"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != rev) &#123;</span><br><span class="line">        perror(<span class="string">"failed to chroot"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rev = chdir(<span class="string">"/"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != rev) &#123;</span><br><span class="line">        perror(<span class="string">"failed to chdir"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rev = execv(container_args[<span class="number">0</span>], container_args);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != rev) &#123;</span><br><span class="line">        perror(<span class="string">"failed to exec"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Something's wrong!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与之前一样，编译并执行程序，即可进入到容器内部:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gcc main.c -o mn; sudo ./mn</span><br><span class="line">Parent - start a container!</span><br><span class="line">Container - inside the container!</span><br><span class="line">bash-4.4<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>然后，执行 <code>ls</code> 可以看到根目录 <code>/</code> 的文件就是之前在 <code>root</code> 目录预先准备好的文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bash-4.4<span class="comment"># ls /</span></span><br><span class="line">bin  etc  lib  lib64  usr</span><br><span class="line">bash-4.4<span class="comment"># ls /bin</span></span><br><span class="line">bash  ls</span><br><span class="line">bash-4.4<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>综上所述，如果在 <code>root</code> 目录中保存的是一个完成的操作系统，那么，就可以实现容器内的进程就可以使用内部的 <code>/bin</code>，<code>/lib</code> 的系统环境，从而与宿主机，与其他容器相互隔离的目的。</p><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>挂载 <code>tmpfs</code> 实验的运行环境为:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/os-release</span><br><span class="line">NAME=<span class="string">"Arch Linux"</span></span><br><span class="line">PRETTY_NAME=<span class="string">"Arch Linux"</span></span><br><span class="line">ID=arch</span><br><span class="line">BUILD_ID=rolling</span><br><span class="line">ANSI_COLOR=<span class="string">"38;2;23;147;209"</span></span><br><span class="line">HOME_URL=<span class="string">"https://www.archlinux.org/"</span></span><br><span class="line">DOCUMENTATION_URL=<span class="string">"https://wiki.archlinux.org/"</span></span><br><span class="line">SUPPORT_URL=<span class="string">"https://bbs.archlinux.org/"</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">"https://bugs.archlinux.org/"</span></span><br><span class="line">LOGO=archlinux</span><br><span class="line"></span><br><span class="line">$ uname -r</span><br><span class="line">4.19.104-microsoft-standard</span><br></pre></td></tr></table></figure><p><code>chroot</code> 实验的运行环境为:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/os-release</span><br><span class="line">NAME=<span class="string">"Ubuntu"</span></span><br><span class="line">VERSION=<span class="string">"18.04.4 LTS (Bionic Beaver)"</span></span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME=<span class="string">"Ubuntu 18.04.4 LTS"</span></span><br><span class="line">VERSION_ID=<span class="string">"18.04"</span></span><br><span class="line">HOME_URL=<span class="string">"https://www.ubuntu.com/"</span></span><br><span class="line">SUPPORT_URL=<span class="string">"https://help.ubuntu.com/"</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">"https://bugs.launchpad.net/ubuntu/"</span></span><br><span class="line">PRIVACY_POLICY_URL=<span class="string">"https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"</span></span><br><span class="line">VERSION_CODENAME=bionic</span><br><span class="line">UBUNTU_CODENAME=bionic</span><br><span class="line"></span><br><span class="line">$ uname -r</span><br><span class="line">4.15.0-112-generic</span><br></pre></td></tr></table></figure><h2 id="UnionFS"><a href="#UnionFS" class="headerlink" title="UnionFS"></a>UnionFS</h2><p>在 <code>Cloud Foundry</code> 时代，上云过程繁琐的根本原因在于: 本地环境与云主机环境不一致。</p><p>在狭义上，软件的依赖指编程时所使用的第三方库；广义上，依赖不止包括编程使用的第三方库，操作系统同样也是软件的依赖。</p><p>通过上面对 <code>Mount Namespace</code> 技术简单的实验，已经验证了在容器内打包一个完整的操作系统作为容器的 <code>rootfs</code> 是可行的。到目前为止，从技术的角度而言，已经解决了容器隔离的问题。但从使用角度，或者说用户体验的角度而言，每次构建一个容器，都要打包一份操作系统文件，似乎实在是不便于使用。</p><p>比如，开发者使用 <code>Ubuntu</code> 操作系统的 <code>ISO</code> 制作了一个 <code>rootfs</code>，并依次为基础，安装 <code>Java</code> 环境，进而部署 <code>Java</code> 应用。如果，另一个开发者也有同样的需求，或者同一开发者需要部署另一个 <code>Java</code> 应用，显然，最理想情况是能够复用之前已经安装了 <code>Java</code> 的 <code>rootfs</code> 环境，而不是重复一遍流程。</p><p>直观的解决办法，构建 <code>rootfs</code> 时，每执行一个有意义的操作之后，都生成一个新的 <code>rootfs</code>。之后，就可以选择一个合适的 <code>rootfs</code> 作为基础，添加新的操作构建目标 <code>rootfs</code>。</p><p>但这个方案并不完美，如果每次构建过程都产生一个新的 <code>rootfs</code>，最后将会导致系统内有极其多的 <code>rootfs</code>。</p><p>幸运的是，这个问题并不难解决。将问题一般化，基于既有 <code>A</code>，每一种操作 <code>F</code> 都可以产生唯一结果 <code>B</code>。并且，<code>B</code> 可以作为下一轮的输入。结果发现，这像极了 <code>git</code> 和区块链。</p><p><code>Docker</code> 在设计 <code>Docker</code> 镜像时也是使用了类似的方法。他们引入了层 <code>(layer)</code> 概念。用户制作镜像的每一步操作，都会生成一个层，将 <code>rootfs</code> 从全量保存，改为了增量保存。</p><h3 id="什么是-UnionFS"><a href="#什么是-UnionFS" class="headerlink" title="什么是 UnionFS"></a>什么是 UnionFS</h3><p><code>Docker</code> 镜像的这种实现方式，依赖于一种叫做 <code>UnionFS</code> 的文件系统。</p><p>简单来讲，<a href="https://de.wikipedia.org/wiki/UnionFS" target="_blank" rel="noopener">UnionFS</a> 允许将多个设备文件或目录挂载到同一个目录上，将多个设备的内容作为整体对外展示，或者将一个设备文件挂载到一个已有的目录上。</p><p>比如，在 <code>Ubuntu 18.04</code> 上:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 准备测试目录</span></span><br><span class="line">$ mkdir -p A/&#123;a,x&#125;</span><br><span class="line">$ mkdir -p B/&#123;b,x&#125;</span><br><span class="line">$ rm -rf C &amp;&amp; mkdir -p C</span><br></pre></td></tr></table></figure><p>使用联合挂载的方式，将这两个目录挂载到一个公共的目录 <code>C</code> 上:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mount -t aufs -o <span class="built_in">dirs</span>=./A:./B none ./C</span><br></pre></td></tr></table></figure><p>这时可以看到目录 <code>A</code> 与目录 <code>B</code> 被合并到了目录 <code>C</code> 中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ tree C</span><br><span class="line">C</span><br><span class="line">├── a</span><br><span class="line">├── b</span><br><span class="line">└── x</span><br><span class="line"></span><br><span class="line">3 directories, 0 files</span><br></pre></td></tr></table></figure><p>此时，如果修改 <code>C</code> 也会反应到对应的 <code>A</code> 或 <code>B</code> 中。</p><p><code>Docker</code> 支持多种<a href="https://docs.docker.com/storage/storagedriver/select-storage-driver/" target="_blank" rel="noopener">存储驱动</a>，但目前默认使用的驱动为 <code>overlay2</code>。</p><h3 id="Overlay2"><a href="#Overlay2" class="headerlink" title="Overlay2"></a>Overlay2</h3><p>接下来通过一个例子来探索 <code>overlay2</code>。</p><p>首先，启动一个容器:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d ubuntu:latest sleep 3600000</span><br></pre></td></tr></table></figure><p>这个命令的含义是，使用 <code>ubuntu:latest</code> 这个 <code>Docker</code> 镜像来运行一个容器。然后，使用命令查看镜像的细节:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ docker image inspect ubuntu:latest</span><br><span class="line">...</span><br><span class="line">        <span class="string">"GraphDriver"</span>: &#123;</span><br><span class="line">            <span class="string">"Data"</span>: &#123;</span><br><span class="line">                <span class="string">"LowerDir"</span>: <span class="string">"/var/lib/docker/overlay2/f34511250966eebf394cfcd377e3f3b3e226910881a87b14a9a9743bcbd30c05/diff:/var/lib/docker/overlay2/268f8bdf24c70efcb96bcfedbc22458b36d532bd1a9494f8a5989069eb849802/diff:/var/lib/docker/overlay2/286b92fb4ca407b7475db92eec9dccbd7bc279b968e9f7ca61deb13a9eee9c02/diff"</span>,</span><br><span class="line">                <span class="string">"MergedDir"</span>: <span class="string">"/var/lib/docker/overlay2/df8d02faf11610c87d3ed7c92b5201902b87c468061bb495597fb2ce8d68d90e/merged"</span>,</span><br><span class="line">                <span class="string">"UpperDir"</span>: <span class="string">"/var/lib/docker/overlay2/df8d02faf11610c87d3ed7c92b5201902b87c468061bb495597fb2ce8d68d90e/diff"</span>,</span><br><span class="line">                <span class="string">"WorkDir"</span>: <span class="string">"/var/lib/docker/overlay2/df8d02faf11610c87d3ed7c92b5201902b87c468061bb495597fb2ce8d68d90e/work"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"Name"</span>: <span class="string">"overlay2"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"RootFS"</span>: &#123;</span><br><span class="line">            <span class="string">"Type"</span>: <span class="string">"layers"</span>,</span><br><span class="line">            <span class="string">"Layers"</span>: [</span><br><span class="line">                <span class="string">"sha256:e1c75a5e0bfa094c407e411eb6cc8a159ee8b060cbd0398f1693978b4af9af10"</span>,</span><br><span class="line">                <span class="string">"sha256:9e97312b63ff63ad98bb1f3f688fdff0721ce5111e7475b02ab652f10a4ff97d"</span>,</span><br><span class="line">                <span class="string">"sha256:ec1817c93e7c08d27bfee063f0f1349185a558b87b2d806768af0a8fbbf5bc11"</span>,</span><br><span class="line">                <span class="string">"sha256:05f3b67ed530c5b55f6140dfcdfb9746cdae7b76600de13275197d009086bb3d"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li><code>RootFS</code>: 由于 <code>Docker</code> 的镜像为分层结构，制作镜像的每一步，都是一个层。因此，一个完整的 <code>Docker</code> 镜像包括 <code>image</code> 和 <code>layer</code>。为了解决空间，提高效率等目的， <code>Docker</code> 构建镜像时，使用了 <code>COW</code> 技术，即 <code>layer</code> 在 <code>image</code> 之间是被共享的。一个 <code>Image</code> 是由多个有先后逻辑顺序的 <code>Layer</code> 所构成，也就是 <code>RootFS</code> 中的 <code>Layer</code> ，上面是底层，下面是顶层。这个信息保存在 <code>/var/lib/docker/image/overlay2/imagedb/content/sha256/&lt;image_id&gt;</code> 文件中。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ll /var/lib/docker/image/overlay2/layerdb/sha256/</span><br><span class="line">drwx------ 2 root root 4096 Aug 16 13:48 27d46ebb54384edbc8c807984f9eb065321912422b0e6c49d6a9cd8c8b7d8ffc</span><br><span class="line">drwx------ 2 root root 4096 Aug 16 13:48 8a8d1f0b34041a66f09e49bdc03e75c2190f606b0db7e08b75eb6747f7b49e11</span><br><span class="line">drwx------ 2 root root 4096 Aug 16 13:48 e1c75a5e0bfa094c407e411eb6cc8a159ee8b060cbd0398f1693978b4af9af10</span><br><span class="line">drwx------ 2 root root 4096 Aug 16 13:48 f1b8f74eff975ae600be0345aaac8f0a3d16680c2531ffc72f77c5e17cbfeeee</span><br></pre></td></tr></table></figure><p>结果在 <code>RootFS.Layers</code> 中只找到了 <code>e1c75a5e0bfa094c407e411eb6cc8a159ee8b060cbd0398f1693978b4af9af10</code>。这是为 <code>Docker</code> 使用了 <code>ChainID</code> 的方式去保存其他的 <code>layer</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -n <span class="string">"sha256:e1c75a5e0bfa094c407e411eb6cc8a159ee8b060cbd0398f1693978b4af9af10 sha256:9e97312b63ff63ad98bb1f3f688fdff0721ce5111e7475b02ab652f10a4ff97d"</span> | sha256sum -</span><br><span class="line">27d46ebb54384edbc8c807984f9eb065321912422b0e6c49d6a9cd8c8b7d8ffc  -</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> -n <span class="string">"sha256:27d46ebb54384edbc8c807984f9eb065321912422b0e6c49d6a9cd8c8b7d8ffc sha256:ec1817c93e7c08d27bfee063f0f1349185a558b87b2d806768af0a8fbbf5bc11"</span> | sha256sum -</span><br><span class="line">f1b8f74eff975ae600be0345aaac8f0a3d16680c2531ffc72f77c5e17cbfeeee  -</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> -n <span class="string">"sha256:f1b8f74eff975ae600be0345aaac8f0a3d16680c2531ffc72f77c5e17cbfeeee sha256:05f3b67ed530c5b55f6140dfcdfb9746cdae7b76600de13275197d009086bb3d"</span> | sha256sum -</span><br><span class="line">8a8d1f0b34041a66f09e49bdc03e75c2190f606b0db7e08b75eb6747f7b49e11  -</span><br></pre></td></tr></table></figure><p>如此就找到了所有的 <code>layer</code>。</p><p>但是，上面的文件保存的只有元数据 <code>(metadata )</code>，还需要找到真实的 <code>rootfs</code> 保存的位置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /var/lib/docker/image/overlay2/layerdb/sha256/e1c75a5e0bfa094c407e411eb6cc8a159ee8b060cbd0398f1693978b4af9af10/cache-id</span><br><span class="line">286b92fb4ca407b7475db92eec9dccbd7bc279b968e9f7ca61deb13a9eee9c02</span><br></pre></td></tr></table></figure><p><code>overlay2</code> 的所有 <code>rootfs</code> 都保存在 <code>/var/lib/docker/overlay2</code> 中，具体到上面的 <code>layer: e1c75a5e0bfa094c407e411eb6cc8a159ee8b060cbd0398f1693978b4af9af10</code> 的 <code>rootfs</code> 的位置就是 <code>/var/lib/docker/overlay2/286b92fb4ca407b7475db92eec9dccbd7bc279b968e9f7ca61deb13a9eee9c02</code>。</p><p>以此类推，可以找到上述的四个 <code>layer</code> 的 <code>rootfs</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat /var/lib/docker/image/overlay2/layerdb/sha256/27d46ebb54384edbc8c807984f9eb065321912422b0e6c49d6a9cd8c8b7d8ffc/cache-id</span><br><span class="line">268f8bdf24c70efcb96bcfedbc22458b36d532bd1a9494f8a5989069eb849802</span><br><span class="line"></span><br><span class="line">$ cat /var/lib/docker/image/overlay2/layerdb/sha256/f1b8f74eff975ae600be0345aaac8f0a3d16680c2531ffc72f77c5e17cbfeeee/cache-id</span><br><span class="line">f34511250966eebf394cfcd377e3f3b3e226910881a87b14a9a9743bcbd30c05</span><br><span class="line"></span><br><span class="line">$ cat /var/lib/docker/image/overlay2/layerdb/sha256/8a8d1f0b34041a66f09e49bdc03e75c2190f606b0db7e08b75eb6747f7b49e11/cache-id</span><br><span class="line">df8d02faf11610c87d3ed7c92b5201902b87c468061bb495597fb2ce8d68d90e</span><br></pre></td></tr></table></figure><p>将他们通过 <code>Union mount</code> 的方式挂载到某个目录，就能得到容器完整的 <code>rootfs</code> 了。而且，可以观察出，上面得到的结果就是 <code>GraphDriver</code> 中的结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ls /var/lib/docker/overlay2/286b92fb4ca407b7475db92eec9dccbd7bc279b968e9f7ca61deb13a9eee9c02</span><br><span class="line">committed  diff  link</span><br><span class="line"></span><br><span class="line">$ ls /var/lib/docker/overlay2/268f8bdf24c70efcb96bcfedbc22458b36d532bd1a9494f8a5989069eb849802</span><br><span class="line">committed  diff  link  lower  work</span><br><span class="line"></span><br><span class="line">$ ls /var/lib/docker/overlay2/f34511250966eebf394cfcd377e3f3b3e226910881a87b14a9a9743bcbd30c05</span><br><span class="line">committed  diff  link  lower  work</span><br><span class="line"></span><br><span class="line">$ ls /var/lib/docker/overlay2/df8d02faf11610c87d3ed7c92b5201902b87c468061bb495597fb2ce8d68d90e</span><br><span class="line">committed  diff  link  lower  work</span><br></pre></td></tr></table></figure><p>除了最底层 <code>286b92fb4ca407b7475db92eec9dccbd7bc279b968e9f7ca61deb13a9eee9c02</code> 之外，其他各上层的 <code>rootfs</code> 中都存在 <code>lower</code> 目录，这是保存各自的底层 <code>(文档中表述为 parent)</code>。比如对于倒数第二层 <code>268f8bdf24c70efcb96bcfedbc22458b36d532bd1a9494f8a5989069eb849802</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat /var/lib/docker/overlay2/268f8bdf24c70efcb96bcfedbc22458b36d532bd1a9494f8a5989069eb849802/lower</span><br><span class="line">l/QEYZLDRIUA2DNUJIGGVCZYDVRM</span><br><span class="line"></span><br><span class="line">$ ls -l /var/lib/docker/overlay2/l/QEYZLDRIUA2DNUJIGGVCZYDVRM</span><br><span class="line">/var/lib/docker/overlay2/l/QEYZLDRIUA2DNUJIGGVCZYDVRM -&gt; ../286b92fb4ca407b7475db92eec9dccbd7bc279b968e9f7ca61deb13a9eee9c02/diff</span><br></pre></td></tr></table></figure><p>最后，根据当前的 <code>lower</code> 可以得到底层的 <code>diff</code> 。</p><p>通过上述操作，将 <code>lower</code> 与 <code>diff</code> 关联起来了:</p><ul><li><code>lower</code>: 可理解为当前的镜像层，对于当前层而言，是只读的</li><li><code>diff</code>: 是容器可读可写层，初始为空，容器内有文件被修改时，这个文件夹就会有对应的变化，也就是所谓的 <code>COW</code></li></ul><p>使用如下方式验证:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">7baea70ac0a0        ubuntu:latest       <span class="string">"sleep 3600000"</span>     2 hours ago         Up 2 hours                              vigorous_poitras</span><br><span class="line"></span><br><span class="line">$ docker inspect 7baea70ac0a0</span><br><span class="line">...</span><br><span class="line">        <span class="string">"GraphDriver"</span>: &#123;</span><br><span class="line">            <span class="string">"Data"</span>: &#123;</span><br><span class="line">                <span class="string">"LowerDir"</span>: <span class="string">"/var/lib/docker/overlay2/9667b87c5a650e82e2a27a6420813fd8b7891a0e37b13558448e6f82a2e7a877-init/diff:/var/lib/docker/overlay2/df8d02faf11610c87d3ed7c92b5201902b87c468061bb495597fb2ce8d68d90e/diff:/var/lib/docker/overlay2/f34511250966eebf394cfcd377e3f3b3e226910881a87b14a9a9743bcbd30c05/diff:/var/lib/docker/overlay2/268f8bdf24c70efcb96bcfedbc22458b36d532bd1a9494f8a5989069eb849802/diff:/var/lib/docker/overlay2/286b92fb4ca407b7475db92eec9dccbd7bc279b968e9f7ca61deb13a9eee9c02/diff"</span>,</span><br><span class="line">                <span class="string">"MergedDir"</span>: <span class="string">"/var/lib/docker/overlay2/9667b87c5a650e82e2a27a6420813fd8b7891a0e37b13558448e6f82a2e7a877/merged"</span>,</span><br><span class="line">                <span class="string">"UpperDir"</span>: <span class="string">"/var/lib/docker/overlay2/9667b87c5a650e82e2a27a6420813fd8b7891a0e37b13558448e6f82a2e7a877/diff"</span>,</span><br><span class="line">                <span class="string">"WorkDir"</span>: <span class="string">"/var/lib/docker/overlay2/9667b87c5a650e82e2a27a6420813fd8b7891a0e37b13558448e6f82a2e7a877/work"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"Name"</span>: <span class="string">"overlay2"</span></span><br><span class="line">        &#125;,</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ docker <span class="built_in">exec</span> -ti 7baea70ac0a0 bash</span><br><span class="line">touch ~/a.txt</span><br></pre></td></tr></table></figure><p>然后在另一个终端:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ tree /var/lib/docker/overlay2/9667b87c5a650e82e2a27a6420813fd8b7891a0e37b13558448e6f82a2e7a877</span><br><span class="line">├── diff</span><br><span class="line">│   └── root</span><br><span class="line">│       └── a.txt</span><br><span class="line">├── link</span><br><span class="line">├── lower</span><br><span class="line">├── merged</span><br><span class="line">└── work</span><br><span class="line">    └── work</span><br></pre></td></tr></table></figure><p>在 <code>diff</code> 中多出了文件 <code>root/a.txt</code>。</p><p>此外，很容易发现还有一个以 <code>-init</code> 结尾的文件，这同样是一个层，夹在只读层和读写层之间。<code>Init</code> 层是 <code>Docker</code> 项目单独生成的一个内部层，专门用来存放 <code>/etc/hosts</code>、 <code>/etc/resolv.conf</code> 等信息。</p><p>需要这样一层的原因是，这些文件本来属于只读的 <code>Ubuntu</code> 镜像的一部分，但是用户往往需要在启动容器时写入一些指定的值比如 <code>hostname</code>，所以就需要在可读写层对它们进行修改。</p><p>可是，这些修改往往只对当前的容器有效，我们并不希望执行 <code>docker commit</code> 时，把这些信息连同可读写层一起提交掉。</p><p>所以， <code>Docker</code> 做法是，在修改了这些文件之后，以一个单独的层挂载了出来。而用户执行 <code>docker commit</code> 只会提交可读写层，所以是不包含这些内容的。</p><p>最终，这几个层都被联合挂载，表现为一个完整的 <code>Ubuntu</code> 操作系统供容器使用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Mount Namespace</code> 技术为容器提供了独立 <code>rootfs</code> 的能力，使容器在本地环境，测试环境，云环境之间具备了真正的 <strong>一致性</strong>。</p><p><code>UnionFS</code> 为 <code>Docker</code> 镜像提供了快速迭代，分层下载，复用已有镜像等能力。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://coolshell.cn/articles/17061.html" target="_blank" rel="noopener">DOCKER基础技术：AUFS</a><br><a href="https://blog.csdn.net/ra681t58cjxsgckj31/article/details/104707642" target="_blank" rel="noopener">一文读懂容器三大核心技术——Namespace，Cgroup和UnionFS</a><br><a href="https://docs.docker.com/storage/storagedriver/select-storage-driver/" target="_blank" rel="noopener">Docker storage drivers</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;Namespace&lt;/code&gt; 与 &lt;code&gt;Cgroup&lt;/code&gt; 技术是容器技术的核心点，但 &lt;code&gt;Docker&lt;/code&gt; 项目的成功关键点却要归功于 &lt;code&gt;Docker Image&lt;/code&gt; 的发明。在 &lt;code&gt;Cloud </summary>
      
    
    
    
    
    <category term="container" scheme="http://divinerapier.github.io/tags/container/"/>
    
    <category term="docker image" scheme="http://divinerapier.github.io/tags/docker-image/"/>
    
    <category term="mount namespace" scheme="http://divinerapier.github.io/tags/mount-namespace/"/>
    
    <category term="unionfs" scheme="http://divinerapier.github.io/tags/unionfs/"/>
    
  </entry>
  
  <entry>
    <title>容器 - 隔离与限制</title>
    <link href="http://divinerapier.github.io/2020/08/17/namespace-and-cgroup/"/>
    <id>http://divinerapier.github.io/2020/08/17/namespace-and-cgroup/</id>
    <published>2020-08-17T12:25:09.000Z</published>
    <updated>2020-08-19T14:42:49.528Z</updated>
    
    <content type="html"><![CDATA[<p>之前提到过，容器技术就是一种沙盒技术，可以将应用及相关配置、脚本 <strong>装</strong> 到一个 <strong>箱子</strong> 中，这样，应用与应用之间就会因为有了边界而不至于相互干扰。而应用被装进箱子后，也可以被方便地搬来搬去。</p><p>但是，<code>Talk is cheap, show me the code!</code></p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>如果要实现一个程序，从一个文件读取两个整数，将计算结果写入到另一个文件，则至少需要有三个文件</p><ul><li>可执行文件</li><li>输入文件</li><li>输出文件</li></ul><p>由于计算机只认识 <code>0</code> 和 <code>1</code>，因此无论用哪种语言编写这段代码，最后这三个文件都需要通过某种方式翻译成二进制文件，才能在计算机操作系统中运行与使用。初始状态时，三个文件都存放在磁盘上。可执行文件被称作程序，剩余两个文件是数据。</p><p>要完成功能，需要在计算机上执行这个程序。</p><p>首先，操作系统将 <strong>程序</strong> 载入到内存中，表现为指令序列。在执行过程中，当执行到从文件加载输入数据的指令时，操作系统控制存储控制器完成将数据从磁盘载入到内存。之后，操作系统读取到计算加法的指令时，通过 <code>CPU</code>、寄存器与内存的共同协作完成加法计算将计算结果暂存在内存中。最后，执行将结果保存到文件的指令时，操作系统会通过存储控制器，将内存中的结果写入到磁盘上。同时，操作系统中还需要维护其他状态，辅助这一过程顺利进行。</p><p>在操作系统中，将上述过程所涉及到的总和称作：进程。</p><p>而容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个 <strong>边界</strong>。</p><p>对于 <code>Docker</code> 等大多数 <code>Linux</code> 容器来说，使用 <code>cgroups</code> 技术来制造约束，使用 <code>namespace</code> 技术来修改进程视图。</p><h2 id="从创建一个容器开始"><a href="#从创建一个容器开始" class="headerlink" title="从创建一个容器开始"></a>从创建一个容器开始</h2><p>首先创建一个容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --<span class="built_in">help</span></span><br><span class="line">Usage:  docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line">$ docker run -it busybox /bin/sh</span><br><span class="line">Unable to find image <span class="string">'busybox:latest'</span> locally</span><br><span class="line">latest: Pulling from library/busybox</span><br><span class="line">91f30d776fb2: Pull complete</span><br><span class="line">Digest: sha256:9ddee63a712cea977267342e8750ecbc60d3aab25f04ceacfa795e6fce341793</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> busybox:latest</span><br><span class="line">/ <span class="comment">#</span></span><br></pre></td></tr></table></figure><p>参数 <code>-it</code> 的含义是</p><ul><li>-i: –interactive     Keep STDIN open even if not attached</li><li>-t, –tty             Allocate a pseudo-TTY</li></ul><p>结果就是，在操作系统中创建了一个容器，该容器中执行的程序为 <code>/bin/sh</code>。并且，在容器启动之后，申请了一个随机的 <code>tty</code>，使用交互方式访问这个容器。</p><p>现在，执行 <code>ps</code> 指令，会发现很有趣</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># ps</span></span><br><span class="line">PID   USER     TIME  COMMAND</span><br><span class="line">    1 root      0:00 /bin/sh</span><br><span class="line">    6 root      0:00 ps</span><br></pre></td></tr></table></figure><p>在创建容器时指定的 <code>/bin/sh</code> 进程，竟然就是容器内部的第一个进程<code>(pid=1)</code>，并且，这个容器内只有两个进程正在运行中，另一个进程是正在执行的 <code>ps</code> 指令。</p><p>其实，这种现象就是通过 <code>namespace</code> 技术实现的。</p><h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p>首先，通过 <code>manpages</code> 对 <code>namespace</code> 有一个初步的了解:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ man namespaces</span><br><span class="line">NAMESPACES(7)                       Linux Programmer<span class="string">'s Manual                       NAMESPACES(7)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">NAME</span></span><br><span class="line"><span class="string">       namespaces - overview of Linux namespaces</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">DESCRIPTION</span></span><br><span class="line"><span class="string">       A namespace wraps a global system resource in an abstraction that makes it appear to the processes</span></span><br><span class="line"><span class="string">       within the namespace that they have their own isolated instance of the global resource. Changes to</span></span><br><span class="line"><span class="string">       the global resource are visible to other processes that are members of the namespace, but are</span></span><br><span class="line"><span class="string">       invisible to other processes. One use of namespaces is to implement containers.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       This page provides pointers to information on the various namespace types, describes the associated</span></span><br><span class="line"><span class="string">      /proc files, and summarizes the APIs for working with namespaces.</span></span><br><span class="line"><span class="string">       ...</span></span><br></pre></td></tr></table></figure><p>总的来说，<code>Linux Namespace</code> 提供了一种内核级别隔离系统资源的方法，通过将系统的全局资源放在不同的 <code>Namespace</code> 中，来实现资源隔离的目的。不同 <code>Namespace</code> 的程序，可以享有一份独立的系统资源。目前 <code>Linux</code> 中提供了以下几种系统资源的隔离机制：</p><table><thead><tr><th align="left">Namespace</th><th align="left">Flag</th><th align="left">Page</th><th align="left">Isolates</th></tr></thead><tbody><tr><td align="left">Cgroup</td><td align="left">CLONE_NEWCGROUP</td><td align="left">cgroup_namespaces(7)</td><td align="left">Cgroup root directory</td></tr><tr><td align="left">IPC</td><td align="left">CLONE_NEWIPC</td><td align="left">ipc_namespaces(7)</td><td align="left">System V IPC, POSIX message queues</td></tr><tr><td align="left">Network</td><td align="left">CLONE_NEWNET</td><td align="left">network_namespaces(7)</td><td align="left">Network devices, stacks, ports, etc.</td></tr><tr><td align="left">Mount</td><td align="left">CLONE_NEWNS</td><td align="left">mount_namespaces(7)</td><td align="left">Mount points</td></tr><tr><td align="left">PID</td><td align="left">CLONE_NEWPID</td><td align="left">pid_namespaces(7)</td><td align="left">Process IDs</td></tr><tr><td align="left">Time</td><td align="left">CLONE_NEWTIME</td><td align="left">time_namespaces(7)</td><td align="left">Boot and monotonic clocks</td></tr><tr><td align="left">User</td><td align="left">CLONE_NEWUSER</td><td align="left">user_namespaces(7)</td><td align="left">User and group IDs</td></tr><tr><td align="left">UTS</td><td align="left">CLONE_NEWUTS</td><td align="left">uts_namespaces(7)</td><td align="left">Hostname and NIS domain name</td></tr></tbody></table><h3 id="如何使用-Namespace-技术"><a href="#如何使用-Namespace-技术" class="headerlink" title="如何使用 Namespace 技术"></a>如何使用 Namespace 技术</h3><p>以 <code>PID Namespace</code> 为例，简单说明如何在编程中使用这种技术。</p><p><code>Linux</code> 实现 <code>Namespace</code> 机制的方式，就是在创建进程的时候，传入特定的选项即。更具体一些，就是在调用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ man 2 <span class="built_in">clone</span></span><br><span class="line">CLONE(2)                            Linux Programmer<span class="string">'s Manual                           CLONE(2)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">NAME</span></span><br><span class="line"><span class="string">       clone, __clone2, clone3 - create a child process</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">SYNOPSIS</span></span><br><span class="line"><span class="string">       /* Prototype for the glibc wrapper function */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       #define _GNU_SOURCE</span></span><br><span class="line"><span class="string">       #include &lt;sched.h&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       int clone(int (*fn)(void *), void *stack, int flags, void *arg, ...</span></span><br><span class="line"><span class="string">                 /* pid_t *parent_tid, void *tls, pid_t *child_tid */ );</span></span><br></pre></td></tr></table></figure><p>系统调用时，传入对应的 <code>Flag</code> 作为参数 <code>flag</code> 的值。比如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pid = clone(main_function, stack_size, SIGCHLD, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>就会创建一个新的进程，并且返回它的进程号 <code>pid</code>。</p><p>如果，同时指定 <code>CLONE_NEWPID</code> 参数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>新创建进程将会 <strong>看到</strong> 一个全新的进程空间，在这个进程空间里，它的 <code>pid</code> 是 <code>1</code>。之所以说 <strong>看到</strong>，是因为这只是一个 <strong>障眼法</strong>，在宿主机真实的进程空间里，这个进程的 <code>pid</code> 还是真实的数值，比如 <code>404</code>。</p><p>如果多次执行上面的 <code>clone()</code> 调用，就会创建多个 <code>PID Namespace</code>，而每个 <code>Namespace</code> 里的应用进程都会认为自己是当前容器里的 <strong>第 1 号进程</strong>，它们既看不到宿主机里真正的进程空间，也看不到其他 <code>PID Namespace</code> 里的具体情况。</p><p>而其他的几种 <code>Namespace</code>，在写法上与 <code>PID Namespace</code> 是相同的，区别只在于目的不同。</p><p>所以，<code>Docker</code> 容器这个听起来玄而又玄的概念，实际上是在创建容器进程时，指定了这个进程所需要启用的一组 <code>Namespace</code> 参数。这样，容器就只能 <strong>看到</strong> 当前 <code>Namespace</code> 所限定的资源、文件、设备、状态，或者配置。而对于宿主机以及其他不相关的程序，它就完全看不到了。</p><p>本质仍旧是进程。因此，在之前出现过的虚拟机对比容器的图片中，才没有出现 <code>Docker</code> 的位置。因为，容器只是通过 <code>Namespace</code> 技术被隔离的进程，与其他进程一样，也是直接运行在宿主机操作系统之上的。<code>Docker</code> 只是充当了一个管理者的身份。</p><p><img src="/images/what-is-the-docker/virtualization-vs-containers.png" alt="virtualization-vs-containers"></p><p>既然，虚拟机与容器是两种不同的技术，那么二者之间就应该有一些区别。</p><h4 id="容器的优势"><a href="#容器的优势" class="headerlink" title="容器的优势"></a>容器的优势</h4><h5 id="占用资源小"><a href="#占用资源小" class="headerlink" title="占用资源小"></a>占用资源小</h5><p>容器占用的内存，要比同等功能的虚拟机占用的内存小，因为虚拟机本身也需要消耗一定的资源。比如，运行 <code>CentOS</code> 的 <code>KVM</code> 虚拟机至少需要 <code>100 ~ 200 MB</code> 的内存</p><h5 id="更好的-I-O-性能"><a href="#更好的-I-O-性能" class="headerlink" title="更好的 I/O 性能"></a>更好的 I/O 性能</h5><p>在参考阅读 <a href="https://dominoweb.draco.res.ibm.com/reports/rc25482.pdf" target="_blank" rel="noopener">An Updated Performance Comparison of Virtual Machines and Linux Containers</a> 中显示</p><ul><li>在随机读写场景中，无论是 <code>iops</code> 还是 <code>latency</code>，容器的性能都接近于物理机性能，远好于 <code>KVM</code> 虚拟机</li><li>在顺序读写场景中，容器的性能基本与物理机性能，略好于 <code>KVM</code> 虚拟机</li><li>在 <code>host network</code> 场景中，容器的性能接近于物理机的性能，好于 <code>KVM</code> 虚拟机</li><li>在 <code>nat network</code> 场景中，容器的性能略逊于 <code>KVM</code> 虚拟机，但差别不大</li></ul><p>总的来说，容器的 <code>I/O</code> 性能优于 <code>KVM</code> 虚拟机</p><h4 id="容器的劣势"><a href="#容器的劣势" class="headerlink" title="容器的劣势"></a>容器的劣势</h4><h5 id="平台依赖性"><a href="#平台依赖性" class="headerlink" title="平台依赖性"></a>平台依赖性</h5><ul><li>尽管，可以通过 <code>Mount Namespace</code> 的方式挂起与宿主机不同的 <code>Linux</code> 发行版，但容器中进程使用的内核依然是宿主机的内核。<ul><li>因此 <code>Windows</code> 耗费了那么长的时间才对容器技术有了比较好的支持。</li><li>同样，也无法在低版本内核的宿主机上运行高版本内核的容器。</li></ul></li></ul><h5 id="有限的隔离"><a href="#有限的隔离" class="headerlink" title="有限的隔离"></a>有限的隔离</h5><p>部分资源无法被隔离，比如 <strong>时间</strong>。</p><p>如果在容器中调用 <code>settimeofday(2)</code> 系统调用修改系统时间，会导致宿主机系统的时间被修改，这显然是一个很可怕的事情。因此，在使用容器的时候必须要了解 <strong>什么能做，什么不能做</strong>。</p><h2 id="Cgroup"><a href="#Cgroup" class="headerlink" title="Cgroup"></a>Cgroup</h2><p><code>Namespace</code> 技术的作用是隔离进程，但只有隔离是不够的。虽然，容器内的进程无法感知到其他运行在宿主机上的进程或容器，但从操作系统的角度而言，所有的进程与容器都是平等的地位。这就意味着，虽然容器是一个独立的小空间，但其可用的资源仍旧与其他进程之间有着竞争的关系。</p><p>因此，就需要用到 <code>Cgroup</code> 技术的帮助了。</p><p><code>Cgroup</code> 全称为 <code>Control Group</code>，用途是限制一个进程组能够使用的资源上限，包括 <code>CPU</code>、<code>MEM</code>、<code>DISK</code>、<code>NETWORK</code> 等。</p><h3 id="Cgroup-In-Action"><a href="#Cgroup-In-Action" class="headerlink" title="Cgroup In Action"></a>Cgroup In Action</h3><p>在 <code>Linux</code> 中 <code>Everything is a file</code>，因此，操作 <code>Cgroup</code> 的途径也是通过文件系统。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ mount -t cgroup</span><br><span class="line">cgroup on /sys/fs/cgroup/cpuset <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpu <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,cpu)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpuacct <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,cpuacct)</span><br><span class="line">cgroup on /sys/fs/cgroup/blkio <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,blkio)</span><br><span class="line">cgroup on /sys/fs/cgroup/memory <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,memory)</span><br><span class="line">cgroup on /sys/fs/cgroup/devices <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,devices)</span><br><span class="line">cgroup on /sys/fs/cgroup/freezer <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,freezer)</span><br><span class="line">cgroup on /sys/fs/cgroup/net_cls <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,net_cls)</span><br><span class="line">cgroup on /sys/fs/cgroup/perf_event <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)</span><br><span class="line">cgroup on /sys/fs/cgroup/net_prio <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,net_prio)</span><br><span class="line">cgroup on /sys/fs/cgroup/hugetlb <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)</span><br><span class="line">cgroup on /sys/fs/cgroup/pids <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,pids)</span><br><span class="line">cgroup on /sys/fs/cgroup/rdma <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,rdma)</span><br></pre></td></tr></table></figure><p>可以看到，<code>Cgroup</code> 是一系列定义在 <code>/sys/fs/cgroup/</code> 目录下的各种文件或文件夹。每一个文件夹都被用来限制某一种特定的资源。以 <code>cpu</code> 资源为例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ls /sys/fs/cgroup/cpu</span><br><span class="line">000-metadata  cgroup.clone_children  cpu.cfs_period_us  cpu.rt_runtime_us  docker    notify_on_release  systemreserved</span><br><span class="line">001-binfmt    cgroup.procs           cpu.cfs_quota_us   cpu.shares         kmsg      podruntime         tasks</span><br><span class="line">002-bridge    cgroup.sane_behavior   cpu.rt_period_us   cpu.stat           kubepods  release_agent</span><br></pre></td></tr></table></figure><p>列举了限制 <code>cpu</code> 资源的各种参数选项。</p><p>使用 <code>Cgroup</code> 的方式非常简单，在对应的资源目录下面创建一个目录，比如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mkdir -p /sys/fs/cgroup/cpu/container</span><br><span class="line"></span><br><span class="line">$ ls /sys/fs/cgroup/cpu/container</span><br><span class="line">cgroup.clone_children  cpu.cfs_period_us  cpu.rt_period_us   cpu.shares  notify_on_release</span><br><span class="line">cgroup.procs           cpu.cfs_quota_us   cpu.rt_runtime_us  cpu.stat    tasks</span><br></pre></td></tr></table></figure><p>这个目录被称作 <strong>控制组</strong>，<code>Linux</code> 会在控制组下自动创建各种资源限制文件。</p><p>然后，在后台执行脚本:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">while</span> : ; <span class="keyword">do</span> : ; <span class="keyword">done</span> &amp;</span><br><span class="line">[1] 12555</span><br></pre></td></tr></table></figure><p>显然，这是一个死循环进程，会占用 <code>100%</code> 的 <code>CPU</code>。使用 <code>top</code> 指令，也可以确认确实使用了 <code>100%</code> 的 <code>CPU</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ top -p 12555</span><br><span class="line">top - 21:00:26 up  4:43,  0 users,  load average: 0.66, 0.66, 0.56</span><br><span class="line">Tasks:   1 total,   1 running,   0 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.0 us,  2.5 sy,  3.7 ni, 93.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">MiB Mem :   7958.1 total,   5885.9 free,    539.2 used,   1533.0 buff/cache</span><br><span class="line">MiB Swap:  16384.0 total,  16384.0 free,      0.0 used.   7183.5 avail Mem</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND</span><br><span class="line">12555 diviner+  25   5   13576   4816      0 R 100.0   0.1   0:46.30 zsh</span><br></pre></td></tr></table></figure><p>接下来，是时候展现 <code>Cgroup</code> 的魔法了。首先，查看两个接下来要使用的关键文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat /sys/fs/cgroup/cpu/container/cpu.cfs_quota_us</span><br><span class="line">-1</span><br><span class="line">$ cat /sys/fs/cgroup/cpu/container/cpu.cfs_period_us</span><br><span class="line">100000</span><br></pre></td></tr></table></figure><ul><li><strong>cfs_period_us</strong>: 资源组获取资源的时间周期，单位微妙</li><li><strong>cfs_quota_us</strong>: 在获取资源时间周期内获得资源的时间，单位微妙</li></ul><p>所以 <code>usage = cfs_quota_us / cfs_period_us</code>。</p><p>为了验证这一点，尝试将进程的 <code>CPU</code> 使用率控制在 <code>20%</code>。</p><p>首先，根据上面推测的公式，因为 <code>cfs_period_us = 100000</code>，所以应该修改 <code>cfs_quota_us</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 20000 | sudo tee /sys/fs/cgroup/cpu/container/cpu.cfs_quota_us</span><br></pre></td></tr></table></figure><p>但这还不够，还需要将被限制的进程的 <code>PID</code> 写入到 <strong>控制组</strong> <code>container</code> 的 <code>tasks</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 12555 | sudo tee /sys/fs/cgroup/cpu/container/tasks</span><br></pre></td></tr></table></figure><p>然后使用 <code>top</code> 查看:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">top - 21:09:11 up  4:52,  0 users,  load average: 0.41, 0.76, 0.70</span><br><span class="line">Tasks:   1 total,   1 running,   0 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.0 us,  0.8 sy,  0.9 ni, 98.4 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">MiB Mem :   7958.1 total,   5883.8 free,    541.1 used,   1533.1 buff/cache</span><br><span class="line">MiB Swap:  16384.0 total,  16384.0 free,      0.0 used.   7181.6 avail Mem</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND</span><br><span class="line">12555 diviner+  25   5   13576   4816      0 R  20.0   0.1   8:17.25 zsh</span><br></pre></td></tr></table></figure><p><code>Linux Cgroups</code> 的设计还是比较易用的，可以简单地理解为，一个子系统目录加上一组资源限制文件的组合。而对于 <code>Docker</code> 等 <code>Linux</code> 容器项目来说，它们只需要在每个子系统下面，为每个容器创建一个<strong>控制组</strong> (即创建一个新目录)，然后在启动容器进程之后，把这个进程的 <code>PID</code> 填写到对应控制组的 <code>tasks</code> 文件中就可以了。</p><h2 id="Cgroup-in-Docker"><a href="#Cgroup-in-Docker" class="headerlink" title="Cgroup in Docker"></a>Cgroup in Docker</h2><p>在通过 <code>Docker</code> 启动容器的时候，也可以限制 <code>cpu</code> 使用率:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --cpu-period=100000 --cpu-quota=20000 ubuntu /bin/bash</span><br><span class="line">611f8f2c0c7613c2f3f3964e7dc3dbe407c74689e376736e34d7fe4735ec95d4</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat /sys/fs/cgroup/cpu/docker/611f8f2c0c7613c2f3f3964e7dc3dbe407c74689e376736e34d7fe4735ec95d4/cpu.cfs_period_us</span><br><span class="line">100000</span><br><span class="line"></span><br><span class="line">$ cat /sys/fs/cgroup/cpu/docker/611f8f2c0c7613c2f3f3964e7dc3dbe407c74689e376736e34d7fe4735ec95d4/cpu.cfs_quota_us</span><br><span class="line">20000</span><br></pre></td></tr></table></figure><p>此时，这个容器最多只能使用 <code>20%</code> 的 <code>CPU</code>。</p><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><ul><li><a href="https://dominoweb.draco.res.ibm.com/reports/rc25482.pdf" target="_blank" rel="noopener">An Updated Performance Comparison of Virtual Machines and Linux Containers</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前提到过，容器技术就是一种沙盒技术，可以将应用及相关配置、脚本 &lt;strong&gt;装&lt;/strong&gt; 到一个 &lt;strong&gt;箱子&lt;/strong&gt; 中，这样，应用与应用之间就会因为有了边界而不至于相互干扰。而应用被装进箱子后，也可以被方便地搬来搬去。&lt;/p&gt;
&lt;p&gt;但是</summary>
      
    
    
    
    
    <category term="container" scheme="http://divinerapier.github.io/tags/container/"/>
    
    <category term="namespace" scheme="http://divinerapier.github.io/tags/namespace/"/>
    
    <category term="cgroup" scheme="http://divinerapier.github.io/tags/cgroup/"/>
    
  </entry>
  
  <entry>
    <title>Docker - 概述</title>
    <link href="http://divinerapier.github.io/2020/08/16/what-is-the-docker/"/>
    <id>http://divinerapier.github.io/2020/08/16/what-is-the-docker/</id>
    <published>2020-08-16T12:49:59.000Z</published>
    <updated>2020-08-17T05:11:00.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PaaS-的发展过程"><a href="#PaaS-的发展过程" class="headerlink" title="PaaS 的发展过程"></a>PaaS 的发展过程</h2><p><strong>容器</strong> 这个概念从来就不是什么新鲜的东西，也不是 <code>Docker</code> 公司发明的。在红极一时的 <code>PaaS</code> 项目 <code>Cloud Foundry</code> 中，也同样使用到了容器技术，只不过容器只是其最底层、最没人关注的那一部分。</p><p><code>PaaS</code> 项目被大家接纳的一个主要原因，就是它提供了一种名叫 <strong>应用托管</strong> 的能力。在当时，虚拟机和云计算已经是比较普遍的技术和服务，主流用户的普遍用法，就是租一批 <code>AWS</code> 或者 <code>OpenStack</code> 的虚拟机，然后像以前管理物理服务器那样，用脚本或者手工的方式在这些机器上部署应用。</p><p>但是，在部署过程中，难免会碰到云端虚拟机和本地环境不一致的问题。所以当时的云计算服务，比的就是谁能更好地模拟本地服务器环境，能带来更好的 <strong>上云</strong> 体验。而 <code>PaaS</code> 开源项目 <code>Cloud Foundry</code> 就是当时解决这个问题的一个最佳方案。</p><p>举个栗子，创建好虚拟机之后，运维人员只需要在这些机器上部署 <code>Cloud Foundry Agent</code>，随后开发者只要执行一条命令就能把本地的应用部署到云上:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cf push <span class="string">"我的应用"</span></span><br></pre></td></tr></table></figure><p>事实上，<code>Cloud Foundry</code> 最核心的组件就是一套应用的打包和分发机制。<code>Cloud Foundry</code> 为每种主流编程语言都定义了一种打包格式。</p><p><code>cf push</code> 的作用是把应用的可执行文件和启动脚本打进一个压缩包内，上传到云上 <code>Cloud Foundry</code> 的存储中。接着，<code>Cloud Foundry</code> 会通过调度器选择一个可以运行这个应用的虚拟机，然后通知这个机器上的 <code>Agent</code> 把应用压缩包下载下来启动。</p><p>这时候关键来了，由于需要在一个虚拟机上启动很多个来自不同用户的应用，<code>Cloud Foundry</code> 通过操作系统的 <code>cgroups</code> 和 <code>namespace</code> 机制为每一个应用单独创建一个称作 <strong>沙盒</strong> 的隔离环境，然后在 <strong>沙盒</strong> 中启动这些应用进程。这样，就实现了把多个用户的应用互不干涉地在虚拟机里批量地、自动地运行起来的目的。而这个 <strong>沙盒</strong> 就是所谓的 <strong>容器</strong>。</p><p>而本文的主角 <code>Docker</code> 项目，与 <code>Cloud Foundry</code> 的容器并没有本质上的差异。因此在它发布后不久，<code>Cloud Foundry</code> 的首席产品经理 <code>James Bayer</code> 就在社区里做了一次详细对比，告诉用户 <code>Docker</code> 只是一个同样使用 <code>cgroups</code> 和 <code>namespace</code> 实现的 <strong>沙盒</strong> 而已，没有什么特别的黑科技，也不需要特别关注。</p><p>然而，短短几个月，<code>Docker</code> 项目就迅速崛起了。它的崛起速度如此之快，以至于 <code>Cloud Foundry</code> 以及所有的 <code>PaaS</code> 社区还没来得及成为它的竞争对手，就直接被宣告出局了，堪称 <strong>降维打击</strong>。</p><h2 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h2><p>究其根本原因，虽然 <code>Docker</code> 与 <code>Cloud Foundry</code> 无论是在核心原理还是在技术实现上大部分相同，但正是被大家忽视的那一小部分成为 <code>Docker</code> 的制胜法宝——<code>Docker</code> 镜像。</p><p><code>Cloud Fondry</code> 成也“打包”，败萧“打包”。其一，每种语言，每种框架的打包方式都不甚相同，甚至于每个版本都需要打包；其二，虽然打包之后可以在云上直接使用，但在从本地上云的过程中，可能仍旧需要反复修改、配置，甚至于在不断试错中体会<strong>玄学调参</strong>。</p><p>结果大家发现，虽然 <code>cf push</code> 可以一键部署，但是为了实现<strong>一键部署</strong>这一目的的过程却需要费尽心机。</p><p>而 <code>Docker</code> 镜像却从根本上解决了这一问题。<code>Docker</code> 镜像，实际上也是一个压缩包，但是内容却要比 <code>Cloud Foundry</code> 的丰富的多。它不但包含可执行文件与启动脚本，更是包含了一个完整的操作系统，所以这个压缩包的内容可以与开发环境、测试环境的完全一样。</p><p>假设，开发时使用 <code>centos 8</code> 作为开发环境，此时，只需要使用 <code>centos 8</code> 的 <code>iso</code> 连同可执行文件一起制作一个压缩包，那么，无论在哪里解压这个压缩包，都可以为可执行文件提供完全一致的运行环境。</p><h2 id="容器与虚拟化"><a href="#容器与虚拟化" class="headerlink" title="容器与虚拟化"></a>容器与虚拟化</h2><p>虚拟化允许多个操作系统 <code>(Windows/Linux)</code> 同时在单个硬件系统上运行。</p><p>容器可共享同一个操作系统内核，将应用进程与系统其他部分隔离开。例如：<code>ARM Linux</code> 系统运行 <code>ARM Linux</code> 容器，<code>x86 Linux</code> 系统运行 <code>x86 Linux</code> 容器，<code>x86 Windows</code> 系统运行 <code>x86 Windows</code> 容器。<code>Linux</code> 容器具有极佳的可移植性，但前提是它们必须与底层系统兼容。</p><p><img src="/images/what-is-the-docker/virtualization-vs-containers.png" alt="virtualization-vs-containers"></p><p>这意味着，虚拟化会使用虚拟机监控程序模拟硬件，从而使多个操作系统能够并行运行。但这不如容器轻便。<code>Linux</code> 容器在本机操作系统上运行，与所有容器共享该操作系统，因此应用和服务能够保持轻巧，并行化快速运行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;PaaS-的发展过程&quot;&gt;&lt;a href=&quot;#PaaS-的发展过程&quot; class=&quot;headerlink&quot; title=&quot;PaaS 的发展过程&quot;&gt;&lt;/a&gt;PaaS 的发展过程&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;容器&lt;/strong&gt; 这个概念从来就不是什么新鲜的东西，也</summary>
      
    
    
    
    
    <category term="container" scheme="http://divinerapier.github.io/tags/container/"/>
    
    <category term="docker" scheme="http://divinerapier.github.io/tags/docker/"/>
    
    <category term="paas" scheme="http://divinerapier.github.io/tags/paas/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS 双向认证</title>
    <link href="http://divinerapier.github.io/2020/08/15/https-mutual-authentication/"/>
    <id>http://divinerapier.github.io/2020/08/15/https-mutual-authentication/</id>
    <published>2020-08-15T06:04:21.000Z</published>
    <updated>2020-08-15T07:40:51.775Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TLS-协议"><a href="#TLS-协议" class="headerlink" title="TLS 协议"></a>TLS 协议</h2><p>传输层安全性协议 <code>(TLS: Transport Layer Security)</code> 及其前身安全套接层 <code>(SSL: Secure Sockets Layer)</code> 是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。</p><p><code>SSL</code> 包含记录层 <code>(Record Layer)</code> 和传输层，记录层协议确定传输层数据的封装格式。传输层安全协议使用 <code>X.509</code> 认证，然后利用非对称加密演算来对通信方做身份认证，之后交换对称密钥作为会谈密钥 <code>(Session key)</code>。这个会谈密钥是用来将通信两方交换的数据做加密，保证两个应用间通信的保密性和可靠性，使客户与服务器应用之间的通信不被攻击者窃听。</p><h2 id="HTTPS-协议"><a href="#HTTPS-协议" class="headerlink" title="HTTPS 协议"></a>HTTPS 协议</h2><p>超文本传输安全协议 <code>(HTTPS: HyperText Transfer Protocol Secure，常称为HTTP over TLS、HTTP over SSL或HTTP Secure)</code> 是一种通过计算机网络进行安全通信的传输协议。<code>HTTPS</code> 经由 <code>HTTP</code> 进行通信，但利用 <code>SSL/TLS</code> 来加密数据包。<code>HTTPS</code> 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p><h2 id="认证过程"><a href="#认证过程" class="headerlink" title="认证过程"></a>认证过程</h2><h3 id="单向认证"><a href="#单向认证" class="headerlink" title="单向认证"></a>单向认证</h3><p>在访问大多数网站 <code>(google, facebook)</code> 时，会使用单向认证的方式。客户端(浏览器)会验证服务端证书的合法性，过程如下：</p><p><img src="/images/https-mutual-authentication/01-one-way-authentication.png" alt="01-one-way-authentication"></p><ol><li>客户端发起建立 <code>HTTPS</code> 连接请求，将 <code>SSL</code> 协议版本的信息发送给服务器端</li><li>服务器端将本机的公钥证书 <code>(server.crt)</code> 发送给客户端</li><li>客户端读取公钥证书 <code>(server.crt)</code> 取出服务端公钥</li><li>客户端生成随机密钥 <code>R</code>，用服务器公钥加密密钥<code>R</code>，将密文发送给服务端</li><li>服务端用私钥 <code>(server.key)</code> 解密密文，得到了密钥 <code>R</code></li><li>双方使用随机密钥 <code>R</code> 通信的对称加密密钥</li></ol><h3 id="双向认证"><a href="#双向认证" class="headerlink" title="双向认证"></a>双向认证</h3><p>而在某些有较高安全性要求，或需要验证访问者身份的场景，则可能会需要用到双向认证的方式：</p><p><img src="/images/https-mutual-authentication/02-mutual-anthentication.png" alt="02-mutual-anthentication"></p><ol><li>客户端发起建立 <code>HTTPS</code> 连接请求，将 <code>SSL</code> 协议版本的信息发送给服务端；</li><li>服务器端将本机的公钥证书 <code>(server.crt)</code> 发送给客户端</li><li>客户端读取公钥证书 <code>(server.crt)</code> 取出服务端公钥</li><li>客户端将客户端公钥证书 <code>(client.crt)</code> 发送给服务器端</li><li>服务器端使用根证书 <code>(root.crt)</code> 解密客户端公钥证书，得到客户端公钥</li><li>客户端发送自己支持的加密方案给服务器端</li><li>服务器端根据自己和客户端的能力，选择一个双方都能接受的加密方案，使用客户端的公钥加密目标方案. 后发送给客户端；</li><li>客户端使用自己的私钥解密加密方案，生成随机密钥 <code>R</code>，使用服务器公钥加密后传给服务器端；</li><li>服务端用自己的私钥去解密这个密文，得到了密钥 <code>R</code></li><li>双方使用随机密钥 <code>R</code> 通信的对称加密密钥</li></ol><h2 id="生成自签名证书"><a href="#生成自签名证书" class="headerlink" title="生成自签名证书"></a>生成自签名证书</h2><p>生成这一些列证书之前，我们需要先生成一个 <code>CA</code> 根证书，然后由这个 <code>CA</code> 根证书颁发服务器公钥证书和客户端公钥证书。为了验证根证书颁发与验证客户端证书这个逻辑，我们使用根证书生成两套不同的客户端证书，然后同时用两个客户端证书来发送请求，看服务器端是否都能识别。下面是证书生成的内在逻辑示意图：</p><p><img src="/images/https-mutual-authentication/03-self-signed-sertificate.png" alt="03-self-signed-sertificate"></p><h3 id="生成根证书"><a href="#生成根证书" class="headerlink" title="生成根证书"></a>生成根证书</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建根证书私钥：</span></span><br><span class="line">$ openssl genrsa -out root.key 1024</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建根证书请求文件：</span></span><br><span class="line">$ openssl req -new -out root.csr -key root.key</span><br><span class="line"><span class="comment"># 后续参数请自行填写，下面是一个例子：</span></span><br><span class="line"><span class="comment"># Country Name (2 letter code) [XX]:cn</span></span><br><span class="line"><span class="comment"># State or Province Name (full name) []:bj</span></span><br><span class="line"><span class="comment"># Locality Name (eg, city) [Default City]:bj</span></span><br><span class="line"><span class="comment"># Organization Name (eg, company) [Default Company Ltd]:alibaba</span></span><br><span class="line"><span class="comment"># Organizational Unit Name (eg, section) []:test</span></span><br><span class="line"><span class="comment"># Common Name (eg, your name or your servers hostname) []:root</span></span><br><span class="line"><span class="comment"># Email Address []: a.divinerapier.cn</span></span><br><span class="line"><span class="comment"># A challenge password []:</span></span><br><span class="line"><span class="comment"># An optional company name []:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建根证书：</span></span><br><span class="line">$ openssl x509 -req -<span class="keyword">in</span> root.csr -out root.crt -signkey root.key -CAcreateserial -days 3650</span><br></pre></td></tr></table></figure><p>可以得到</p><ul><li><code>root.crt</code>: 有效期为 <code>10</code> 年的根证书</li></ul><h3 id="生成自签名服务器端证书"><a href="#生成自签名服务器端证书" class="headerlink" title="生成自签名服务器端证书"></a>生成自签名服务器端证书</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成服务器端证书私钥：</span></span><br><span class="line">$ openssl genrsa -out server.key 1024</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成服务器证书请求文件，过程和注意事项参考根证书，本节不详述：</span></span><br><span class="line">$ openssl req -new -out server.csr -key server.key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成服务器端公钥证书</span></span><br><span class="line">$ openssl x509 -req -<span class="keyword">in</span> server.csr -out server.crt -signkey server.key -CA root.crt -CAkey root.key -CAcreateserial -days 3650</span><br></pre></td></tr></table></figure><p>可以得到</p><ul><li><code>server.key</code>: 服务端私钥文件</li><li><code>server.crt</code>: 有效期为 <code>10</code> 年的服务端公钥文件</li></ul><h3 id="生成自签名客户端证书"><a href="#生成自签名客户端证书" class="headerlink" title="生成自签名客户端证书"></a>生成自签名客户端证书</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成客户端证书秘钥：</span></span><br><span class="line">$ openssl genrsa -out client.key 1024</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成客户端证书请求文件，过程和注意事项参考根证书，本节不详述：</span></span><br><span class="line">$ openssl req -new -out client.csr -key client.key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生客户端证书</span></span><br><span class="line">$ openssl x509 -req -<span class="keyword">in</span> client.csr -out client.crt -signkey client.key -CA root.crt -CAkey root.key -CAcreateserial -days 3650</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生客户端p12格式证书，输入一个好记的密码，比如 123456</span></span><br><span class="line">$ openssl pkcs12 -<span class="built_in">export</span> -clcerts -<span class="keyword">in</span> client.crt -inkey client.key -out client.p12</span><br></pre></td></tr></table></figure><p>可以得到</p><ul><li><code>client.key</code>: 客户端私钥文件</li><li><code>client.crt</code>: 有效期为 <code>10</code> 年的客户端公钥文件</li><li><code>client.p12</code>: 同时包含公钥与私钥的客户端 <code>p12</code> 证书文件</li></ul><h3 id="生成证书注意事项"><a href="#生成证书注意事项" class="headerlink" title="生成证书注意事项"></a>生成证书注意事项</h3><p>在创建证书请求文件的时候需要注意</p><ul><li>根证书的 <code>Common Name</code> 填写 <code>root</code> 就可以</li><li>所有客户端和服务器端的 <code>Common Name</code> 需要填写域名</li><li>根证书的 <code>Common Name</code> 与客户端证书、服务端证书的 <code>Common Name</code> 不能相同</li><li>其他所有字段的填写，根证书、服务器端证书、客户端证书需保持一致 最后的密码可以直接回车跳过</li></ul><h2 id="使用-golang-构建双向认证通信"><a href="#使用-golang-构建双向认证通信" class="headerlink" title="使用 golang 构建双向认证通信"></a>使用 golang 构建双向认证通信</h2><h3 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/tls"</span></span><br><span class="line">    <span class="string">"crypto/x509"</span></span><br><span class="line">    <span class="string">"flag"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> handler <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *handler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter,</span></span></span><br><span class="line"><span class="function"><span class="params">    r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintf(w,</span><br><span class="line">        <span class="string">"Hi, This is an example of https service in golang!\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> capath, certpath, keypath, bind <span class="keyword">string</span></span><br><span class="line">    flag.StringVar(&amp;capath, <span class="string">"ca"</span>, <span class="string">"./root.crt"</span>, <span class="string">"path of ca file"</span>)</span><br><span class="line">    flag.StringVar(&amp;certpath, <span class="string">"cert"</span>, <span class="string">"./server.crt"</span>, <span class="string">"path of cert file"</span>)</span><br><span class="line">    flag.StringVar(&amp;keypath, <span class="string">"key"</span>, <span class="string">"./server.key"</span>, <span class="string">"path of key file"</span>)</span><br><span class="line">    flag.StringVar(&amp;bind, <span class="string">"bind"</span>, <span class="string">":443"</span>, <span class="string">"local address to bind"</span>)</span><br><span class="line">    flag.Parse()</span><br><span class="line"></span><br><span class="line">    pool := x509.NewCertPool()</span><br><span class="line"></span><br><span class="line">    caCrt, err := ioutil.ReadFile(capath)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"ReadFile err:"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    pool.AppendCertsFromPEM(caCrt)</span><br><span class="line">    s := &amp;http.Server&#123;</span><br><span class="line">        Addr:    bind,</span><br><span class="line">        Handler: &amp;handler&#123;&#125;,</span><br><span class="line">        TLSConfig: &amp;tls.Config&#123;</span><br><span class="line">            ClientCAs:  pool,</span><br><span class="line">            ClientAuth: tls.RequireAndVerifyClientCert,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = s.ListenAndServeTLS(certpath, keypath)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"ListenAndServeTLS err:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/tls"</span></span><br><span class="line">    <span class="string">"crypto/x509"</span></span><br><span class="line">    <span class="string">"flag"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> host, capath, certpath, keypath <span class="keyword">string</span></span><br><span class="line">    flag.StringVar(&amp;capath, <span class="string">"ca"</span>, <span class="string">"./root.crt"</span>, <span class="string">"path of ca file"</span>)</span><br><span class="line">    flag.StringVar(&amp;certpath, <span class="string">"cert"</span>, <span class="string">"./client.crt"</span>, <span class="string">"path of cert file"</span>)</span><br><span class="line">    flag.StringVar(&amp;keypath, <span class="string">"key"</span>, <span class="string">"./client.key"</span>, <span class="string">"path of key file"</span>)</span><br><span class="line">    flag.StringVar(&amp;host, <span class="string">"host"</span>, <span class="string">"https://localhost"</span>, <span class="string">"host of https server"</span>)</span><br><span class="line">    flag.Parse()</span><br><span class="line"></span><br><span class="line">    pool := x509.NewCertPool()</span><br><span class="line"></span><br><span class="line">    caCrt, err := ioutil.ReadFile(capath)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"ReadFile err:"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    pool.AppendCertsFromPEM(caCrt)</span><br><span class="line"></span><br><span class="line">    cliCrt, err := tls.LoadX509KeyPair(certpath, keypath)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Loadx509keypair err:"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tr := &amp;http.Transport&#123;</span><br><span class="line">        TLSClientConfig: &amp;tls.Config&#123;</span><br><span class="line">            RootCAs:      pool,</span><br><span class="line">            Certificates: []tls.Certificate&#123;cliCrt&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    client := &amp;http.Client&#123;Transport: tr&#125;</span><br><span class="line">    resp, err := client.Get(host)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(body) + <span class="string">"\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TLS-协议&quot;&gt;&lt;a href=&quot;#TLS-协议&quot; class=&quot;headerlink&quot; title=&quot;TLS 协议&quot;&gt;&lt;/a&gt;TLS 协议&lt;/h2&gt;&lt;p&gt;传输层安全性协议 &lt;code&gt;(TLS: Transport Layer Security)&lt;/code&gt; </summary>
      
    
    
    
    
    <category term="tls" scheme="http://divinerapier.github.io/tags/tls/"/>
    
    <category term="ssl" scheme="http://divinerapier.github.io/tags/ssl/"/>
    
    <category term="https" scheme="http://divinerapier.github.io/tags/https/"/>
    
    <category term="mutual authentication" scheme="http://divinerapier.github.io/tags/mutual-authentication/"/>
    
  </entry>
  
  <entry>
    <title>设备控制器</title>
    <link href="http://divinerapier.github.io/2020/08/12/device-controllers/"/>
    <id>http://divinerapier.github.io/2020/08/12/device-controllers/</id>
    <published>2020-08-12T09:50:29.000Z</published>
    <updated>2020-08-15T07:41:01.835Z</updated>
    
    <content type="html"><![CDATA[<p>从功能角度方面，一个 <code>I/O</code> 单元由机械组件和电子组件两部分组合而成。而从设计的角度出发，将二者分开，则可以提供一种更具模块化，且更具通用性的设计模式。</p><p>电子组件，可被称作设备控制器(<code>device controller</code>)，也可被称作适配器 <code>(adapter)</code>。在个人计算机上，常见的设备控制器要么是直接在母板上的芯片，要么是可插入扩展插槽的印刷电路板。</p><p>机械组件其实就是设备本身。</p><p>下图为这种模块化的设计的简易示意图。</p><p><img src="/images/device-controllers/01-devices-arrangement.PNG" alt="arrangement"></p><p>控制器卡上有一些连接器，用途是允许通过线缆连接到设备上，大部分控制器卡支持两个，四个甚至八个设备。控制器和设备之间的接口可以是标准接口，比如 <code>ANSI</code>，<code>IEEE</code> 或 <code>ISO</code> 标准，也可以是事实上的标准，例如，<code>SATA</code>，<code>SCSI</code>，<code>USB</code>，<code>Thunderbolt</code> 或 <code>FireWire(IEEE 1394)</code>。</p><p>控制器和设备之间的接口属于非常底层的接口。例如，磁盘可能被格式化为<code>2,000,000</code> 个扇区，每个磁道 <code>512</code> 字节。但是，实际上从驱动器中出来的是一个串行位流，始于前导码 <code>(preamble)</code>，然后是一个扇区中的 <code>4096</code> 位，最后是一个校验和或纠错码 <code>(ECC)</code>。格式化磁盘后，将写入包含柱面号和扇区号，扇区大小，类似数据以及同步信息的前导码。</p><p>控制器的职责是将串行位流转换为字节块，并执行必要的纠错。首先，控制器在其内部缓冲区中，逐位组装成字节块。在确认校验和无误，且该块无错误后，可以将数据块复制到主存储器中。</p><p><code>LCD</code> 显示器的控制器在低电平时，可以用作位串行设备。它从存储器中读取包含要显示的字符的字节后，生成修改相应像素背光偏振的信号，实现将字符写入到屏幕上。试想，如果没有显示控制器，则需要操作系统开发者通过显式编程的方式，控制所有像素的电场，这将是一件多么可怕的事情。正是因为使用了控制器，操作系统只需通过少量参数来初始化控制器，例如每行的字符数，像素数以及每屏的行数，之后就可以让控制器来负责实际驱动电场。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从功能角度方面，一个 &lt;code&gt;I/O&lt;/code&gt; 单元由机械组件和电子组件两部分组合而成。而从设计的角度出发，将二者分开，则可以提供一种更具模块化，且更具通用性的设计模式。&lt;/p&gt;
&lt;p&gt;电子组件，可被称作设备控制器(&lt;code&gt;device controller&lt;/</summary>
      
    
    
    
    
    <category term="I/O" scheme="http://divinerapier.github.io/tags/I-O/"/>
    
    <category term="principles of i/o hardware" scheme="http://divinerapier.github.io/tags/principles-of-i-o-hardware/"/>
    
  </entry>
  
  <entry>
    <title>I/O 设备</title>
    <link href="http://divinerapier.github.io/2020/08/11/io-devices/"/>
    <id>http://divinerapier.github.io/2020/08/11/io-devices/</id>
    <published>2020-08-11T04:33:35.000Z</published>
    <updated>2020-08-11T13:50:38.083Z</updated>
    
    <content type="html"><![CDATA[<p><code>I/O</code> 设备大致可分为两类：块设备和字符设备。</p><p>块设备将信息存储在固定大小的块中。通常情况，数据块的大小在 <code>512 Bytes</code> 到 <code>32768 Bytes</code> 之间。所有传输过程均以<strong>块</strong>为单位，每次传输一个或多个完整且连续的块。对每个块的读或写操作是互相独立的，这是块设备的基本属性。常见的块设备有硬盘、蓝光光盘等。每个设备块都有各自的地址，因此块设备支持寻址操作，可以使用 <code>seek</code> 指令任意指定偏移位置。比如，磁盘接收到该指令后，通过旋转机械臂及磁头的方式完成寻址操作。</p><p>字符设备在传输数据时使用流式传输的方式，为不可寻址设备，因此也不支持 <code>seek</code> 操作。常见的字符设备有鼠标，网卡等。</p><p>但事实上，这种分类方案并不是完美无缺的。因为，还有一些设备无法适用于这个分类方案。</p><p>比如，时钟是一种按照预定义时间间隔产生中断信息的一种设备，它既不是可寻址的块设备，也不是字符流设备。除此之外，还有内存映射、屏幕、触摸屏等各类设备。但换一个角度分析，由于计算机使用到的大部分 <code>I/O</code> 设备，要么是块设备，要么是字符设备，这个分类模型足够通用。因此，可以用来作为独立于设备的基础操作系统基础模块。例如，文件系统就是用于处理经过抽象处理之后的块设备，而具体到设备层面的交互则交给更底层的软件处理，比如设备驱动程序。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;I/O&lt;/code&gt; 设备大致可分为两类：块设备和字符设备。&lt;/p&gt;
&lt;p&gt;块设备将信息存储在固定大小的块中。通常情况，数据块的大小在 &lt;code&gt;512 Bytes&lt;/code&gt; 到 &lt;code&gt;32768 Bytes&lt;/code&gt; 之间。所有传输过程均以&lt;s</summary>
      
    
    
    
    
    <category term="I/O" scheme="http://divinerapier.github.io/tags/I-O/"/>
    
    <category term="principles of i/o hardware" scheme="http://divinerapier.github.io/tags/principles-of-i-o-hardware/"/>
    
  </entry>
  
  <entry>
    <title>优化 WHERE 子句</title>
    <link href="http://divinerapier.github.io/2020/08/01/where-clause-optimization/"/>
    <id>http://divinerapier.github.io/2020/08/01/where-clause-optimization/</id>
    <published>2020-08-01T07:26:44.000Z</published>
    <updated>2020-08-01T09:38:50.046Z</updated>
    
    <content type="html"><![CDATA[<p>以 <code>SELECT</code> 语句为例，介绍如何优化 <code>WHERE</code> 子句。这些优化方法同样适用于 <code>DELETE</code> 和 <code>UPDATE</code> 语句中的 <code>WHERE</code> 子句。</p><p>在编写 <code>SQL</code> 时，开发者在主观上为了使语句执行的更快而去做一些所谓的“优化”。但实际上，这些“优化”要么会使 <code>SQL</code> 失去了可读性，要么是在重复 <code>MySQL</code> 做的事情。</p><p>下面列举一些 <code>MySQL</code> 会做的优化:</p><ul><li><p>删除不必要的括号</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">((a AND b) AND c OR (((a AND b) AND (c AND d))))</span><br><span class="line">-&gt; (a AND b AND c) OR (a AND b AND c AND d)</span><br></pre></td></tr></table></figure></li><li><p>常量替换(Constant folding)</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(a&lt;b AND b=c) AND a=5</span><br><span class="line">-&gt; b&gt;5 AND b=c AND a=5</span><br></pre></td></tr></table></figure></li><li><p>删除恒定条件</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(b&gt;=5 AND b=5) OR (b=6 AND 5=5) OR (b=7 AND 5=6)</span><br><span class="line">-&gt; b=5 OR b=6</span><br></pre></td></tr></table></figure><p>  在 <code>MySQL 8.0.14</code> 和更高版本中，这是在准备过程中发生的，而不是在优化阶段发生的，这有助于简化联接。 有关更多信息和示例，请参见 <a href="https://dev.mysql.com/doc/refman/8.0/en/outer-join-optimization.html" target="_blank" rel="noopener">Section 8.2.1.9, “Outer Join Optimization”</a>。</p></li><li><p>索引使用的常量表达式仅计算一次。</p></li><li><p>从 <code>MySQL 8.0.16</code> 开始，数值类型的列与常数比较时，折叠(folded)或删除无效或越界的值：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- CREATE TABLE t (c TINYINT UNSIGNED NOT NULL);</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> c ≪ <span class="number">256</span>;</span><br><span class="line">-≫ <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>对于使用<code>MyISAM</code> 和 <code>MEMORY</code>存储引擎的表，在单一表上执行 <a href="https://dev.mysql.com/doc/refman/8.0/en/aggregate-functions.html#function_count" target="_blank" rel="noopener"><code>COUNT(*)</code></a> 操作时，如果没有 <code>WHERE</code> 子句，或者 <code>WHERE</code> 子句的表达式 <code>NOT NULL</code>，都将直接从表信息中读取。</p><blockquote><p>COUNT(*) on a single table without a WHERE is retrieved directly from the table information for MyISAM and MEMORY tables. This is also done for any NOT NULL expression when used with only one table.</p></blockquote></li><li><p>尽早检测无效的常量表达式。<code>MySQL</code> 检测到无效 <code>SELECT</code> 语句时，直接返回无结果。</p></li><li><p>不使用 <code>GROUP BY</code> 或聚合函数(<code>COUNT()，MIN()</code>)时，会把 <code>HAVING</code> 与 <code>WHERE</code> 合并。</p></li><li><p>对于联接查询中的每个表，构造一个简单的 <code>WHERE</code> 实现快速 <code>WHERE</code> 评估，尽快跳过行的目的。</p></li><li><p>优先读取常量表。满足以下任意一个即为常量表：</p><ul><li>空表或具有一行的表。</li><li>使用 <code>WHERE</code> 语句构建得到的表，且 <code>WHERE</code> 子句中的所有列只能是 <code>PRIMARY KEY</code> 或 <code>NOT NULL UNIQUE</code> 索引与常量表达式比较。</li></ul><p>以下所有表均用作常量表：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WHERE primary_key=1;</span><br><span class="line"></span><br><span class="line">WHERE t1.primary_key=1 AND t2.primary_key=t1.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- PRIMARY KEY (column1,column2)</span></span><br><span class="line">WHERE column1=5 AND column2=7</span><br><span class="line"></span><br><span class="line"><span class="comment">-- unique_not_null_column INT NOT NULL UNIQUE</span></span><br><span class="line">WHERE unique_not_null_column=5</span><br></pre></td></tr></table></figure><p>参考 <a href="https://dev.mysql.com/doc/internals/en/optimizer-constants-constant-tables.html" target="_blank" rel="noopener">7.2.1.4 Constants and Constant Tables</a> 了解更多有关常量与常量表。</p></li><li><p>通过尝试所有可能的方法，找到用于联接表的最佳联接组合。如果 <code>ORDER BY</code> 和 <code>GROUP BY</code> 子句中的所有列都来自同一表，则在连接时优先使用该表。</p></li><li><p>如果 <code>ORDER BY</code> 子句和 <code>GROUP BY</code> 子句使用不同的列，或者 <code>ORDER BY</code>/<code>GROUP BY</code> 使用的列不属于联接队列中第一个表，则会创建一个临时表。</p><blockquote><p>If there is an ORDER BY clause and a different GROUP BY clause, or if the ORDER BY or GROUP BY contains columns from tables other than the first table in the join queue, a temporary table is created.</p></blockquote></li><li><p>如果使用 <code>SQL_SMALL_RESULT</code> 修饰符，<code>MySQL</code> 将使用内存临时表。</p></li><li><p>从表的所有索引中选择一个最佳索引使用。或者，优化器认为全表扫描更有效时，会选择全表扫描。曾经，当使用最佳索引仍然会跨越表的 <code>30%</code>(<code>spanned more than 30% of the table</code>)时，就会选择使用全表扫描。但现在，使用索引还是全表扫描不再只取决于固定百分比，同时还要考虑其他因素，例如表大小，行数和 <code>I/O</code> 块大小。</p></li><li><p>在某些情况下，<code>MySQL</code> 可以从索引中读取数据行，而无需查询数据文件。如果索引中使用的所有列都是数字列，则仅使用索引树解析查询。</p></li><li><p>在输出每一行之前，将跳过与 <code>HAVING</code> 子句不匹配的行。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以 &lt;code&gt;SELECT&lt;/code&gt; 语句为例，介绍如何优化 &lt;code&gt;WHERE&lt;/code&gt; 子句。这些优化方法同样适用于 &lt;code&gt;DELETE&lt;/code&gt; 和 &lt;code&gt;UPDATE&lt;/code&gt; 语句中的 &lt;code&gt;WHERE&lt;/code&gt; 子句。</summary>
      
    
    
    
    
    <category term="mysql" scheme="http://divinerapier.github.io/tags/mysql/"/>
    
    <category term="optimization" scheme="http://divinerapier.github.io/tags/optimization/"/>
    
    <category term="where clause" scheme="http://divinerapier.github.io/tags/where-clause/"/>
    
  </entry>
  
  <entry>
    <title>优化 SELECT 语句</title>
    <link href="http://divinerapier.github.io/2020/07/28/optimizing-select-statements/"/>
    <id>http://divinerapier.github.io/2020/07/28/optimizing-select-statements/</id>
    <published>2020-07-28T13:45:48.000Z</published>
    <updated>2020-08-11T13:57:18.553Z</updated>
    
    <content type="html"><![CDATA[<p>数据库中所有查找操作，均以 <code>SELECT</code> 语句的形式执行。无论是实现网站秒级以内的响应时间，还是期望在生成大量的隔夜报告是缩短数小时的执行时间，调试这类语句都是重中之重。</p><p>除了 <code>SELECT</code> 语句外，相同的技术还适用于诸如 <code>CREATE TABLE ... AS SELECT</code>，<code>INSERT INTO ... SELECT</code> 和 <code>DELETE</code> 语句中的 <code>WHERE</code> 子句。但由于这些语句同时会涉及到读写两种操作，因此还需要考虑其他方面的性能问题。</p><p>多节点集群支持 <strong><code>JOIN</code> 查询下推优化(<code>join pushdown optimization</code>)</strong>，能将符合条件的 <code>JOIN</code> 完整地发送到集群的数据节点，让这个查询请求被分发到这些节点上并行执行。有关此优化的更多信息，请参见<a href="https://dev.mysql.com/doc/refman/8.0/en/mysql-cluster-options-variables.html#ndb_join_pushdown-conditions" target="_blank" rel="noopener">Conditions for NDB pushdown joins</a>。</p><p>优化查询的核心因素：</p><ul><li><p>如何查询语句 <code>SELECT ... WHERE</code> 执行的非常之慢，首选提速方法就是检查是否可以添加<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_index" target="_blank" rel="noopener">索引</a>。在 <code>WHERE</code> 子句中使用的列上设置索引，以加快执行，过滤，检索结果等操作的速度。同时，索引信息需要占用一定的磁盘空间，请尽可能在有一定关联性的查询中复用索引。</p><p>  在执行 <code>JOIN</code> 查询，外键关联等需要多个表参与的查询语句时，索引尤为重要。此时，可以通过 <a href="https://dev.mysql.com/doc/refman/8.0/en/explain.html" target="_blank" rel="noopener">EXPLAIN</a> 语句来确定，执行 <code>SELECT</code> 语句时，实际有哪些索引真正被使用了。参见 <a href="https://dev.mysql.com/doc/refman/8.0/en/mysql-indexes.html" target="_blank" rel="noopener">Section 8.3.1, “How MySQL Uses Indexes”</a> and <a href="https://dev.mysql.com/doc/refman/8.0/en/using-explain.html" target="_blank" rel="noopener">Section 8.8.1, “Optimizing Queries with EXPLAIN”</a>。</p></li><li><p>隔离和调整查询中花费时间过多的任何部分，例如函数调用。 根据查询的结构方式，可以对结果集中的每一行调用一次函数，甚至可以对表中的每一行调用一次函数，从而极大地提高了效率。</p></li><li><p>最小化查询中<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_full_table_scan" target="_blank" rel="noopener">全表扫描</a>的次数，特别是对于大表。</p></li><li><p>通过定期使用 <a href="https://dev.mysql.com/doc/refman/8.0/en/analyze-table.html" target="_blank" rel="noopener"><code>ANALYZE TABLE</code></a> 语句使表统计信息保持最新状态，让优化器具有充足的信息构造有效执行计划。</p></li><li><p>了解每种存储引擎的调整技术，索引技术和配置参数。无论是 <code>InnoDB</code> 还是 <code>MyISAM</code>，都各自具有一套保持查询高性能的准则。参见 <a href="https://dev.mysql.com/doc/refman/8.0/en/optimizing-innodb-queries.html" target="_blank" rel="noopener">Section 8.5.6, “Optimizing InnoDB Queries”</a> 和 <a href="https://dev.mysql.com/doc/refman/8.0/en/optimizing-queries-myisam.html" target="_blank" rel="noopener">Section 8.6.1, “Optimizing MyISAM Queries”</a>。</p></li><li><p>使用 <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-performance-ro-txn.html" target="_blank" rel="noopener">Section 8.5.3, “Optimizing InnoDB Read-Only Transactions”</a> 中的技术优化 <code>InnoDB</code> 表的单查询事务。</p></li><li><p>避免以难以理解的方式转换查询，特别是在优化器自动执行某些相同转换的情况下。</p></li><li><p>当使用基本准则不能轻松解决性能问题时，可以通过阅读 <a href="https://dev.mysql.com/doc/refman/8.0/en/explain.html" target="_blank" rel="noopener">EXPLAIN</a> 计划并调整索引，<code>WHERE</code>，<code>JOIN</code> 等子句来调查特定查询的内部详细信息。(有一定经验之后，阅读 <a href="https://dev.mysql.com/doc/refman/8.0/en/explain.html" target="_blank" rel="noopener">EXPLAIN</a> 计划可能是每个查询的第一步。)</p></li><li><p>调整 <code>MySQL</code> 用于缓存的内存区域的大小和属性。合理使用 InnoDB 的<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_buffer_pool" target="_blank" rel="noopener">buffer pool</a>，<code>MyISAM</code> 的 <code>key cache</code> 和 <code>MySQL</code> 的 <code>query cache</code>，可以让重复查询的运行速度更快。</p></li><li><p>即使查询已经使用了内存缓存，也依然可能对其进一步优化，使其需要更少的内存，从而使应用程序更具可伸缩性。比如，应用程序可以同时处理更多的用户，更大的请求量，而不会导致性能大幅下降。</p></li><li><p>锁定问题，多个会话同时访问同一张表可能会影响查询速度。</p></li></ul><h3 id="更多优化策略"><a href="#更多优化策略" class="headerlink" title="更多优化策略"></a>更多优化策略</h3><ul><li><a href="https://blog.divinerapier.cn/2020/08/01/where-clause-optimization/" target="_blank" rel="noopener">WHERE Clause Optimization</a></li><li>Range Optimization</li><li>Index Merge Optimization</li><li>Hash Join Optimization</li><li>Engine Condition Pushdown Optimization</li><li>Index Condition Pushdown Optimization</li><li>Nested-Loop Join Algorithms</li><li>Nested Join Optimization</li><li>Outer Join Optimization</li><li>Outer Join Simplification</li><li>Multi-Range Read Optimization</li><li>Block Nested-Loop and Batched Key Access Joins</li><li>Condition Filtering</li><li>Constant-Folding Optimization</li><li>IS NULL Optimization</li><li>ORDER BY Optimization</li><li>GROUP BY Optimization</li><li>DISTINCT Optimization</li><li>LIMIT Query Optimization</li><li>Function Call Optimization</li><li>Window Function Optimization</li><li>Row Constructor Expression Optimization</li><li>Avoiding Full Table Scans</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数据库中所有查找操作，均以 &lt;code&gt;SELECT&lt;/code&gt; 语句的形式执行。无论是实现网站秒级以内的响应时间，还是期望在生成大量的隔夜报告是缩短数小时的执行时间，调试这类语句都是重中之重。&lt;/p&gt;
&lt;p&gt;除了 &lt;code&gt;SELECT&lt;/code&gt; 语句外，相同的技</summary>
      
    
    
    
    
    <category term="mysql" scheme="http://divinerapier.github.io/tags/mysql/"/>
    
    <category term="optimization" scheme="http://divinerapier.github.io/tags/optimization/"/>
    
    <category term="select statements" scheme="http://divinerapier.github.io/tags/select-statements/"/>
    
  </entry>
  
  <entry>
    <title>优化SQL语句</title>
    <link href="http://divinerapier.github.io/2020/07/28/optimizing-sql-statements/"/>
    <id>http://divinerapier.github.io/2020/07/28/optimizing-sql-statements/</id>
    <published>2020-07-28T11:41:54.000Z</published>
    <updated>2020-07-28T13:51:51.836Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Optimizing SELECT Statements</li><li>Optimizing Subqueries, Derived Tables, View References, and Common Table Expressions</li><li>Optimizing INFORMATION_SCHEMA Queries</li><li>Optimizing Performance Schema Queries</li><li>Optimizing Data Change Statements</li><li>Optimizing Database Privileges</li><li>Other Optimization Tips</li></ol><p>数据库应用程序的核心逻辑是通过 <code>SQL</code> 语句执行的，无论这些 <code>SQL</code> 语句是通过解释程序直接发出还是通过调用 <code>API</code> 提交。之后提到的调整准则有助于加快各种使用到 <code>MySQL</code> 应用程序的速度。指南涵盖了读写数据的 <code>SQL</code> 操作，通用 <code>SQL</code> 操作的底层开销以及在特定方案（例如数据库监视）中使用的操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;Optimizing SELECT Statements&lt;/li&gt;
&lt;li&gt;Optimizing Subqueries, Derived Tables, View References, and Common Table Expressions&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    
    <category term="mysql" scheme="http://divinerapier.github.io/tags/mysql/"/>
    
    <category term="optimization" scheme="http://divinerapier.github.io/tags/optimization/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 性能优化概述</title>
    <link href="http://divinerapier.github.io/2020/07/27/mysql-optimization-overview/"/>
    <id>http://divinerapier.github.io/2020/07/27/mysql-optimization-overview/</id>
    <published>2020-07-27T13:43:22.000Z</published>
    <updated>2020-07-27T14:41:42.600Z</updated>
    
    <content type="html"><![CDATA[<p>在软件层面，数据库的性能会受到表结构，查询语句和数据库系统配置等几个方面的影响。这些软件层面的因素会直接决定 CPU 和 I/O 等硬件如何操作。我们要努力做到硬件操作的最小化。</p><p>对于研究数据库性能的初学者而言，可以从学习数据库的高级规则和准则开始，学会使用时钟时间来作为衡量性能的指标。而对于那些想要成为数据库性能优化领域的专家的人来说，则需要他们了解更多关于数据库底层的知识，能使用更具有一般性的指标，诸如 CPU 周期和 I/O 操作等来衡量性能。</p><p>大部分的用户，希望从其现有的软件和硬件配置中获得最佳的数据库性能。进阶用户则专注于寻找机会改进 MySQL 软件本身，或者开发自己的存储引擎和硬件设备以扩展 MySQL 生态系统。</p><h2 id="在数据库级别进行优化"><a href="#在数据库级别进行优化" class="headerlink" title="在数据库级别进行优化"></a>在数据库级别进行优化</h2><p>使数据库应用程序快速运行的最重要因素是其基本设计：</p><ul><li><p>表格的结构是否正确？ 特别是，这些列是否具有正确的数据类型，并且每个表都具有适合于该工作类型的列吗？ 例如，执行频繁更新的应用程序通常具有许多表而具有很少的列，而分析大量数据的应用程序通常具有很少的表而具有很多列。</p></li><li><p>是否安装了正确的<a href="https://dev.mysql.com/doc/refman/8.0/en/optimization-indexes.html" target="_blank" rel="noopener">索引</a>以提高查询效率？</p></li><li><p>您是否为每个表使用了适当的存储引擎，并利用了所使用的每个存储引擎的优势和功能？ 特别是，对于性能和可伸缩性而言，选择事务存储引擎（例如 <a href="https://dev.mysql.com/doc/refman/8.0/en/optimizing-innodb.html" target="_blank" rel="noopener">InnoDB</a>）或非事务存储引擎（例如 <a href="https://dev.mysql.com/doc/refman/8.0/en/optimizing-myisam.html" target="_blank" rel="noopener">MyISAM</a>）可能非常重要。</p><blockquote><p>注意<br><code>InnoDB</code> 是新表的默认存储引擎。 实际上，先进的 <code>InnoDB</code> 性能功能意味着 <code>InnoDB</code> 表通常优于简单的 <code>MyISAM</code> 表，尤其是对于繁忙的数据库。</p></blockquote></li><li><p>每个表都使用适当的行格式吗？ 该选择还取决于表使用的存储引擎。 特别是，压缩表使用较少的磁盘空间，因此需要较少的磁盘I / O来读取和写入数据。 压缩可用于带有 <code>InnoDB</code> 表的所有类型的工作负载以及只读的 <code>MyISAM</code> 表。</p></li><li><p>应用程序是否使用适当的<a href="https://dev.mysql.com/doc/refman/8.0/en/locking-issues.html" target="_blank" rel="noopener">锁定策略</a>？ 例如，通过在可能的情况下允许共享访问，以便数据库操作可以同时运行，并在适当的时候请求独占访问，以使关键操作获得最高优先级。 同样，存储引擎的选择很重要。 InnoDB存储引擎无需您的参与即可处理大多数锁定问题，从而可以更好地并发数据库并减少代码的试验和调整量。</p></li><li><p>用于<a href="https://dev.mysql.com/doc/refman/8.0/en/buffering-caching.html" target="_blank" rel="noopener">缓存</a>的所有内存区域大小是否正确？ 也就是说，足够大以容纳经常访问的数据，但又不能太大以至于它们会使物理内存过载并导致分页。 要配置的主要内存区域是 <code>InnoDB</code> 缓冲池和 <code>MyISAM</code> 密钥缓存。</p></li></ul><h2 id="在硬件级别进行优化"><a href="#在硬件级别进行优化" class="headerlink" title="在硬件级别进行优化"></a>在硬件级别进行优化</h2><p>随着数据库变得越来越繁忙，任何数据库应用程序最终都会达到硬件极限。 DBA必须评估是否有可能调整应用程序或重新配置服务器以避免这些<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_bottleneck" target="_blank" rel="noopener">瓶颈</a>，或者是否需要更多的硬件资源。 系统瓶颈通常来自以下来源：</p><ul><li>磁盘搜寻。 磁盘查找数据需要花费时间。 对于现代磁盘，此操作的平均时间通常小于10毫秒，因此理论上我们可以执行100次搜索。 这段时间随着新磁盘的使用而缓慢改善，并且很难为单个表进行优化。 优化寻道时间的方法是将数据分发到多个磁盘上。</li><li>磁盘读写。 当磁盘位于正确的位置时，我们需要读取或写入数据。 对于现代磁盘，一个磁盘至少可提供10–20MB / s的吞吐量。 与查找相比，优化起来更容易，因为您可以从多个磁盘并行读取。</li><li>CPU周期。 当数据位于主存储器中时，我们必须对其进行处理以获得结果。 与内存量相比，拥有较大的表是最常见的限制因素。 但是对于小桌子，速度通常不是问题。</li><li>内存带宽。 当CPU需要的数据超出CPU缓存的容量时，主内存带宽将成为瓶颈。 对于大多数系统来说，这是一个不常见的瓶颈，但是要意识到这一点。</li></ul><h2 id="平衡便携性和性能"><a href="#平衡便携性和性能" class="headerlink" title="平衡便携性和性能"></a>平衡便携性和性能</h2><p>MySQL 支持在 SQL 注释中（<code>/*！*/</code>）通过特定的关键字来指定优化策略。而且，因为是在注释中，会被其他的 SQL 服务忽略，因此，SQL 语句仍然是可移植的。有关编写注释的信息，请参见 <a href="https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html" target="_blank" rel="noopener">8.9.3 优化器提示</a>，<a href="https://dev.mysql.com/doc/refman/8.0/en/comments.html" target="_blank" rel="noopener">9.6 注释语法</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在软件层面，数据库的性能会受到表结构，查询语句和数据库系统配置等几个方面的影响。这些软件层面的因素会直接决定 CPU 和 I/O 等硬件如何操作。我们要努力做到硬件操作的最小化。&lt;/p&gt;
&lt;p&gt;对于研究数据库性能的初学者而言，可以从学习数据库的高级规则和准则开始，学会使用时</summary>
      
    
    
    
    
    <category term="mysql" scheme="http://divinerapier.github.io/tags/mysql/"/>
    
    <category term="optimization" scheme="http://divinerapier.github.io/tags/optimization/"/>
    
  </entry>
  
</feed>
