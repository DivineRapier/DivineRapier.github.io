<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>お可愛いこと</title>
  
  
  <link href="http://divinerapier.github.io/atom.xml" rel="self"/>
  
  <link href="http://divinerapier.github.io/"/>
  <updated>2020-10-23T08:21:31.110Z</updated>
  <id>http://divinerapier.github.io/</id>
  
  <author>
    <name>divinerapier</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MPI Operator</title>
    <link href="http://divinerapier.github.io/2020/10/23/mpi-operator/"/>
    <id>http://divinerapier.github.io/2020/10/23/mpi-operator/</id>
    <published>2020-10-23T08:17:12.000Z</published>
    <updated>2020-10-23T08:21:31.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://github.com/kubeflow/mpi-operator" target="_blank" rel="noopener">GitHub: MPI Operator</a></li><li><a href="https://medium.com/kubeflow/introduction-to-kubeflow-mpi-operator-and-industry-adoption-296d5f2e6edc" target="_blank" rel="noopener">Introduction to Kubeflow MPI Operator and Industry Adoption</a></li><li><a href="https://www.kubeflow.org/docs/components/training/mpi/" target="_blank" rel="noopener">MPI Training</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考文档&quot;&gt;&lt;a href=&quot;#参考文档&quot; class=&quot;headerlink&quot; title=&quot;参考文档&quot;&gt;&lt;/a&gt;参考文档&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/kubeflow/mpi-operator&quot; targe</summary>
      
    
    
    
    
    <category term="kubernetes" scheme="http://divinerapier.github.io/tags/kubernetes/"/>
    
    <category term="mpi" scheme="http://divinerapier.github.io/tags/mpi/"/>
    
    <category term="operator" scheme="http://divinerapier.github.io/tags/operator/"/>
    
  </entry>
  
  <entry>
    <title>升级 Ubuntu 发行版</title>
    <link href="http://divinerapier.github.io/2020/10/20/upgrade-ubuntu-release/"/>
    <id>http://divinerapier.github.io/2020/10/20/upgrade-ubuntu-release/</id>
    <published>2020-10-20T08:05:06.000Z</published>
    <updated>2020-10-20T08:15:06.347Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Install all available updates for your release before upgrading.</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt upgrade -y</span><br></pre></td></tr></table></figure><p><strong>Reboot system.</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><p><strong>Install the Ubuntu update tool.</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y update-manager-core</span><br></pre></td></tr></table></figure><p><strong>Start the upgrade procdure.</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">do</span>-release-upgrade</span><br></pre></td></tr></table></figure><p>不建议升级过程通过 <strong>ssh</strong> 连接运行，可以运行在 <strong>tmux</strong> 会话中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="keyword">do</span>-release-upgrade</span><br><span class="line">Checking <span class="keyword">for</span> a new Ubuntu release</span><br><span class="line">Get:1 Upgrade tool signature [1,554 B]</span><br><span class="line">Get:2 Upgrade tool [1,336 kB]</span><br><span class="line">Fetched 1,338 kB <span class="keyword">in</span> 0s (0 B/s)</span><br><span class="line">authenticate <span class="string">'focal.tar.gz'</span> against <span class="string">'focal.tar.gz.gpg'</span></span><br><span class="line">extracting <span class="string">'focal.tar.gz'</span></span><br><span class="line"></span><br><span class="line">Reading cache</span><br><span class="line"></span><br><span class="line">Checking package manager</span><br><span class="line"></span><br><span class="line">Continue running under SSH?</span><br><span class="line"></span><br><span class="line">This session appears to be running under ssh. It is not recommended</span><br><span class="line">to perform a upgrade over ssh currently because <span class="keyword">in</span> <span class="keyword">case</span> of failure it</span><br><span class="line">is harder to recover.</span><br><span class="line"></span><br><span class="line">If you <span class="built_in">continue</span>, an additional ssh daemon will be started at port</span><br><span class="line"><span class="string">'1022'</span>.</span><br><span class="line">Do you want to <span class="built_in">continue</span>?</span><br><span class="line"></span><br><span class="line">Continue [yN]</span><br></pre></td></tr></table></figure><p><strong>Reboot the box.</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Install all available updates for your release before upgrading.&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class</summary>
      
    
    
    
    
    <category term="ubuntu" scheme="http://divinerapier.github.io/tags/ubuntu/"/>
    
    <category term="linux" scheme="http://divinerapier.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>使用 kubeadm 创建 kubernetes 集群</title>
    <link href="http://divinerapier.github.io/2020/10/19/using-kubeadm-to-create-a-kubernetes-cluster/"/>
    <id>http://divinerapier.github.io/2020/10/19/using-kubeadm-to-create-a-kubernetes-cluster/</id>
    <published>2020-10-19T12:38:25.000Z</published>
    <updated>2020-10-23T13:56:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 <strong>Ubuntu 20.04</strong> 系统上搭建 <strong>Kubernetes</strong> 集群。</p><h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line">sudo apt-key fingerprint 0EBFCD88</span><br><span class="line">sudo add-apt-repository \</span><br><span class="line">   <span class="string">"deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">   <span class="variable">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">   stable"</span></span><br><span class="line">sudo apt-get update --fix-missing</span><br><span class="line">sudo apt-get install -y docker-ce docker-ce-cli containerd.io</span><br><span class="line">cat &lt;&lt;EOF | sudo tee /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"exec-opts"</span>: [<span class="string">"native.cgroupdriver=systemd"</span>],</span><br><span class="line">  <span class="string">"log-driver"</span>: <span class="string">"json-file"</span>,</span><br><span class="line">  <span class="string">"log-opts"</span>: &#123;</span><br><span class="line">    <span class="string">"max-size"</span>: <span class="string">"100m"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"storage-driver"</span>: <span class="string">"overlay2"</span></span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo mkdir -p /etc/systemd/system/docker.service.d</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure><h2 id="下载-Kubernetes-相关程序"><a href="#下载-Kubernetes-相关程序" class="headerlink" title="下载 Kubernetes 相关程序"></a>下载 Kubernetes 相关程序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install -y apt-transport-https curl</span><br><span class="line">curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -</span><br><span class="line">cat &lt;&lt;EOF | sudo tee /etc/apt/sources.list.d/kubernetes.list</span><br><span class="line">deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main</span><br><span class="line">EOF</span><br><span class="line">sudo apt-get update --fix-missing</span><br><span class="line">sudo apt-get install -y kubelet kubeadm kubectl</span><br><span class="line">sudo apt-mark hold kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure><h2 id="配置桥接网络防火墙"><a href="#配置桥接网络防火墙" class="headerlink" title="配置桥接网络防火墙"></a>配置桥接网络防火墙</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure><h2 id="关闭-swap"><a href="#关闭-swap" class="headerlink" title="关闭 swap"></a>关闭 swap</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 临时关闭</span></span><br><span class="line">swapoff -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 永久关闭，注释 swap 配置</span></span><br><span class="line">vi /etc/fstab</span><br></pre></td></tr></table></figure><h2 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop firewalld</span><br><span class="line">sudo systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure><h2 id="关闭-selinux"><a href="#关闭-selinux" class="headerlink" title="关闭 selinux"></a>关闭 selinux</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo sed -i <span class="string">'s/enforcing/disabled/'</span> /etc/selinux/config</span><br><span class="line">sudo setenforce 0</span><br></pre></td></tr></table></figure><h2 id="拉取-gcr-镜像"><a href="#拉取-gcr-镜像" class="headerlink" title="拉取 gcr 镜像"></a>拉取 gcr 镜像</h2><p>需要在所有的 <strong>Master</strong> 节点与 <strong>Worker</strong> 节点拉取镜像。</p><p><strong>bash</strong> 环境使用如下脚本:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">image_list=$(kubeadm config images list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> image <span class="keyword">in</span> <span class="variable">$&#123;image_list&#125;</span> ; <span class="keyword">do</span></span><br><span class="line">  name=$(<span class="built_in">echo</span> <span class="variable">$&#123;image&#125;</span> | cut -d<span class="string">'/'</span> -f2)</span><br><span class="line">  docker pull registry.aliyuncs.com/google_containers/<span class="variable">$name</span></span><br><span class="line">  docker image tag registry.aliyuncs.com/google_containers/<span class="variable">$name</span> k8s.gcr.io/<span class="variable">$name</span></span><br><span class="line">  docker image rm registry.aliyuncs.com/google_containers/<span class="variable">$name</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>zsh</strong> 环境使用如下脚本:</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">image_list=$(kubeadm config images list)</span><br><span class="line">images=(`<span class="built_in">echo</span> <span class="variable">$&#123;image_list&#125;</span> | tr <span class="string">'\n'</span> <span class="string">' '</span>`)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> image <span class="keyword">in</span> <span class="variable">$&#123;images&#125;</span> ; <span class="keyword">do</span></span><br><span class="line">  name=$(<span class="built_in">echo</span> <span class="variable">$&#123;image&#125;</span> | cut -d<span class="string">'/'</span> -f2)</span><br><span class="line">  docker pull registry.aliyuncs.com/google_containers/<span class="variable">$name</span></span><br><span class="line">  docker image tag registry.aliyuncs.com/google_containers/<span class="variable">$name</span> k8s.gcr.io/<span class="variable">$name</span></span><br><span class="line">  docker image rm registry.aliyuncs.com/google_containers/<span class="variable">$name</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="初始化-Master-节点"><a href="#初始化-Master-节点" class="headerlink" title="初始化 Master 节点"></a>初始化 Master 节点</h2><p>在 <strong>Master</strong> 节点执行命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sudo kubeadm init --apiserver-advertise-address $(hostname -i) --pod-network-cidr 10.5.0.0/16 --v=5</span><br><span class="line"></span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run <span class="string">"kubectl apply -f [podnetwork].yaml"</span> with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 192.168.50.5:6443 --token 7zjyq9.x3xkoatt6pb1cbsu \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:1c78c44bc57e6e887c5f81e7a9c6c3e52f098e1ba9255f5303ac78129d410774</span><br></pre></td></tr></table></figure><p>或者省略下载镜像步骤，直接创建集群 (未测试):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">  --apiserver-advertise-address=192.168.50.5 \</span><br><span class="line">  --image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">  --kubernetes-version v1.14.0 \</span><br><span class="line">  --service-cidr=10.1.0.0/16 \</span><br><span class="line">  --pod-network-cidr=10.244.0.0/16</span><br></pre></td></tr></table></figure><p>然后配置 <strong>kubeconfig</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure><h2 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h2><h3 id="Calico"><a href="#Calico" class="headerlink" title="Calico"></a>Calico</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p calico; <span class="built_in">cd</span> calico</span><br><span class="line">curl https://docs.projectcalico.org/manifests/canal.yaml -O</span><br><span class="line">kubectl apply -f canal.yaml</span><br><span class="line"><span class="built_in">cd</span> -</span><br></pre></td></tr></table></figure><h2 id="添加-Worker-节点"><a href="#添加-Worker-节点" class="headerlink" title="添加 Worker 节点"></a>添加 Worker 节点</h2><p>在 <strong>Worker</strong> 节点执行命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo kubeadm join 192.168.50.5:6443 --token 4n2pwp.hq9jyo3auaibma3q     --discovery-token-ca-cert-hash sha256:750da2c87a67b96bfec73ade40888d22b61e045fdd28bbb7a4ff2c6ce3e0309c</span><br><span class="line"></span><br><span class="line">This node has joined the cluster:</span><br><span class="line">* Certificate signing request was sent to apiserver and a response was received.</span><br><span class="line">* The Kubelet was informed of the new secure connection details.</span><br><span class="line"></span><br><span class="line">Run <span class="string">'kubectl get nodes'</span> on the control-plane to see this node join the cluster.</span><br></pre></td></tr></table></figure><h2 id="测试集群"><a href="#测试集群" class="headerlink" title="测试集群"></a>测试集群</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/application/nginx-app.yaml</span><br></pre></td></tr></table></figure><h2 id="清理集群"><a href="#清理集群" class="headerlink" title="清理集群"></a>清理集群</h2><p>在期望清理的节点执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm reset</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://docs.docker.com/engine/install/ubuntu/" target="_blank" rel="noopener">Install Docker Engine on Ubuntu</a></li><li><a href="https://kubernetes.io/docs/setup/production-environment/container-runtimes/" target="_blank" rel="noopener">Container runtimes</a></li><li><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/" target="_blank" rel="noopener">Installing kubeadm</a></li><li><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/" target="_blank" rel="noopener">Creating a cluster with kubeadm</a></li><li><a href="https://github.com/cloudnativelabs/kube-router/blob/master/docs/kubeadm.md" target="_blank" rel="noopener">Deploying kube-router with kubeadm</a></li><li><a href="https://docs.projectcalico.org/getting-started/kubernetes/flannel/flannel" target="_blank" rel="noopener">Install Calico for policy and flannel (aka Canal) for networking</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 &lt;strong&gt;Ubuntu 20.04&lt;/strong&gt; 系统上搭建 &lt;strong&gt;Kubernetes&lt;/strong&gt; 集群。&lt;/p&gt;
&lt;h2 id=&quot;安装-Docker&quot;&gt;&lt;a href=&quot;#安装-Docker&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="kubernetes" scheme="http://divinerapier.github.io/tags/kubernetes/"/>
    
    <category term="kubeadm" scheme="http://divinerapier.github.io/tags/kubeadm/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 20.04 配置静态网络</title>
    <link href="http://divinerapier.github.io/2020/10/19/configure-networks-on-ubuntu-20-04/"/>
    <id>http://divinerapier.github.io/2020/10/19/configure-networks-on-ubuntu-20-04/</id>
    <published>2020-10-19T10:55:44.000Z</published>
    <updated>2020-10-19T11:56:03.548Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Ubuntu 20.04</strong> 的网络配置文件位于 <strong>/etc/netplan/00-installer-config.yaml</strong>:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This is the network config written by 'subiquity'</span></span><br><span class="line"><span class="attr">network:</span></span><br><span class="line">  <span class="attr">ethernets:</span></span><br><span class="line">    <span class="attr">ens33:</span></span><br><span class="line">      <span class="attr">dhcp4:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">addresses:</span> <span class="string">[192.168.50.30/24]</span></span><br><span class="line">      <span class="attr">gateway4:</span> <span class="number">192.168</span><span class="number">.50</span><span class="number">.1</span></span><br><span class="line">      <span class="attr">nameservers:</span></span><br><span class="line">        <span class="attr">addresses:</span> <span class="string">[192.168.50.1,</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span><span class="string">]</span></span><br></pre></td></tr></table></figure><p>更新配置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu-00:~<span class="comment"># netplan --debug apply</span></span><br><span class="line">** (generate:3768): DEBUG: 11:49:11.734: Processing input file /etc/netplan/00-installer-config.yaml..</span><br><span class="line">** (generate:3768): DEBUG: 11:49:11.734: starting new processing pass</span><br><span class="line">** (generate:3768): DEBUG: 11:49:11.735: We have some netdefs, pass them through a final round of validation</span><br><span class="line">** (generate:3768): DEBUG: 11:49:11.735: ens33: setting default backend to 1</span><br><span class="line">** (generate:3768): DEBUG: 11:49:11.735: Configuration is valid</span><br><span class="line">** (generate:3768): DEBUG: 11:49:11.736: Generating output files..</span><br><span class="line">** (generate:3768): DEBUG: 11:49:11.736: NetworkManager: definition ens33 is not <span class="keyword">for</span> us (backend 1)</span><br><span class="line">(generate:3768): GLib-DEBUG: 11:49:11.736: posix_spawn avoided (fd close requested)</span><br><span class="line">DEBUG:netplan generated networkd configuration changed, restarting networkd</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Ubuntu 20.04&lt;/strong&gt; 的网络配置文件位于 &lt;strong&gt;/etc/netplan/00-installer-config.yaml&lt;/strong&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table</summary>
      
    
    
    
    
    <category term="ubuntu" scheme="http://divinerapier.github.io/tags/ubuntu/"/>
    
    <category term="networks" scheme="http://divinerapier.github.io/tags/networks/"/>
    
  </entry>
  
  <entry>
    <title>Docker 中无法找到命令 configure</title>
    <link href="http://divinerapier.github.io/2020/10/18/command-configure-not-found-in-docker/"/>
    <id>http://divinerapier.github.io/2020/10/18/command-configure-not-found-in-docker/</id>
    <published>2020-10-18T13:02:27.000Z</published>
    <updated>2020-10-18T13:25:56.340Z</updated>
    
    <content type="html"><![CDATA[<p>通过进入基于 <code>ubuntu:20.04</code> 镜像运行的容器中安装 <strong>openmpi</strong> 的一系列指令得到了如下 <strong>dockerfile</strong> 片段:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> wget https://download.open-mpi.org/release/open-mpi/v4.0/openmpi-4.0.5.tar.gz</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> tar xzf openmpi-4.0.5.tar.gz -C /tmp</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> /tmp/openmpi-4.0.5</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ./configure --with-threads=posix --<span class="built_in">enable</span>-mpi-thread-multiple</span></span><br></pre></td></tr></table></figure><p>以上命令可以在容器中逐条执行，但却在构建镜像时失败:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh: 1: ./configure: not found</span><br></pre></td></tr></table></figure><p>提示 <strong>configure</strong> 不存在。</p><p>修复办法是将 <strong>configure</strong> 命令与前一条命令合并:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> wget https://download.open-mpi.org/release/open-mpi/v4.0/openmpi-4.0.5.tar.gz</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> tar xzf openmpi-4.0.5.tar.gz -C /tmp</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> /tmp/openmpi-4.0.5 \</span></span><br><span class="line"><span class="bash">  &amp;&amp; ./configure --with-threads=posix --<span class="built_in">enable</span>-mpi-thread-multiple \</span></span><br><span class="line"><span class="bash">  &amp;&amp; make -j \</span></span><br><span class="line"><span class="bash">  &amp;&amp; make -j install</span></span><br></pre></td></tr></table></figure><p>推测原因: <strong>docker</strong> 镜像的每一层基于不同的 <strong>workdir</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;通过进入基于 &lt;code&gt;ubuntu:20.04&lt;/code&gt; 镜像运行的容器中安装 &lt;strong&gt;openmpi&lt;/strong&gt; 的一系列指令得到了如下 &lt;strong&gt;dockerfile&lt;/strong&gt; 片段:&lt;/p&gt;
&lt;figure class=&quot;highl</summary>
      
    
    
    
    
    <category term="docker" scheme="http://divinerapier.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>GPU 101 - Architecture</title>
    <link href="http://divinerapier.github.io/2020/10/15/GPU-101-Architecture/"/>
    <id>http://divinerapier.github.io/2020/10/15/GPU-101-Architecture/</id>
    <published>2020-10-15T11:50:58.000Z</published>
    <updated>2020-10-15T12:42:54.195Z</updated>
    
    <content type="html"><![CDATA[<p><strong>图形处理器单元(GPU)</strong> 主要是指运行高度图形化应用时使用的硬件设备，比如 <strong>3D建模软件</strong> 或 <strong>VDI基础设施</strong>。在消费市场上，GPU多用于加速游戏图形。如今，GPGPU(General Purpose GPU) 是现代高性能计算 (HPC) 场景中加速计算的普遍硬件选择。</p><p>会用到 GPU 的领域除了我们熟悉的 HPC，比如会用到图像识别的机器学习方向，也常用在医疗、保险和金融行业相关的垂直领域中使用的 <a href="https://www.w3.org/TR/tabular-data-model/" target="_blank" rel="noopener">表格数据 (Tabular Data)</a> 的计算。</p><p>因此，就引出一个问题: 为什么需要使用 GPU 而不是 CPU?</p><h2 id="延迟与吞吐量"><a href="#延迟与吞吐量" class="headerlink" title="延迟与吞吐量"></a>延迟与吞吐量</h2><p>首先，来看看 CPU 和 GPU 的主要区别。</p><p>CPU 对速度与延迟方面进行了优化，在保持操作之间快速切换的能力的前提下，以尽可能低的延迟完成任务。它的本质就是以序列化的方式处理任务。</p><p>GPU 对吞吐量方面进行了优化，它允许一次推尽可能多的任务到内部，并通过并行方式处理每个任务。</p><p>下面的示例图显示了 CPU 和 GPU <strong>核心</strong> 的数量。显而易见地，GPU 具有更多的核心来处理一个任务。</p><p><img src="/images/GPU-101-Architecture/01-cpu-vs-gpu-cores.png" alt="cpu-vs-gpu-cores"></p><h2 id="异同点"><a href="#异同点" class="headerlink" title="异同点"></a>异同点</h2><p>然而，这不仅仅是核心数量的问题。而当我们说到NVIDIA GPU中的核心时，我们指的是由ALU（算术逻辑单元）组成的CUDA核心。不同厂商的术语可能会有所不同。</p><p>从CPU和GPU的整体架构来看，我们可以看到两者之间有很多相似之处。两者都使用了缓存层、内存控制器和全局内存的内存构造。对现代CPU架构的高层概述表明，它都是通过使用重要的缓存内存层来实现低延迟的内存访问。让我们先看一张图，它显示了一个通用的、以内存为中心的现代CPU封装（注意：精确的布局强烈地取决于供应商/型号）。</p><p><img src="/images/GPU-101-Architecture/02-cpu-hl-architecture.png" alt="cpu-hl-architecture"></p><p>一个CPU包由核心组成，包含独立的数据层和指令层-1缓存，由层-2缓存支持。第3层高速缓存，也就是最后一层高速缓存，由多个核心共享。如果数据没有驻留在缓存层中，它将从全局DDR-4内存中获取数据。每个CPU的核心数量可以达到28个或32个，根据品牌和型号的不同，在Turbo模式下可以运行到2.5GHz或3.8GHz。缓存大小范围为每个核心最高2MB二级缓存。</p><h2 id="探索GPU架构"><a href="#探索GPU架构" class="headerlink" title="探索GPU架构"></a>探索GPU架构</h2><p>如果我们检查GPU的高层架构概述（同样，强烈依赖make/model），看起来GPU的本质就是把可用的核心投入工作，它不太注重低延迟的缓存内存访问。</p><p><img src="/images/GPU-101-Architecture/03-gpu-architecture.png" alt="gpu-architecture"></p><p>单个GPU设备由多个处理器集群（PC）组成，其中包含多个流式多处理器（SM）。每个SM容纳一个第1层指令缓存层与其相关的核心。通常情况下，一个SM在从全局GDDR-5内存中提取数据之前，会使用一个专用的第1层缓存和一个共享的第2层缓存。其架构对内存延迟的容忍度很高。</p><p>与CPU相比，GPU工作的内存缓存层数较少，而且相对较小。原因是GPU有更多的晶体管用于计算，这意味着它不太在乎从内存中检索数据所需的时间。只要GPU手头有足够的计算量，潜在的内存访问 “延迟 “就会被掩盖，使其保持忙碌。</p><blockquote><p>A GPU is optimized for data parallel throughput computations.</p></blockquote><p>从核心数量来看，它很快就能让你看到它在并行方面的可能性。 当检查当前NVIDIA的旗舰产品Tesla V100时，一台设备包含80个SM，每个SM包含64个核心，总共有5120个核心！任务不是安排给单个核心，而是安排给处理器集群和SM。任务不是安排给单个核心，而是安排给处理器集群和SM。这就是它能够并行处理的原因。现在把这个强大的硬件设备和编程框架结合起来，应用就可以充分发挥GPU的计算能力。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://nielshagoort.com/2019/03/12/exploring-the-gpu-architecture/" target="_blank" rel="noopener">Exploring the GPU Architecture</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;图形处理器单元(GPU)&lt;/strong&gt; 主要是指运行高度图形化应用时使用的硬件设备，比如 &lt;strong&gt;3D建模软件&lt;/strong&gt; 或 &lt;strong&gt;VDI基础设施&lt;/strong&gt;。在消费市场上，GPU多用于加速游戏图形。如今，GPGPU(Ge</summary>
      
    
    
    
    
    <category term="gpu" scheme="http://divinerapier.github.io/tags/gpu/"/>
    
  </entry>
  
  <entry>
    <title>WSL2 中无法连接 Docker 服务</title>
    <link href="http://divinerapier.github.io/2020/10/15/cannot-connect-to-docker-daemon-on-wsl2/"/>
    <id>http://divinerapier.github.io/2020/10/15/cannot-connect-to-docker-daemon-on-wsl2/</id>
    <published>2020-10-15T09:21:20.000Z</published>
    <updated>2020-10-15T09:31:37.955Z</updated>
    
    <content type="html"><![CDATA[<p>在 <strong>WSL2</strong> 环境中使用 <strong>Docker</strong> 遇到错误:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</span><br></pre></td></tr></table></figure><p>可以通过如下操作解决:</p><ol><li><p>在 <strong>App and features</strong> 中卸载 <strong>Docker</strong> 程序</p></li><li><p>删除如下目录</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Docker</span><br><span class="line">C:\ProgramData\DockerDesktop</span><br><span class="line">C:\Users\[USERNAME]\.docker</span><br><span class="line">C:\Users\[USERNAME]\AppData\Local\Docker</span><br><span class="line">C:\Users\[USERNAME]\AppData\Roaming\Docker</span><br><span class="line">C:\Users\[USERNAME]\AppData\Roaming\Docker Desktop</span><br></pre></td></tr></table></figure></li><li><p>下载最 <a href="https://docs.docker.com/docker-for-windows/edge-release-notes/" target="_blank" rel="noopener">新版本 <strong>Docker</strong></a></p></li><li><p>启动 <strong>Docker</strong></p></li></ol><p>到此为止，问题应该已经被解决了(至少我解决了)。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://codesthq.com/painless-way-to-wsl-2-with-docker/" target="_blank" rel="noopener">Painless way to WSL 2 with Docker</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 &lt;strong&gt;WSL2&lt;/strong&gt; 环境中使用 &lt;strong&gt;Docker&lt;/strong&gt; 遇到错误:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c</summary>
      
    
    
    
    
    <category term="windows" scheme="http://divinerapier.github.io/tags/windows/"/>
    
    <category term="wsl2" scheme="http://divinerapier.github.io/tags/wsl2/"/>
    
    <category term="docker" scheme="http://divinerapier.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>初识 MPI</title>
    <link href="http://divinerapier.github.io/2020/10/11/started-with-mpi/"/>
    <id>http://divinerapier.github.io/2020/10/11/started-with-mpi/</id>
    <published>2020-10-11T04:10:37.000Z</published>
    <updated>2020-10-11T13:08:47.240Z</updated>
    
    <content type="html"><![CDATA[<h2 id="消息传递模型"><a href="#消息传递模型" class="headerlink" title="消息传递模型"></a>消息传递模型</h2><p><strong>消息传递模型(Message Passing Model)</strong> 指程序通过在进程间传递消息（消息可以理解成带有一些信息和数据的一个数据结构）来完成某些任务。在实践中，基于此模型，很容易开发 <strong>并发程序</strong>。</p><p>举例来说:</p><ol><li>主进程(manager process) 可以通过向从进程(worker process) 发送一个描述工作的消息的方式，将工作分配给从进程。</li><li>一个并发的排序程序可以在当前进程中对当前进程可见的(我们称作本地的，locally) 数据进行排序，然后把排好序的数据发送到邻居进程上面来进行合并的操作。</li></ol><p>几乎所有的并行程序可以使用消息传递模型来描述。</p><p>之后，业界统一制定了一套消息传递模型的接口标准，即 <strong>Message Passing Interface —— MPI</strong>。</p><h2 id="MPI-基础概念"><a href="#MPI-基础概念" class="headerlink" title="MPI 基础概念"></a>MPI 基础概念</h2><h3 id="Communicator"><a href="#Communicator" class="headerlink" title="Communicator"></a>Communicator</h3><p><strong>通讯器(communicator)</strong> 定义了一组能够互相发消息的进程。</p><h3 id="Rank"><a href="#Rank" class="headerlink" title="Rank"></a>Rank</h3><p>在 <strong>通讯器(communicator)</strong> 中，每个进程会被分配一个序号，称作 <strong>秩(rank)</strong>，进程间显性地通过指定 <strong>rank</strong> 来进行通信。</p><h3 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h3><p>不同进程之间发送、接收操作是通信的基础。</p><p>作为发送者时，进程可以通过指定另一个进程的 <strong>rank</strong> 和一个独一无二的 <strong>消息标签(tag)</strong> 来发送消息给另一个进程。</p><p>作为接受者时，进程可以发送一个 <strong>接收特定标签标记的消息的请求 (或者忽略标签，接收任何消息)</strong>，然后依次处理接收到的数据。</p><h3 id="Point-to-Point-Communications"><a href="#Point-to-Point-Communications" class="headerlink" title="Point-to-Point Communications"></a>Point-to-Point Communications</h3><p>一个发送者，一个接受者的通信被称作 <strong>点对点(point-to-point) 通信</strong>。</p><h3 id="Collective-Communications"><a href="#Collective-Communications" class="headerlink" title="Collective Communications"></a>Collective Communications</h3><p>在很多情况下，某个进程可能需要跟所有其他进程通信。比如主进程想发一个广播给所有的从进程。在这种情况下，如果通过写代码的方式来完成所有的发送和接收过程会很麻烦。并且，事实上，这种方式往往也不会以最佳方式使用网络。MPI 可以处理各种各样的这些涉及所有进程的 <strong>集体(Collective)通信</strong> 类型。</p><h2 id="使用-MPI"><a href="#使用-MPI" class="headerlink" title="使用 MPI"></a>使用 MPI</h2><p><strong>MPI</strong> 只是一套接口标准，无法直接使用。对此不必担心，业内已经存在很多符合标准的实现。其中 <strong>OpenMPI</strong> 就是最受欢迎的实现之一。因此，之后的内容基于 <strong>OpenMPI</strong> 展开。</p><h3 id="安装-OpenMPI"><a href="#安装-OpenMPI" class="headerlink" title="安装 OpenMPI"></a>安装 OpenMPI</h3><p>从 <a href="https://www.open-mpi.org/software/ompi/v4.0/" target="_blank" rel="noopener">这里</a> 可以找到最新的版本，本文基于版本 <a href="https://download.open-mpi.org/release/open-mpi/v4.0/openmpi-4.0.5.tar.gz" target="_blank" rel="noopener">4.0.5</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># download package</span></span><br><span class="line">$ wget https://download.open-mpi.org/release/open-mpi/v4.0/openmpi-4.0.5.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># extract files</span></span><br><span class="line">$ tar xzf openmpi-4.0.5.tar.gz</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> openmpi-4.0.5</span><br><span class="line"></span><br><span class="line"><span class="comment"># configure project</span></span><br><span class="line">$ mkdir -p build; ./configure --prefix=$(<span class="built_in">pwd</span>)/build</span><br><span class="line"></span><br><span class="line"><span class="comment"># build</span></span><br><span class="line">$ make -j; make -j install</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://mpitutorial.com/tutorials/mpi-introduction/" target="_blank" rel="noopener">MPI Tutorial Introduction</a></li><li><a href="https://www.open-mpi.org/faq/" target="_blank" rel="noopener">OpenMPI FAQ</a></li><li><a href="https://www.mpi-forum.org/" target="_blank" rel="noopener">MPI Forum</a></li><li><a href="https://www.citutor.org//browse.php" target="_blank" rel="noopener">The “Introduction to MPI” and “Intermediate MPI” tutorials</a></li><li><a href="http://hpc.mediawiki.hull.ac.uk/Applications/OpenMPI" target="_blank" rel="noopener">UNIVERSITY OF HULL HPC: OpenMPI</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;消息传递模型&quot;&gt;&lt;a href=&quot;#消息传递模型&quot; class=&quot;headerlink&quot; title=&quot;消息传递模型&quot;&gt;&lt;/a&gt;消息传递模型&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;消息传递模型(Message Passing Model)&lt;/strong&gt; 指程序通过在进</summary>
      
    
    
    
    
    <category term="mpi" scheme="http://divinerapier.github.io/tags/mpi/"/>
    
  </entry>
  
  <entry>
    <title>训练系统相关读物</title>
    <link href="http://divinerapier.github.io/2020/10/11/readings-about-training-system/"/>
    <id>http://divinerapier.github.io/2020/10/11/readings-about-training-system/</id>
    <published>2020-10-11T03:44:32.000Z</published>
    <updated>2020-10-11T06:44:19.060Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://images.nvidia.com/events/sc15/pdfs/NCCL-Woolley.pdf" target="_blank" rel="noopener">NCCL: ACCELERATED MULTI-GPU COLLECTIVE COMMUNICATIONS</a></li><li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.95.2490&rep=rep1&type=pdf" target="_blank" rel="noopener">Message Passing, Remote Procedure Calls and Distributed Shared Memory as Communication Paradigms for Distributed Systems</a></li><li><a href="https://zhuanlan.zhihu.com/p/50116885" target="_blank" rel="noopener">分布式训练的方案和效率对比</a></li><li><a href="http://gaocegege.com/Blog/mpi-1" target="_blank" rel="noopener">MPI，OpenMPI 与深度学习</a></li><li><a href="https://mpitutorial.com/tutorials/mpi-introduction/zh_cn/" target="_blank" rel="noopener">MPI 教程介绍</a></li><li><a href="https://www.mpi-forum.org/" target="_blank" rel="noopener">MPI Forum</a></li><li><a href="https://zhuanlan.zhihu.com/p/149771261" target="_blank" rel="noopener">2020 Rethinking GPU 集群上的分布式训练</a></li><li><a href="https://zhuanlan.zhihu.com/p/40578792" target="_blank" rel="noopener">Horovod-基于TensorFlow分布式深度学习框架</a></li><li><a href="https://github.com/horovod/horovod" target="_blank" rel="noopener">Github: Horovod</a></li><li><a href="https://kubernetes.io/docs/tasks/manage-gpus/scheduling-gpus/" target="_blank" rel="noopener">Schedule GPUs</a></li><li><a href="https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/" target="_blank" rel="noopener">Device Plugins</a></li><li><a href="https://towardsdatascience.com/distributed-deep-learning-training-with-horovod-on-kubernetes-6b28ac1d6b5d" target="_blank" rel="noopener">Distributed Deep Learning Training with Horovod on Kubernetes</a></li><li><a href="https://developer.nvidia.com/kubernetes-gpu" target="_blank" rel="noopener">Kubernetes on NVIDIA GPUs</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://images.nvidia.com/events/sc15/pdfs/NCCL-Woolley.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NCCL: ACCELERATED MULTI-GPU CO</summary>
      
    
    
    
    
    <category term="gpu" scheme="http://divinerapier.github.io/tags/gpu/"/>
    
    <category term="kubernetes" scheme="http://divinerapier.github.io/tags/kubernetes/"/>
    
    <category term="mpi" scheme="http://divinerapier.github.io/tags/mpi/"/>
    
    <category term="rdma" scheme="http://divinerapier.github.io/tags/rdma/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 存储卷</title>
    <link href="http://divinerapier.github.io/2020/10/07/kubernetes-volumes/"/>
    <id>http://divinerapier.github.io/2020/10/07/kubernetes-volumes/</id>
    <published>2020-10-07T09:37:14.000Z</published>
    <updated>2020-10-12T05:54:15.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在 <strong>Docker</strong> 中，<strong><a href="https://docs.docker.com/storage/" target="_blank" rel="noopener">Volume</a></strong> 概念表示磁盘上或者另外一个容器内的一个目录。 直到最近，Docker 才支持对基于本地磁盘的 Volume 的生存期进行管理。 虽然 Docker 现在也能提供 Volume 驱动程序，但是目前功能还非常有限 （例如，截至 Docker 1.7，每个容器只允许有一个 Volume 驱动程序，并且无法将参数传递给 Volume）。</p><p>而在 <strong>Kubernetes</strong> 中，<strong>Volume</strong> 具有明确的生命周期——与其所属 <strong>Pod</strong> 相同。 因此，<strong>Volume 比 Pod 中运行的任何容器的存活期都长</strong>，在容器重新启动时数据也会得到保留。 当然，<strong>当一个 Pod 不再存在时，卷也将不再存在</strong>。 更重要的是，<strong>Kubernetes 可以支持许多类型的卷，Pod 也能同时使用任意数量的卷</strong>。</p><p><strong>Volume</strong> 的核心是包含一些数据的目录，Pod 中的容器可以访问该目录。 特定的卷类型可以决定这个目录是如何形成的，并能决定它支持何种介质，以及目录中存放什么内容。</p><p>使用 <strong>Volume</strong> 时, Pod 声明中需要提供卷的类型 (<strong>.spec.volumes</strong> 字段) 和 <strong>Volume</strong> 挂载的位置 (<strong>.spec.containers.volumeMounts</strong> 字段).</p><p>容器中的进程能看到由它们的 Docker 镜像和卷组成的文件系统视图。 <a href="https://docs.docker.com/userguide/dockerimages/" target="_blank" rel="noopener">Docker 镜像</a> 位于文件系统层次结构的根部，并且任何 Volume 都挂载在镜像内的指定路径上。 卷不能挂载到其他卷，也不能与其他卷有硬链接。 Pod 中的每个容器必须独立地指定每个卷的挂载位置(<strong>Volumes</strong> 之间的挂载点应该相互独立)。</p><h2 id="Volume-的类型"><a href="#Volume-的类型" class="headerlink" title="Volume 的类型"></a>Volume 的类型</h2><p>Kubernetes 支持下列类型的卷:</p><ul><li><a href="#Cephfs">cephfs</a></li><li><a href="#ConfigMap">configMap</a></li><li><a href="#CSI">csi</a></li><li><a href="#DownwardAPI">downwardAPI</a></li><li><a href="#EmptyDir">emptyDir</a></li><li><a href="#HostPath">hostPath</a></li><li><a href="#Local">local</a></li><li><a href="#Nfs">nfs</a></li><li><a href="#PersistentVolumeClaim">persistentVolumeClaim</a></li><li><a href="#Projected">projected</a></li><li><a href="#Secret">secret</a></li></ul><h3 id="Cephfs"><a href="#Cephfs" class="headerlink" title="Cephfs"></a>Cephfs</h3><p><strong>cephfs</strong> 允许用户将现存的 <strong>CephFS</strong> 卷挂载到 <strong>Pod</strong> 中。 与 <strong><a href="#EmptyDir">emptyDir</a></strong> 不同的是，<strong>emptyDir</strong> 会在删除 Pod 的同时<strong>一并被删除</strong>，<strong>cephfs</strong> 卷的内容在删除 Pod 时会被保留，卷只是被卸载掉了。 这意味着 <strong>CephFS 卷可以被预先填充数据，并且这些数据可以在 Pod 之间”传递”</strong>。CephFS 卷可同时被多个写者挂载。</p><blockquote><p>注意： 在您使用 Ceph 卷之前，您的 Ceph 服务器必须正常运行并且要使用的 share 被导出（exported）。</p></blockquote><p>更多信息请参考 <a href="https://github.com/kubernetes/examples/tree/master/volumes/cephfs/" target="_blank" rel="noopener">CephFS 示例</a>。</p><h3 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h3><p><strong>configMap</strong> 资源提供了向 Pod <strong>注入配置数据</strong>的方法。 ConfigMap 对象中存储的数据可以被 configMap 类型的卷引用，然后被应用到 Pod 中运行的容器化应用。</p><p>当引用 configMap 对象时，你可以简单的在 Volume 中通过它名称来引用。 还可以自定义 ConfigMap 中特定条目所要使用的路径。 例如，要将名为 log-config 的 ConfigMap 挂载到名为 configmap-pod 的 Pod 中，您可以使用下面的 YAML:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">configmap-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-vol</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/config</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-vol</span></span><br><span class="line">      <span class="attr">configMap:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">log-config</span></span><br><span class="line">        <span class="attr">items:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">log_level</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">log_level</span></span><br></pre></td></tr></table></figure><h3 id="CSI"><a href="#CSI" class="headerlink" title="CSI"></a>CSI</h3><p><a href="https://github.com/container-storage-interface/spec/blob/master/spec.md" target="_blank" rel="noopener">容器存储接口 (CSI)</a> 为容器编排系统（如 Kubernetes）定义标准接口，以将任意存储系统暴露给它们的容器工作负载。</p><p>更多详情请阅读 <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md" target="_blank" rel="noopener">CSI 设计方案</a>。</p><p>CSI 的支持在 Kubernetes v1.9 中作为 alpha 特性引入，在 Kubernetes v1.10 中转为 beta 特性，并在 Kubernetes v1.13 正式 GA。</p><blockquote><p><strong>说明:</strong> CSI驱动程序可能并非在所有Kubernetes版本中都兼容。 请查看特定CSI驱动程序的文档，以获取每个 Kubernetes 版本所支持的部署步骤以及兼容性列表。</p></blockquote><p>一旦在 <strong>Kubernetes</strong> 集群上部署了 CSI 兼容卷驱动程序，用户就可以使用 <strong>csi</strong> 作为卷类型来关联、挂载 <strong>CSI Driver</strong> 暴露出来的卷。</p><p>允许如下三种方式，在 Pod 中使用 <strong>csi</strong> 类型的卷:</p><ul><li>通过 <strong>PersistentVolumeClaim</strong></li><li>通过 <strong><a href="https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes" target="_blank" rel="noopener">Generic ephemeral volumes</a></strong></li><li>通过 <strong><a href="https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#csi-ephemeral-volumes" target="_blank" rel="noopener">CSI ephemeral volumes</a></strong></li></ul><p>存储管理员可以使用以下字段来配置 CSI 持久卷(CSI persistent volume):</p><ul><li><p><strong>driver</strong>：指定要使用的卷 驱动程序(CSI Driver) 名称的字符串值。 这个值必须与 <strong>CSI Driver</strong> 的 <strong><a href="(https://github.com/container-storage-interface/spec/blob/master/spec.md#getplugininfo)">GetPluginInfoResponse</a></strong> 的 <strong>name</strong> 字段相同。 <strong>Kubernetes</strong> 使用所给的值来标识要调用的 <strong>CSI Driver</strong>；<strong>CSI Driver</strong> 也使用该值来<strong>辨识哪些 PV 对象属于该 CSI Driver</strong>。</p></li><li><p><strong>volumeHandle</strong>：唯一标识卷的字符串值。 该值必须与 <strong>CSI Driver</strong> 的 <strong><a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#createvolume" target="_blank" rel="noopener">CreateVolumeResponse</a></strong> 的 <strong>volume.id</strong> 字段相同。 在所有对 <strong>CSI Driver</strong> 的调用中，引用该 <strong>Volume</strong> 时都使用此值作为 <strong>volume_id</strong> 参数。</p></li><li><p><strong>readOnly</strong>：一个可选的布尔值，指示通过 <strong>ControllerPublished</strong> 关联该卷时是否设置该卷为只读。 <strong>默认值是 false</strong>。 该值通过 <strong><a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#controllerpublishvolume" target="_blank" rel="noopener">ControllerPublishVolumeRequest</a></strong> 中的 <strong>readonly</strong> 字段传递给 <strong>CSI Driver</strong>。</p></li><li><p><strong>fsType</strong>：如果 <strong>PV</strong> 的 <strong>VolumeMode</strong> 为 <strong>Filesystem</strong>，则该字段指定挂载卷时应该使用的文件系统。 倘若 <strong>Volume</strong> 尚未完成格式化，且支持格式化，则该值将被用于格式化。 可以通过 <strong><a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#controllerpublishvolume" target="_blank" rel="noopener">ControllerPublishVolumeRequest</a></strong>、<strong><a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#nodestagevolume" target="_blank" rel="noopener">NodeStageVolumeRequest</a></strong> 和 <strong><a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#nodepublishvolume" target="_blank" rel="noopener">NodePublishVolumeRequest</a></strong> 的 <strong>volume_capability</strong> 字段将该值传递给 <strong>CSI Driver</strong>。</p></li><li><p><strong>volumeAttributes</strong>：一个 <strong>map[string]string</strong> 类型的映射表，用来设置 <strong>Volume</strong> 的静态属性。 该映射表必须与 <strong>CSI Driver</strong> 返回的 <strong><a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#createvolume" target="_blank" rel="noopener">CreateVolumeResponse</a></strong> 中的 volume.attributes 字段的映射相对应。 该映射表通过 <strong><a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#controllerpublishvolume" target="_blank" rel="noopener">ControllerPublishVolumeRequest</a></strong>、<strong><a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#nodestagevolume" target="_blank" rel="noopener">NodeStageVolumeRequest</a></strong>、和 <strong><a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#nodepublishvolume" target="_blank" rel="noopener">NodePublishVolumeRequest</a></strong> 中的 <strong>volume_attributes</strong> 字段传递给 <strong>CSI Driver</strong>。</p><ul><li><strong>注意</strong>: 在 <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md" target="_blank" rel="noopener">spec</a> 中只看到了 <strong>volume_context</strong>，并没有 <strong>attributes</strong>，根据注释与数据类型来分析，或许是指这个字段？</li></ul></li><li><p><strong>controllerPublishSecretRef</strong>：对包含敏感信息的 secret 对象的引用；该敏感信息会被传递给 <strong>CSI Driver</strong> 来完成 <strong><a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#controllerpublishvolume" target="_blank" rel="noopener">ControllerPublishVolume</a></strong> 和 <strong><a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#controllerunpublishvolume" target="_blank" rel="noopener">ControllerUnpublishVolume</a></strong> 调用。 该字段为可选字段；为空表示不需要 secret。 如果 secret 对象包含多个 secret，则所有的 secret 都会被传递。</p></li><li><p><strong>nodeStageSecretRef</strong>：对包含敏感信息的 secret 对象的引用，以传递给 <strong>CSI Driver</strong> 来完成 <strong><a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#nodestagevolume" target="_blank" rel="noopener">NodeStageVolume</a></strong> 调用。 该字段为可选字段；为空表示不需要 secret。 如果 secret 对象包含多个 secret，则所有的 secret 都会被传递。</p></li><li><p><strong>nodePublishSecretRef</strong>：对包含敏感信息的 secret 对象的引用，以传递给 <strong>CSI Driver</strong> 来完成 <strong><a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#nodepublishvolume" target="_blank" rel="noopener">NodePublishVolume</a></strong> 调用。 该字段为可选字段；为空表示不需要 secret。 如果 secret 对象包含多个 secret，则所有的 secret 都会被传递。</p></li></ul><h3 id="DownwardAPI"><a href="#DownwardAPI" class="headerlink" title="DownwardAPI"></a>DownwardAPI</h3><p><strong>downwardAPI</strong> 类型的 <strong>Volume</strong> 被用于使 <strong>downward API</strong> 数据对应用程序可见。其表现形式为，挂载一个目录，并将请求的数据写入到纯文本文件中。</p><h3 id="EmptyDir"><a href="#EmptyDir" class="headerlink" title="EmptyDir"></a>EmptyDir</h3><p>当 <strong>Pod</strong> 被指定到某个节点上时，首先创建的是一个 <strong>emptyDir</strong> 类型的 <strong>Volume</strong>，并且只要 <strong>Pod</strong> 保持在该节点上运行，<strong>Volume</strong> 就一直存在。正如名字所说的那样，<strong>Volume</strong> 的初始状态为空。虽然 <strong>Pod</strong> 中的容器挂载 <strong>emptyDir</strong> 类型 <strong>Volume</strong> 的路径可能不尽相同，但这都不重要，重要的是，这些容器都可以读写 <strong>emptyDir</strong> 类型 <strong>Volume</strong> 中的相同的文件。 无论因何种原因，只要 <strong>Pod</strong> 从节点上被删除，<strong>emptyDir</strong> 类型的 <strong>Volume</strong> 中的数据也会被永久删除。</p><blockquote><p><strong>说明</strong>: 容器崩溃并不会导致 <strong>Pod</strong> 从节点上被移除，因此容器崩溃时 <strong>emptyDir</strong> 类型 <strong>Volume</strong> 中的数据是安全的。</p></blockquote><p>有如下需求可以考虑使用 <strong>emptyDir</strong> 类型 <strong>Volume</strong>:</p><ul><li>缓存空间，例如基于磁盘的归并排序。</li><li>为耗时较长的计算任务提供检查点，以便任务能方便地从崩溃前状态恢复执行。</li><li>在 Web 服务器容器服务数据时，保存内容管理器容器获取的文件。</li></ul><p>默认情况下， <strong>emptyDir volume</strong> 所使用的的实际存储介质由节点使用何种存储介质决定: 可以是 <strong>HDD</strong> 或 <strong>SSD</strong> 或 <strong>NFS</strong> 等。但是，可以令 <strong>emptyDir.medium = Memory</strong> 使 <strong>Kubernetes</strong> 安装 <strong>tmpfs</strong>。但需要考虑到，<strong>tmpfs</strong> 的优势与劣势都很突出:</p><ul><li>优势: 基于 <strong>RAM</strong> 的文件系统，速度非常快</li><li>劣势: 随节点重启被清除，且写入的所有文件都会计入容器的内存消耗，受容器内存限制约束</li></ul><h4 id="EmptyDir-示例"><a href="#EmptyDir-示例" class="headerlink" title="EmptyDir 示例"></a>EmptyDir 示例</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-pd</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">k8s.gcr.io/test-webserver</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">test-container</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/cache</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">cache-volume</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cache-volume</span></span><br><span class="line">    <span class="attr">emptyDir:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="HostPath"><a href="#HostPath" class="headerlink" title="HostPath"></a>HostPath</h3><p>A hostPath volume mounts a file or directory from the host node’s filesystem into your Pod. This is not something that most Pods will need, but it offers a powerful escape hatch for some applications.</p><p><strong>hostPath</strong> 类型的 <strong>Volume</strong> 会将宿主机节点的路径挂载到</p><p>For example, some uses for a hostPath are:</p><p>running a Container that needs access to Docker internals; use a hostPath of /var/lib/docker<br>running cAdvisor in a Container; use a hostPath of /sys<br>allowing a Pod to specify whether a given hostPath should exist prior to the Pod running, whether it should be created, and what it should exist as<br>In addition to the required path property, user can optionally specify a type for a hostPath volume.</p><p>The supported values for field type are:</p><p>Value    Behavior        Empty string (default) is for backward compatibility, which means that no checks will be performed before mounting the hostPath volume.    DirectoryOrCreate    If nothing exists at the given path, an empty directory will be created there as needed with permission set to 0755, having the same group and ownership with Kubelet.    Directory    A directory must exist at the given path    FileOrCreate    If nothing exists at the given path, an empty file will be created there as needed with permission set to 0644, having the same group and ownership with Kubelet.    File    A file must exist at the given path    Socket    A UNIX socket must exist at the given path    CharDevice    A character device must exist at the given path    BlockDevice    A block device must exist at the given path<br>Watch out when using this type of volume, because:</p><p>Pods with identical configuration (such as created from a podTemplate) may behave differently on different nodes due to different files on the nodes<br>when Kubernetes adds resource-aware scheduling, as is planned, it will not be able to account for resources used by a hostPath<br>the files or directories created on the underlying hosts are only writable by root. You either need to run your process as root in a privileged Container or modify the file permissions on the host to be able to write to a hostPath volume</p><h3 id="Local"><a href="#Local" class="headerlink" title="Local"></a>Local</h3><h3 id="Nfs"><a href="#Nfs" class="headerlink" title="Nfs"></a>Nfs</h3><h3 id="PersistentVolumeClaim"><a href="#PersistentVolumeClaim" class="headerlink" title="PersistentVolumeClaim"></a>PersistentVolumeClaim</h3><h3 id="Projected"><a href="#Projected" class="headerlink" title="Projected"></a>Projected</h3><h3 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h3><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://kubernetes.io/docs/concepts/storage/volumes/" target="_blank" rel="noopener">Volumes</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在 &lt;strong&gt;Docker&lt;/strong&gt; 中，&lt;strong&gt;&lt;a href=&quot;https://docs.docker.com/s</summary>
      
    
    
    
    
    <category term="kubernetes" scheme="http://divinerapier.github.io/tags/kubernetes/"/>
    
    <category term="storage" scheme="http://divinerapier.github.io/tags/storage/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 持久卷</title>
    <link href="http://divinerapier.github.io/2020/10/07/kubernetes-persistent-volume/"/>
    <id>http://divinerapier.github.io/2020/10/07/kubernetes-persistent-volume/</id>
    <published>2020-10-07T09:30:27.000Z</published>
    <updated>2020-10-11T05:17:14.310Z</updated>
    
    
    
    
    
    <category term="kubernetes" scheme="http://divinerapier.github.io/tags/kubernetes/"/>
    
    <category term="volume" scheme="http://divinerapier.github.io/tags/volume/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 控制器</title>
    <link href="http://divinerapier.github.io/2020/10/06/kubernetes-controllers/"/>
    <id>http://divinerapier.github.io/2020/10/06/kubernetes-controllers/</id>
    <published>2020-10-06T05:13:35.000Z</published>
    <updated>2020-10-09T07:58:21.747Z</updated>
    
    <content type="html"><![CDATA[<p>在机器人技术和自动化领域，控制回路（Control Loop）是一个非终止回路，用于调节系统状态。</p><p>这是一个控制环的例子：房间里的温度自动调节器。</p><p>当你设置了温度，告诉了温度自动调节器你的期望状态（Desired State）。 房间的实际温度是当前状态（Current State）。 通过对设备的开关控制，温度自动调节器让其当前状态接近期望状态。</p><p>控制器通过 <a href="https://kubernetes.io/docs/reference/generated/kube-apiserver/" target="_blank" rel="noopener">apiserver</a> 监控集群的公共状态，并致力于将当前状态转变为期望的状态。</p><h2 id="控制器模式"><a href="#控制器模式" class="headerlink" title="控制器模式"></a>控制器模式</h2><p>一个控制器至少追踪一种类型的 Kubernetes 资源。这些 <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/" target="_blank" rel="noopener">对象</a> 有一个代表期望状态的 spec 字段。 该资源的控制器负责确保其当前状态接近期望状态。</p><p>控制器可能会自行执行操作；在 Kubernetes 中更常见的是一个控制器会发送信息给 <a href="https://kubernetes.io/docs/reference/generated/kube-apiserver/" target="_blank" rel="noopener">API 服务器</a>，这会有副作用。 具体可参看后文的例子。</p><h3 id="通过-API-服务器来控制"><a href="#通过-API-服务器来控制" class="headerlink" title="通过 API 服务器来控制"></a>通过 API 服务器来控制</h3><p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion" target="_blank" rel="noopener">Job</a> 控制器是一个 Kubernetes 内置控制器的例子。 内置控制器通过和集群 API 服务器交互来管理状态。</p><p>Job 是一种 Kubernetes 资源，它运行一个或者多个 Pod， 来执行一个任务然后停止。 （一旦被调度了，对 kubelet 来说 Pod 对象就会变成了期望状态的一部分）。</p><p>在集群中，当 Job 控制器拿到新任务时，它会保证一组 Node 节点上的 kubelet 可以运行正确数量的 Pod 来完成工作。 Job 控制器不会自己运行任何的 Pod 或者容器。Job 控制器是通知 API 服务器来创建或者移除 Pod。<a href="https://kubernetes.io/docs/reference/glossary/?all=true#term-control-plane" target="_blank" rel="noopener">控制面</a>中的其它组件 根据新的消息作出反应（调度并运行新 Pod）并且最终完成工作。</p><p>创建新 Job 后，所期望的状态就是完成这个 Job。Job 控制器会让 Job 的当前状态不断接近期望状态：创建为 Job 要完成工作所需要的 Pod，使 Job 的状态接近完成。</p><p>控制器也会更新配置对象。例如：一旦 Job 的工作完成了，Job 控制器会更新 Job 对象的状态为 Finished。</p><p>（这有点像温度自动调节器关闭了一个灯，以此来告诉你房间的温度现在到你设定的值了）。</p><h3 id="直接控制"><a href="#直接控制" class="headerlink" title="直接控制"></a>直接控制</h3><p>相比 Job 控制器，有些控制器需要对集群外的一些东西进行修改。</p><p>例如，如果你使用一个控制环来保证集群中有足够的<a href="https://kubernetes.io/docs/concepts/architecture/nodes/" target="_blank" rel="noopener">节点</a>，那么控制就需要当前集群外的一些服务在需要时创建新节点。</p><p>和外部状态交互的控制器从 API 服务器获取到它想要的状态，然后直接和外部系统进行通信并使当前状态更接近期望状态。</p><p>（实际上有一个控制器可以水平地扩展集群中的节点。请参阅 <a href="https://kubernetes.io/docs/tasks/administer-cluster/cluster-management/#cluster-autoscaling" target="_blank" rel="noopener">集群自动扩缩容</a>）。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>作为设计原则之一，Kubernetes 使用了很多控制器，每个控制器管理集群状态的一个特定方面。 最常见的一个特定的控制器使用一种类型的资源作为它的期望状态， 控制器管理控制另外一种类型的资源向它的期望状态演化。</p><p>使用简单的控制器而不是一组相互连接的单体控制回路是很有用的。 控制器会失败，所以 Kubernetes 的设计正是考虑到了这一点。</p><blockquote><p>说明：<br>可以有多个控制器来创建或者更新相同类型的对象。 在后台，Kubernetes 控制器确保它们只关心与其控制资源相关联的资源。</p><p>例如，你可以创建 Deployment 和 Job；它们都可以创建 Pod。 Job 控制器不会删除 Deployment 所创建的 Pod，因为有信息 （<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/" target="_blank" rel="noopener">标签</a>）让控制器可以区分这些 Pod。</p></blockquote><h2 id="运行控制器的方式"><a href="#运行控制器的方式" class="headerlink" title="运行控制器的方式"></a>运行控制器的方式</h2><p>Kubernetes 内置一组控制器，运行在 <a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager/" target="_blank" rel="noopener">kube-controller-manager</a> 内。 这些内置的控制器提供了重要的核心功能。</p><p>Deployment 控制器和 Job 控制器是 Kubernetes 内置控制器的典型例子。 Kubernetes 允许你运行一个稳定的控制平面，这样即使某些内置控制器失败了， 控制平面的其他部分会接替它们的工作。</p><p>你会遇到某些控制器运行在控制面之外，用以扩展 Kubernetes。 或者，如果你愿意，你也可以自己编写新控制器。 你可以以一组 Pod 来运行你的控制器，或者运行在 Kubernetes 之外。 最合适的方案取决于控制器所要执行的功能是什么。</p><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><p>以 <strong>Deployment</strong> 为例:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.7.9</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>该 Deployment 定义的编排动作要求: 确保携带了 <strong>app=nginx</strong> 标签的 Pod 的个数，永远等于 <strong>spec.replicas</strong> 指定的个数，即 <strong>2</strong> 个。</p><p>集群会根据携带 <strong>app=nginx</strong> 标签的 <strong>Pod</strong> 的实际数量来执行创建或者删除 Pod 操作，使数量收敛于 <strong>2</strong>。</p><p>这时，你也许就会好奇：究竟是 Kubernetes 项目中的哪个组件，在执行这些操作呢？</p><p>在上一小节提到的 <strong>kube-controller-manager</strong> 就是负责管理 <strong>Controllers</strong> 的服务组件。并且，<strong>Kubernetes</strong> 项目已经包含了若干的 <strong>Controllers</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> kubernetes/pkg/controller/</span><br><span class="line">$ ls -d */</span><br><span class="line">deployment/             job/                    podautoscaler/</span><br><span class="line">cloud/                  disruption/             namespace/</span><br><span class="line">replicaset/             serviceaccount/         volume/</span><br><span class="line">cronjob/                garbagecollector/       nodelifecycle/          replication/            statefulset/            daemon/</span><br></pre></td></tr></table></figure><h3 id="控制循环"><a href="#控制循环" class="headerlink" title="控制循环"></a>控制循环</h3><p>正如本文开篇所说，<strong>Kubernetes</strong> 的 <strong>Controllers</strong> 遵循 <strong>控制回路（Control Loop）</strong> 的工作模式。</p><p>比如，对于编排的对象 X，可以用一段 Go 语言风格的伪代码，来描述其 Controller 的控制循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    实际状态 := 获取集群中对象X的实际状态（Actual State）</span><br><span class="line">    期望状态 := 获取集群中对象X的期望状态（Desired State）</span><br><span class="line">    <span class="keyword">if</span> 实际状态 == 期望状态&#123;</span><br><span class="line">        什么都不做</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        执行编排动作，将实际状态调整为期望状态</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况:</p><ul><li><strong>实际状态来自于 Kubernetes 集群本身</strong>: 比如，kubelet 通过心跳汇报的容器状态和节点状态，或者监控系统中保存的应用监控数据，或者控制器主动收集的它自己感兴趣的信息，这些都是常见的实际状态的来源。</li><li><strong>期望状态来自于用户提交的 YAML 文件</strong>: 比如，Deployment 对象中 Replicas 字段的值。很明显，这些信息往往都保存在 Etcd 中。</li></ul><p>具体到本示例，Deployment 控制器的工作流程为:</p><ol><li>从 Etcd 中获取到所有携带了 <strong>app: nginx</strong> 标签的 Pod，统计其数量，作为实际状态</li><li>从 Template 中获取 Deployment 对象的 <strong>spec.replicas</strong> 值，作为期望状态</li><li>将两个状态做比较，然后根据比较结果，确定是创建 Pod，还是删除已有的 Pod</li></ol><p>以上即为 <strong>Kubernetes Controller</strong> 的工作模式。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://kubernetes.io/docs/concepts/architecture/controller/" target="_blank" rel="noopener">Architecture-Controllers</a></li><li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/" target="_blank" rel="noopener">Workloads-Controllers</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在机器人技术和自动化领域，控制回路（Control Loop）是一个非终止回路，用于调节系统状态。&lt;/p&gt;
&lt;p&gt;这是一个控制环的例子：房间里的温度自动调节器。&lt;/p&gt;
&lt;p&gt;当你设置了温度，告诉了温度自动调节器你的期望状态（Desired State）。 房间的实际温度是</summary>
      
    
    
    
    
    <category term="kubernetes" scheme="http://divinerapier.github.io/tags/kubernetes/"/>
    
    <category term="controllers" scheme="http://divinerapier.github.io/tags/controllers/"/>
    
  </entry>
  
  <entry>
    <title>使用 NFS</title>
    <link href="http://divinerapier.github.io/2020/10/02/how-to-use-nfs/"/>
    <id>http://divinerapier.github.io/2020/10/02/how-to-use-nfs/</id>
    <published>2020-10-02T08:18:20.000Z</published>
    <updated>2020-10-06T06:37:26.440Z</updated>
    
    <content type="html"><![CDATA[<p>查看被分享目录的属性:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">stat</span> /public</span><br><span class="line">  File: /public</span><br><span class="line">  Size: 4096            Blocks: 8          IO Block: 4096   directory</span><br><span class="line">Device: 802h/2050d      Inode: 58982401    Links: 2</span><br><span class="line">Access: (0777/drwxrwxrwx)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2020-10-02 16:25:03.129246127 +0800</span><br><span class="line">Modify: 2020-10-02 16:24:56.129203697 +0800</span><br><span class="line">Change: 2020-10-02 16:24:56.129203697 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo exportfs -avrf</span><br><span class="line">exporting *:/public</span><br></pre></td></tr></table></figure><p>服务端 <strong>/etc/exports</strong> 配置如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;public *(rw,sync,no_subtree_check)</span><br></pre></td></tr></table></figure><p>确认被 NFS 导出的本地文件系统:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo exportfs -avrf</span><br><span class="line">exporting *:/public</span><br></pre></td></tr></table></figure><p>在客户端查看远端配置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ showmount -e 192.168.50.5</span><br><span class="line">Export list <span class="keyword">for</span> 192.168.50.5:</span><br><span class="line">/public                               *</span><br></pre></td></tr></table></figure><p>客户端挂载 NFS 文件系统:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -o rw,nolock -t nfs 192.168.50.5:/public ./tmp</span><br></pre></td></tr></table></figure><p>当出现如下报错信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount.nfs: Operation not permitted</span><br></pre></td></tr></table></figure><p>请修改 <strong>/etc/exports</strong> 内容为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;public *(rw,sync,all_squash,no_subtree_check,insecure)</span><br></pre></td></tr></table></figure><p>然后重新执行命令挂载。</p><p>如果希望指定 <code>user</code> 与 <code>group</code> 来操作文件，可以通过在 <strong>/etc/exports</strong> 中增加选项: <strong>anonuid=1026,anongid=100</strong>。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://unix.stackexchange.com/questions/252812/user-permissions-in-nfs-mounted-directory" target="_blank" rel="noopener">User permissions in NFS mounted directory</a></li><li><a href="https://access.redhat.com/solutions/3773891" target="_blank" rel="noopener">Mount failed with mount: mount.nfs: access denied by server while mounting error</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;查看被分享目录的属性:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/sp</summary>
      
    
    
    
    
    <category term="nfs" scheme="http://divinerapier.github.io/tags/nfs/"/>
    
    <category term="filesystem" scheme="http://divinerapier.github.io/tags/filesystem/"/>
    
  </entry>
  
  <entry>
    <title>理解 Kubernetes 对象</title>
    <link href="http://divinerapier.github.io/2020/09/30/understanding-kubernetes-objects/"/>
    <id>http://divinerapier.github.io/2020/09/30/understanding-kubernetes-objects/</id>
    <published>2020-09-30T09:19:21.000Z</published>
    <updated>2020-10-06T05:51:54.780Z</updated>
    
    <content type="html"><![CDATA[<p>在 Kubernetes 系统中，Kubernetes 对象 是持久化的实体。 Kubernetes 使用这些实体去表示整个集群的状态。特别地，它们描述了如下信息：</p><ul><li>哪些容器化应用在运行（以及在哪些节点上）</li><li>可以被应用使用的资源</li><li>关于应用运行时表现的策略，比如重启策略、升级策略，以及容错策略</li></ul><p>Kubernetes 对象是 <strong>目标性记录</strong>，即一旦创建对象，Kubernetes 系统将持续工作以确保对象存在。 通过创建对象，本质上是在告知 Kubernetes 系统，所需要的集群工作负载看起来是什么样子的， 这就是 Kubernetes 集群的 <strong>期望状态（Desired State）</strong>。</p><p>操作 Kubernetes 对象 —— 无论是创建、修改，或者删除 —— 需要使用 <a href="https://kubernetes.io/docs/concepts/overview/kubernetes-api" target="_blank" rel="noopener">Kubernetes API</a>。 比如，当使用 kubectl 命令行接口时，CLI 会执行必要的 Kubernetes API 调用， 也可以在程序中使用 <a href="https://kubernetes.io/docs/reference/using-api/client-libraries/" target="_blank" rel="noopener">客户端库</a> 直接调用 Kubernetes API。</p><h2 id="对象规约（Spec）与状态（Status）"><a href="#对象规约（Spec）与状态（Status）" class="headerlink" title="对象规约（Spec）与状态（Status）"></a>对象规约（Spec）与状态（Status）</h2><p>几乎每个 Kubernetes 对象包含两个嵌套的对象字段，它们负责管理对象的配置： 对象 spec（规约） 和 对象 status（状态） 。 对于具有 spec 的对象，你必须在创建对象时设置其内容，描述你希望对象所具有的特征： 期望状态（Desired State） 。</p><p>status 描述了对象的 当前状态（Current State），它是由 Kubernetes 系统和组件 设置并更新的。在任何时刻，Kubernetes <a href="https://kubernetes.io/docs/reference/glossary/?all=true#term-control-plane" target="_blank" rel="noopener">控制平面</a> 都一直积极地管理着对象的实际状态，以使之与期望状态相匹配。</p><p>例如，Kubernetes 中的 Deployment 对象能够表示运行在集群中的应用。 当创建 Deployment 时，可能需要设置 Deployment 的 spec，以指定该应用需要有 3 个副本运行。 Kubernetes 系统读取 Deployment 规约，并启动我们所期望的应用的 3 个实例 —— 更新状态以与规约相匹配。 如果这些实例中有的失败了（一种状态变更），Kubernetes 系统通过执行修正操作 来响应规约和状态间的不一致 —— 在这里意味着它会启动一个新的实例来替换。</p><p>关于对象 spec、status 和 metadata 的更多信息，可参阅 <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md" target="_blank" rel="noopener">Kubernetes API 约定</a>。</p><h2 id="描述-Kubernetes-对象"><a href="#描述-Kubernetes-对象" class="headerlink" title="描述 Kubernetes 对象"></a>描述 Kubernetes 对象</h2><p>创建 Kubernetes 对象时，必须提供对象的规约，用来描述该对象的期望状态， 以及关于对象的一些基本信息（例如名称）。 当使用 Kubernetes API 创建对象时（或者直接创建，或者基于kubectl）， API 请求必须在请求体中包含 JSON 格式的信息。 <strong>大多数情况下，需要在 .yaml 文件中为 kubectl 提供这些信息</strong>。 kubectl 在发起 API 请求时，将这些信息转换成 JSON 格式。</p><p>这里有一个 .yaml 示例文件，展示了 Kubernetes Deployment 的必需字段和对象规约：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># for versions before 1.9.0 use apps/v1beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span> <span class="comment"># tells deployment to run 2 pods matching the template</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.14.2</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>使用类似于上面的 .yaml 文件来创建 Deployment的一种方式是使用 kubectl 命令行接口（CLI）中的 kubectl apply 命令， 将 .yaml 文件作为参数。下面是一个示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://k8s.io/examples/application/deployment.yaml --record</span><br></pre></td></tr></table></figure><p>输出类似如下这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deployment.apps&#x2F;nginx-deployment created</span><br></pre></td></tr></table></figure><h3 id="必需字段"><a href="#必需字段" class="headerlink" title="必需字段"></a>必需字段</h3><p>在想要创建的 Kubernetes 对象对应的 .yaml 文件中，需要配置如下的字段：</p><ul><li>apiVersion - 创建该对象所使用的 Kubernetes API 的版本</li><li>kind - 想要创建的对象的类别</li><li>metadata - 帮助唯一性标识对象的一些数据，包括一个 name 字符串、UID 和可选的 namespace</li></ul><p>你也需要提供对象的 spec 字段。 对象 spec 的精确格式对每个 Kubernetes 对象来说是不同的，包含了特定于该对象的嵌套字段。 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/" target="_blank" rel="noopener">Kubernetes API 参考</a> 能够帮助我们找到任何我们想创建的对象的 spec 格式。 例如，可以从 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#podspec-v1-core" target="_blank" rel="noopener">core/v1 PodSpec</a> 查看 Pod 的 spec 格式， 并且可以从 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#deploymentspec-v1-apps" target="_blank" rel="noopener">apps/v1 DeploymentSpec</a> 查看 Deployment 的 spec 格式。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/" target="_blank" rel="noopener">理解 Kubernetes 对象</a></li><li><a href="https://kubernetes.io/docs/reference/glossary/?all=true#term-control-plane" target="_blank" rel="noopener">控制平面</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Kubernetes 系统中，Kubernetes 对象 是持久化的实体。 Kubernetes 使用这些实体去表示整个集群的状态。特别地，它们描述了如下信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哪些容器化应用在运行（以及在哪些节点上）&lt;/li&gt;
&lt;li&gt;可以被应用使用的资源&lt;</summary>
      
    
    
    
    
    <category term="kubernetes" scheme="http://divinerapier.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>B 树</title>
    <link href="http://divinerapier.github.io/2020/09/10/b-tree/"/>
    <id>http://divinerapier.github.io/2020/09/10/b-tree/</id>
    <published>2020-09-10T11:29:43.000Z</published>
    <updated>2020-09-24T11:31:06.391Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>B-Tree</strong> 属于<strong>自平衡树</strong>的一种。其他种类的自平衡树，比如，<strong>AVL</strong>、<strong>Red-Black Tree</strong> 等，都是假设所有数据均保存在内存中。而 <strong>B-Tree</strong> 是用于内存无法保存所有数据的超大数据量场景。</p><p>当 <strong>key</strong> 的数量庞大，需要以 <strong>block</strong> 的形式从磁盘中读取数据时，相较于从内存中读取数据而言，访问磁盘需要很长的时间。<strong>B-Tree</strong> 的主要目标，或者说核心思想就是为了减少访问磁盘的次数。</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><table><thead><tr><th align="left">ALGORITHM</th><th align="left">TIME COMPLEXITY</th></tr></thead><tbody><tr><td align="left">Search</td><td align="left">O(log n)</td></tr><tr><td align="left">Insert</td><td align="left">O(log n)</td></tr><tr><td align="left">Delete</td><td align="left">O(log n)</td></tr></tbody></table><blockquote><p><strong>n</strong>: <strong>B-Tree</strong> 的节点总数。</p></blockquote><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol><li>所有的叶子节点在同一级。</li><li><strong>B-Tree</strong> 的 <strong>度(degree)</strong> 取决于磁盘块大小。</li><li>除根节点之外，其余节点必须至少包含 <strong>t-1</strong> 个 <strong>key</strong>；跟节点至少包含 <strong>1</strong> 个 <strong>key</strong>。</li><li>包括根节点在内，所有节点至多包含 <strong>2t-1</strong> 个 <strong>key</strong>。</li><li>节点的子节点数量等于节点中 <strong>key</strong> 的数量 <strong>+1</strong>。</li><li>节点的所有 <strong>key</strong> 按照升序排列，在 <strong>key: k1, k2</strong> 之间的所有子节点包含 <strong>[k1, k2]</strong> 范围内的所有 <strong>key</strong>。</li><li>不同于 <strong>BST</strong> 向下生长，向下收缩。<strong>B-Tree</strong> 从根节点开始生长和收缩。</li></ol><h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><p><img src="/images/b-tree/01.PNG" alt="01.png"></p><p>在上面的例子中，可以观察到:</p><ul><li>所有的叶子结点均处于同一级别</li><li>所有非叶子节点都没有空的子树</li><li>所有非叶子节点 <strong>key</strong> 的数量比其自带数 <strong>少 1</strong></li></ul><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><ul><li><a href="https://www.geeksforgeeks.org/introduction-of-b-tree-2" target="_blank" rel="noopener">Introduction of B-Tree</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;B-Tree&lt;/strong&gt; 属于&lt;strong&gt;自平衡树&lt;/strong&gt;的一种。其他种类的自平衡树，比如，&lt;stron</summary>
      
    
    
    
    
    <category term="data structure" scheme="http://divinerapier.github.io/tags/data-structure/"/>
    
    <category term="tree" scheme="http://divinerapier.github.io/tags/tree/"/>
    
    <category term="storage engine" scheme="http://divinerapier.github.io/tags/storage-engine/"/>
    
    <category term="index" scheme="http://divinerapier.github.io/tags/index/"/>
    
  </entry>
  
  <entry>
    <title>Windows Terminal</title>
    <link href="http://divinerapier.github.io/2020/09/05/windows-terminal/"/>
    <id>http://divinerapier.github.io/2020/09/05/windows-terminal/</id>
    <published>2020-09-05T01:41:34.000Z</published>
    <updated>2020-09-05T02:46:08.181Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.microsoft.com/en-us/windows/terminal/" target="_blank" rel="noopener"><code>Windows Terminal</code></a> 是继 <code>WSL</code> 之后出品的又一个开发者友好的现代化应用程序。在支持原有的 <code>CMD</code>、<code>Powershell</code> 之外，还支持 <code>WSL</code> 子系统。其主要特性包括: 多 <code>tab</code>，多 <code>panes</code>，支持显示 <code>Unicode</code> 与 <code>UTF-8</code> 字符，使用 <code>GPU</code> 加速的文本渲染引擎，内置 <code>SSH</code> 客户端，更允许用户自定义主题及文本样式，颜色，背景，快捷键等。</p><p>更多内容请阅读<a href="https://docs.microsoft.com/en-us/windows/terminal/" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="我的配置文件"><a href="#我的配置文件" class="headerlink" title="我的配置文件"></a>我的配置文件</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"$schema"</span>: <span class="string">"https://aka.ms/terminal-profiles-schema"</span>,</span><br><span class="line">    <span class="attr">"defaultProfile"</span>: <span class="string">"&#123;a5a97cb8-8961-5535-816d-772efe0c6a3f&#125;"</span>,</span><br><span class="line">    <span class="attr">"copyOnSelect"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"copyFormatting"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"theme"</span>: <span class="string">"dark"</span>,</span><br><span class="line">    <span class="attr">"tabWidthMode"</span>: <span class="string">"titleLength"</span>,</span><br><span class="line">    <span class="attr">"profiles"</span>: &#123;</span><br><span class="line">        <span class="attr">"defaults"</span>: &#123;</span><br><span class="line">            <span class="attr">"colorScheme"</span>: <span class="string">"Dracula"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"list"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"guid"</span>: <span class="string">"&#123;61c54bbd-c2c6-5271-96e7-009a87ff44bf&#125;"</span>,</span><br><span class="line">                <span class="attr">"name"</span>: <span class="string">"Windows PowerShell"</span>,</span><br><span class="line">                <span class="attr">"commandline"</span>: <span class="string">"powershell.exe"</span>,</span><br><span class="line">                <span class="attr">"hidden"</span>: <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"guid"</span>: <span class="string">"&#123;0caa0dad-35be-5f56-a8ff-afceeeaa6101&#125;"</span>,</span><br><span class="line">                <span class="attr">"name"</span>: <span class="string">"Command Prompt"</span>,</span><br><span class="line">                <span class="attr">"commandline"</span>: <span class="string">"cmd.exe"</span>,</span><br><span class="line">                <span class="attr">"hidden"</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"guid"</span>: <span class="string">"&#123;a5a97cb8-8961-5535-816d-772efe0c6a3f&#125;"</span>,</span><br><span class="line">                <span class="attr">"hidden"</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">"name"</span>: <span class="string">"Arch"</span>,</span><br><span class="line">                <span class="attr">"tabTitle"</span>: <span class="string">"Arch"</span>,</span><br><span class="line">                <span class="attr">"suppressApplicationTitle"</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">"antialiasingMode"</span>: <span class="string">"cleartype"</span>, <span class="comment">// "grayscale"、"cleartype"、"aliased"</span></span><br><span class="line">                <span class="attr">"icon"</span>: <span class="string">"ms-appdata:///roaming/archlinux-512.webp"</span>,</span><br><span class="line">                <span class="attr">"source"</span>: <span class="string">"Windows.Terminal.Wsl"</span>,</span><br><span class="line">                <span class="attr">"acrylicOpacity"</span>: <span class="number">0.8</span>,</span><br><span class="line">                <span class="attr">"useAcrylic"</span>: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"schemes"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Dracula"</span>,</span><br><span class="line">            <span class="attr">"cursorColor"</span>: <span class="string">"#F8F8F2"</span>,</span><br><span class="line">            <span class="attr">"selectionBackground"</span>: <span class="string">"#44475A"</span>,</span><br><span class="line">            <span class="attr">"background"</span>: <span class="string">"#282A36"</span>,</span><br><span class="line">            <span class="attr">"foreground"</span>: <span class="string">"#F8F8F2"</span>,</span><br><span class="line">            <span class="attr">"black"</span>: <span class="string">"#21222C"</span>,</span><br><span class="line">            <span class="attr">"blue"</span>: <span class="string">"#BD93F9"</span>,</span><br><span class="line">            <span class="attr">"cyan"</span>: <span class="string">"#8BE9FD"</span>,</span><br><span class="line">            <span class="attr">"green"</span>: <span class="string">"#50FA7B"</span>,</span><br><span class="line">            <span class="attr">"purple"</span>: <span class="string">"#FF79C6"</span>,</span><br><span class="line">            <span class="attr">"red"</span>: <span class="string">"#FF5555"</span>,</span><br><span class="line">            <span class="attr">"white"</span>: <span class="string">"#F8F8F2"</span>,</span><br><span class="line">            <span class="attr">"yellow"</span>: <span class="string">"#F1FA8C"</span>,</span><br><span class="line">            <span class="attr">"brightBlack"</span>: <span class="string">"#6272A4"</span>,</span><br><span class="line">            <span class="attr">"brightBlue"</span>: <span class="string">"#D6ACFF"</span>,</span><br><span class="line">            <span class="attr">"brightCyan"</span>: <span class="string">"#A4FFFF"</span>,</span><br><span class="line">            <span class="attr">"brightGreen"</span>: <span class="string">"#69FF94"</span>,</span><br><span class="line">            <span class="attr">"brightPurple"</span>: <span class="string">"#FF92DF"</span>,</span><br><span class="line">            <span class="attr">"brightRed"</span>: <span class="string">"#FF6E6E"</span>,</span><br><span class="line">            <span class="attr">"brightWhite"</span>: <span class="string">"#FFFFFF"</span>,</span><br><span class="line">            <span class="attr">"brightYellow"</span>: <span class="string">"#FFFFA5"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"keybindings"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"command"</span>: &#123;</span><br><span class="line">                <span class="attr">"action"</span>: <span class="string">"copy"</span>,</span><br><span class="line">                <span class="attr">"singleLine"</span>: <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"keys"</span>: <span class="string">"ctrl+c"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"command"</span>: <span class="string">"paste"</span>,</span><br><span class="line">            <span class="attr">"keys"</span>: <span class="string">"ctrl+v"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"command"</span>: <span class="string">"find"</span>,</span><br><span class="line">            <span class="attr">"keys"</span>: <span class="string">"ctrl+shift+f"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"command"</span>: &#123;</span><br><span class="line">                <span class="attr">"action"</span>: <span class="string">"splitPane"</span>,</span><br><span class="line">                <span class="attr">"split"</span>: <span class="string">"auto"</span>,</span><br><span class="line">                <span class="attr">"splitMode"</span>: <span class="string">"duplicate"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"keys"</span>: <span class="string">"alt+shift+d"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"command"</span>: &#123;</span><br><span class="line">                <span class="attr">"action"</span>: <span class="string">"splitPane"</span>,</span><br><span class="line">                <span class="attr">"split"</span>: <span class="string">"horizontal"</span>,</span><br><span class="line">                <span class="attr">"splitMode"</span>: <span class="string">"duplicate"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"keys"</span>: <span class="string">"alt+shift+-"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"command"</span>: &#123;</span><br><span class="line">                <span class="attr">"action"</span>: <span class="string">"splitPane"</span>,</span><br><span class="line">                <span class="attr">"split"</span>: <span class="string">"vertical"</span>,</span><br><span class="line">                <span class="attr">"splitMode"</span>: <span class="string">"duplicate"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"keys"</span>: <span class="string">"alt+shift+|"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h2><ul><li><a href="https://docs.microsoft.com/en-us/windows/terminal/customize-settings/global-settings#default-profile" target="_blank" rel="noopener"><strong>defaultProfile</strong></a>: 默认使用的终端配置，可以是 <code>profiles.list</code> 中的某一个。</li><li><a href="https://docs.microsoft.com/en-us/windows/terminal/customize-settings/global-settings#darklight-theme" target="_blank" rel="noopener"><strong>theme</strong></a>: 窗体配色，可以是 <code>system</code>, <code>dark</code>, <code>light</code></li><li><a href="https://docs.microsoft.com/en-us/windows/terminal/customize-settings/global-settings#tab-width-mode" target="_blank" rel="noopener"><strong>tabWidthMode</strong></a>: <code>tab</code> 显示长度，可以是 <code>equal</code>, <code>titleLength</code>, <code>compact</code></li></ul><h2 id="配置终端"><a href="#配置终端" class="headerlink" title="配置终端"></a>配置终端</h2><p><code>profiles</code> 用于配置具体的终端，其包含如下两部分:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"profiles"</span>: &#123;</span><br><span class="line">        <span class="attr">"defaults"</span>: &#123;</span><br><span class="line">            <span class="comment">// SETTINGS TO APPLY TO ALL PROFILES</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"list"</span>: [</span><br><span class="line">            <span class="comment">// PROFILE OBJECTS</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="默认终端配置"><a href="#默认终端配置" class="headerlink" title="默认终端配置"></a>默认终端配置</h3><ul><li><p><strong>profiles.defaults</strong>: 中的配置对所有的终端有效。</p></li><li><p><strong>profiles.list</strong>: 包含所有可用的终端，配置只对当前终端。</p></li><li><p><strong>guid</strong>: 配置文件可将 <code>GUID</code> 用作唯一标识符。 若要将某个配置文件设置为默认配置文件，则需要 <code>defaultProfile</code> 全局设置的 <code>GUID</code>，为必填项</p></li><li><p><strong>colorScheme</strong>: 终端使用的配色方案，需要在 <code>schemes</code> 中目标配色方案</p></li><li><p><strong>hidden</strong>: 在下拉列表中是否隐藏，默认为 <code>false</code></p></li><li><p><strong>name</strong>: “在下拉列表中显示的名字</p></li><li><p><strong>tabTitle</strong>: 在 <code>tab</code> 上显示的名字，会覆盖 <strong>name</strong>，需要与 <strong>suppressApplicationTitle</strong> 一起使用才会生效。若要了解如何使 shell 设置标题，请访问<a href="https://docs.microsoft.com/en-us/windows/terminal/tutorials/tab-title" target="_blank" rel="noopener">tab title tutorial</a></p></li><li><p><strong>suppressApplicationTitle</strong>: 设置为 <strong>true</strong> 时，<strong>tabTitle</strong> 会替代 <code>tab</code> 的默认标题，并将禁止应用程序的任何标题更改消息。 如果未设置 <strong>tabTitle</strong>，将改为使用 <strong>name</strong></p></li><li><p><strong>antialiasingMode</strong>: 抗锯齿模式，可以为 <strong>grayscale</strong>、<strong>cleartype</strong>、<strong>aliased</strong></p></li><li><p><strong>icon</strong>: 显示图标，”ms-appdata:///roaming/archlinux-512.webp”</p></li><li><p><strong>acrylicOpacity</strong>: 窗口透明度，<strong>[0, 1]</strong> 之内的浮点数，需要配合 <strong>useAcrylic</strong> 一起使用</p></li><li><p><strong>useAcrylic</strong>: 是否是否透明效果</p></li><li><p><strong>startingDirectory</strong>: 起始目录位置，比如 <code>\\\\wsl$\\Ubuntu-20.04\\home\\alice</code></p></li></ul><h4 id="ms-appdata-在什么位置"><a href="#ms-appdata-在什么位置" class="headerlink" title="ms-appdata 在什么位置"></a>ms-appdata 在什么位置</h4><p><code>Windows Terminal</code> 是一个 <code>UWP</code> 应用(如果是在应用商店下载的话)，会有属于自己的 <strong>appdata</strong> 目录，位于:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%LOCALAPPDATA%\Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\RoamingState</span><br></pre></td></tr></table></figure><p>在文件管理器中打开这个目录放入数据，<code>Windows Terminal</code> 即可通过 <code>ms-appdata:\\\</code> 的方式获取到。</p><h2 id="配色方案"><a href="#配色方案" class="headerlink" title="配色方案"></a>配色方案</h2><p>可以在 <strong>themes</strong> 定义一系列的配色方案，要求每个配色方案要有一个唯一的 <strong>name</strong>。除 <strong>name</strong> 以外，每个设置都接受十六进制格式 (<strong>#rgb</strong> 或 <strong>#rrggbb</strong>) 的字符串形式的颜色。 <strong>cursorColor</strong> 和 <strong>selectionBackground</strong> 设置是可选的。</p><p>如果要在一个命令行配置文件中设置配色方案，请添加 <strong>colorScheme</strong> 属性，并将配色方案的 <strong>name</strong> 作为值。</p><h2 id="自定义快捷键"><a href="#自定义快捷键" class="headerlink" title="自定义快捷键"></a>自定义快捷键</h2><p>内容太多，请查看<a href="https://docs.microsoft.com/en-us/windows/terminal/customize-settings/key-bindings" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://docs.microsoft.com/en-us/windows/terminal/" target="_blank" rel="noopener">Windows Terminal</a></li><li><a href="https://www.howtogeek.com/426346/how-to-customize-the-new-windows-terminal-app/" target="_blank" rel="noopener">How to Customize the New Windows Terminal App</a></li><li><a href="https://docs.microsoft.com/en-us/windows/terminal/customize-settings/key-bindings" target="_blank" rel="noopener">Custom key bindings in Windows Terminal</a></li><li><a href="https://draculatheme.com/windows-terminal/" target="_blank" rel="noopener">draculatheme</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/terminal/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;Windows Terminal&lt;/code&gt;&lt;/a&gt; 是继 &lt;code&gt;WS</summary>
      
    
    
    
    
    <category term="windows" scheme="http://divinerapier.github.io/tags/windows/"/>
    
    <category term="terminal" scheme="http://divinerapier.github.io/tags/terminal/"/>
    
  </entry>
  
  <entry>
    <title>投射数据卷 (TBC)</title>
    <link href="http://divinerapier.github.io/2020/09/04/projected-volumes/"/>
    <id>http://divinerapier.github.io/2020/09/04/projected-volumes/</id>
    <published>2020-09-04T00:39:17.000Z</published>
    <updated>2020-09-30T09:17:57.720Z</updated>
    
    <content type="html"><![CDATA[<p><strong>投射数据卷</strong> 的官方名称为: <code>projected volume</code>。<code>Project</code> 在这里的意思为 <a href="https://cn.bing.com/dict/search?q=project&qs=n&form=Z9LH5&sp=-1&pq=project&sc=8-7&sk=&cvid=A2B01F96E5A847E7A67FEC9AE0A97060" target="_blank" rel="noopener"><strong>投射</strong></a>。感谢 <code>k8s</code> 帮助我学习英语。</p><p><a href="https://kubernetes.io/docs/concepts/storage/volumes/#projected" target="_blank" rel="noopener">官方定义为</a>:</p><blockquote><p>A projected volume maps several existing volume sources into the same directory.</p></blockquote><p><code>Projected Volumes</code> 存在的意义不是为了存放容器里的数据，也不是用来进行容器和宿主机之间的数据交换。而是为容器提供预先定义好的数据。所以，从容器的角度来看，这些 <code>Volume</code> 里的信息就是仿佛是被 <code>Kubernetes</code> <strong>投射</strong> (Project) 进入容器当中的。到目前为止，Kubernetes 支持的 Projected Volume 一共有四种:</p><ul><li>Secret</li><li>ConfigMap</li><li>Downward API</li><li>ServiceAccountToken。</li></ul><p>下面是官方给出的一个<a href="https://kubernetes.io/docs/concepts/storage/volumes/#example-pod-with-a-secret-a-downward-api-and-a-configmap" target="_blank" rel="noopener">例子</a>:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">volume-test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">container-test</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">all-in-one</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">"/projected-volume"</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">all-in-one</span></span><br><span class="line">    <span class="attr">projected:</span></span><br><span class="line">      <span class="attr">sources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">secret:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">mysecret</span></span><br><span class="line">          <span class="attr">items:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">username</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">my-group/my-username</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">downwardAPI:</span></span><br><span class="line">          <span class="attr">items:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">"labels"</span></span><br><span class="line">              <span class="attr">fieldRef:</span></span><br><span class="line">                <span class="attr">fieldPath:</span> <span class="string">metadata.labels</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">"cpu_limit"</span></span><br><span class="line">              <span class="attr">resourceFieldRef:</span></span><br><span class="line">                <span class="attr">containerName:</span> <span class="string">container-test</span></span><br><span class="line">                <span class="attr">resource:</span> <span class="string">limits.cpu</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">configMap:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">myconfigmap</span></span><br><span class="line">          <span class="attr">items:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">config</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">my-group/my-config</span></span><br></pre></td></tr></table></figure><p>首先，可以看到 <code>volumes</code> 与 <code>containers</code> 是同级的属性字段，同属于 <code>pod</code> 的信息。其次，在上述示例中，使用了三种 <code>Projected Volume</code>。</p><p>在有了初步认识之后，接下来对每一种 <code>Projected Volume</code> 做出更详细的说明。</p><h2 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h2><p><code>Secret</code> 最常见的用法是保存认证信息，比如数据库等。这些数据会被保存在内部的 <code>ETCD</code> 中，可以通过将 <code>Secret</code> 以 <code>Volume</code> 的形式挂载到 <code>Pod</code> 上的方式，允许 <code>Pod</code> 使用 <code>Secret</code> 中的数据。</p><p>接下来介绍两种创建 <code>Secret</code> 以及使用的方式。</p><h3 id="命令行方式"><a href="#命令行方式" class="headerlink" title="命令行方式"></a>命令行方式</h3><h4 id="通过命令行创建-Secret"><a href="#通过命令行创建-Secret" class="headerlink" title="通过命令行创建 Secret"></a>通过命令行创建 Secret</h4><p>使用如下命令创建两个 <code>Secret</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'admin'</span> &gt; ./user.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'password'</span> &gt; ./pass.txt</span><br><span class="line"></span><br><span class="line">kubectl create secret generic user --from-file=./user.txt</span><br><span class="line">kubectl create secret generic pass --from-file=./pass.txt</span><br></pre></td></tr></table></figure><h4 id="查询-Secret"><a href="#查询-Secret" class="headerlink" title="查询 Secret"></a>查询 Secret</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get secrets</span><br><span class="line">NAME                  TYPE                                  DATA   AGE</span><br><span class="line">pass                  Opaque                                1      13s</span><br><span class="line">user                  Opaque                                1      18s</span><br></pre></td></tr></table></figure><h4 id="在-Pod-中使用-Secret"><a href="#在-Pod-中使用-Secret" class="headerlink" title="在 Pod 中使用 Secret"></a>在 Pod 中使用 Secret</h4><p>生成一个 <code>yaml</code> 文件，引用上面的 <code>Secret</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成 yaml，在 volumes.projected 中指定上面的 user 与 pass</span></span><br><span class="line">$ cat &lt;&lt; EOF &gt;&gt; busybox.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: <span class="built_in">test</span>-projected-volume</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: <span class="built_in">test</span>-secret-volume</span><br><span class="line">    image: busybox</span><br><span class="line">    args:</span><br><span class="line">    - sleep</span><br><span class="line">    - <span class="string">"86400"</span></span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: mysql-cred</span><br><span class="line">      mountPath: <span class="string">"/projected-volume"</span></span><br><span class="line">      readOnly: <span class="literal">true</span></span><br><span class="line">  volumes:</span><br><span class="line">  - name: mysql-cred</span><br><span class="line">    projected:</span><br><span class="line">      sources:</span><br><span class="line">      - secret:</span><br><span class="line">          name: user</span><br><span class="line">      - secret:</span><br><span class="line">          name: pass</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 pod</span></span><br><span class="line">$ kubectl apply -f ./busybox.yaml</span><br><span class="line">pod/<span class="built_in">test</span>-projected-volume created</span><br></pre></td></tr></table></figure><h4 id="在-Pod-中查看-Secret-数据"><a href="#在-Pod-中查看-Secret-数据" class="headerlink" title="在 Pod 中查看 Secret 数据"></a>在 Pod 中查看 Secret 数据</h4><p>进入到 <code>Pod</code> 中:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="built_in">exec</span> -ti <span class="built_in">test</span>-projected-volume -- sh</span><br><span class="line">/ <span class="comment">#</span></span><br></pre></td></tr></table></figure><p>查看 <code>Secret</code> 数据:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># ls /projected-volume/</span></span><br><span class="line">user.txt</span><br><span class="line">pass.txt</span><br><span class="line">/ <span class="comment"># cat /projected-volume/user.txt</span></span><br><span class="line">admin</span><br><span class="line">/ <span class="comment"># cat /projected-volume/pass.txt</span></span><br><span class="line">password</span><br></pre></td></tr></table></figure><p>可以看到，在 <code>mountPath</code> 指定的路径下面有预先定义好的 <code>Secret</code>，并且文件名就是 <code>--from-file</code> 指定的参数。</p><h3 id="yaml-方式"><a href="#yaml-方式" class="headerlink" title="yaml 方式"></a>yaml 方式</h3><h4 id="通过-yaml-创建-Secret"><a href="#通过-yaml-创建-Secret" class="headerlink" title="通过 yaml 创建 Secret"></a>通过 yaml 创建 Secret</h4><p>创建 <code>Secret</code> 的配置文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt;&lt; EOF &gt;&gt; secret.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: mysecret</span><br><span class="line"><span class="built_in">type</span>: Opaque</span><br><span class="line">data:</span><br><span class="line">  user: YWRtaW4=</span><br><span class="line">  pass: cGFzc3dvcmQ=</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>在 <code>Kubernetes</code> 中创建 <code>Secret</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f ./secret.yml</span><br><span class="line">secret/mysecret created</span><br></pre></td></tr></table></figure><h4 id="查询-Secret-1"><a href="#查询-Secret-1" class="headerlink" title="查询 Secret"></a>查询 Secret</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get secrets</span><br><span class="line">NAME                  TYPE                                  DATA   AGE</span><br><span class="line">mysecret              Opaque                                2      3m23s</span><br></pre></td></tr></table></figure><p>结果与使用命令行的方式有一些区别。</p><h4 id="在-Pod-中使用-Secret-1"><a href="#在-Pod-中使用-Secret-1" class="headerlink" title="在 Pod 中使用 Secret"></a>在 Pod 中使用 Secret</h4><p>生成一个 <code>yaml</code> 文件，引用上面的 <code>Secret</code>，需要注意 <code>secret.name</code> 应使用 <code>mysecret</code>，同时，数量从刚才的 <strong>2个</strong> 变成了 <strong>1个</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt;&lt; EOF &gt;&gt; busybox.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: <span class="built_in">test</span>-projected-volume</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: <span class="built_in">test</span>-secret-volume</span><br><span class="line">    image: busybox</span><br><span class="line">    args:</span><br><span class="line">    - sleep</span><br><span class="line">    - <span class="string">"86400"</span></span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: mysql-cred</span><br><span class="line">      mountPath: <span class="string">"/projected-volume"</span></span><br><span class="line">      readOnly: <span class="literal">true</span></span><br><span class="line">  volumes:</span><br><span class="line">  - name: mysql-cred</span><br><span class="line">    projected:</span><br><span class="line">      sources:</span><br><span class="line">      - secret:</span><br><span class="line">          name: mysecret</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 pod</span></span><br><span class="line">$ kubectl apply -f ./busybox.yaml</span><br><span class="line">pod/<span class="built_in">test</span>-projected-volume created</span><br></pre></td></tr></table></figure><h4 id="在-Pod-中查看-Secret-数据-1"><a href="#在-Pod-中查看-Secret-数据-1" class="headerlink" title="在 Pod 中查看 Secret 数据"></a>在 Pod 中查看 Secret 数据</h4><p>进入到 <code>Pod</code> 中:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="built_in">exec</span> -ti <span class="built_in">test</span>-projected-volume -- sh</span><br><span class="line">/ <span class="comment">#</span></span><br></pre></td></tr></table></figure><p>查看 <code>Secret</code> 数据:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># ls /projected-volume/</span></span><br><span class="line">pass  user</span><br><span class="line">/ <span class="comment"># cat /projected-volume/user</span></span><br><span class="line">admin</span><br><span class="line">/ <span class="comment"># cat /projected-volume/pass.txt</span></span><br><span class="line">password</span><br></pre></td></tr></table></figure><p>可以看到，在 <code>mountPath</code> 指定的路径下面有预先定义好的 <code>Secret</code>，并且文件名就是创建 <code>Secret</code> 的 <code>yaml</code> 文件中，<code>data</code> 字段的 <code>key</code>，内容为对应 <code>value</code> 经过 <code>base64</code> 解码之后的结果。</p><h2 id="Config-Map"><a href="#Config-Map" class="headerlink" title="Config Map"></a>Config Map</h2><p>与 <code>Secret</code> 相同的是，<code>ConfigMap</code> 也用于保存用户定义的配置信息；不同的是，<code>ConfigMap</code> 中的数据使用保持明文形式。</p><p>比如，原始配置保存在 <code>example/ui.properties</code> 中，通过该文件创建一个 <code>ConfigMap</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .properties文件的内容</span></span><br><span class="line">$ cat example/ui.properties</span><br><span class="line">color.good=purple</span><br><span class="line">color.bad=yellow</span><br><span class="line">allow.textmode=<span class="literal">true</span></span><br><span class="line">how.nice.to.look=fairlyNice</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 .properties 文件创建 ConfigMap</span></span><br><span class="line">$ kubectl create configmap ui-config --from-file=example/ui.properties</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 yaml 格式查看 ConfigMap 里保存的信息(data)</span></span><br><span class="line">$ kubectl get configmaps ui-config -o yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  ui.properties: |</span><br><span class="line">    color.good=purple</span><br><span class="line">    color.bad=yellow</span><br><span class="line">    allow.textmode=<span class="literal">true</span></span><br><span class="line">    how.nice.to.look=fairlyNice</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: ui-config</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h2 id="Downward-API"><a href="#Downward-API" class="headerlink" title="Downward API"></a>Downward API</h2><blockquote><p>A downwardAPI volume is used to make downward API data available to applications. It mounts a directory and writes the requested data in plain text files.</p></blockquote><p>让 <code>Pod</code> 里的容器能够直接获取到这个 <code>Pod API</code> 对象本身的信息。</p><p><code>Kubernets</code> 提供了两种方式使用 <code>Downward API</code>:</p><ul><li>Environment variables</li><li>Volume File</li></ul><h3 id="使用-Pod-的字段作为环境变量"><a href="#使用-Pod-的字段作为环境变量" class="headerlink" title="使用 Pod 的字段作为环境变量"></a>使用 Pod 的字段作为环境变量</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dapi-envars-fieldref</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">k8s.gcr.io/busybox</span></span><br><span class="line">      <span class="attr">command:</span> <span class="string">[</span> <span class="string">"sh"</span><span class="string">,</span> <span class="string">"-c"</span><span class="string">]</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">while</span> <span class="literal">true</span><span class="string">;</span> <span class="string">do</span></span><br><span class="line">          <span class="string">echo</span> <span class="string">-en</span> <span class="string">'\n'</span><span class="string">;</span></span><br><span class="line">          <span class="string">printenv</span> <span class="string">MY_NODE_NAME</span> <span class="string">MY_POD_NAME</span> <span class="string">MY_POD_NAMESPACE;</span></span><br><span class="line">          <span class="string">printenv</span> <span class="string">MY_POD_IP</span> <span class="string">MY_POD_SERVICE_ACCOUNT;</span></span><br><span class="line">          <span class="string">sleep</span> <span class="number">10</span><span class="string">;</span></span><br><span class="line">        <span class="string">done;</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_NODE_NAME</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">fieldRef:</span></span><br><span class="line">              <span class="attr">fieldPath:</span> <span class="string">spec.nodeName</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_POD_NAME</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">fieldRef:</span></span><br><span class="line">              <span class="attr">fieldPath:</span> <span class="string">metadata.name</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_POD_NAMESPACE</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">fieldRef:</span></span><br><span class="line">              <span class="attr">fieldPath:</span> <span class="string">metadata.namespace</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_POD_IP</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">fieldRef:</span></span><br><span class="line">              <span class="attr">fieldPath:</span> <span class="string">status.podIP</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_POD_SERVICE_ACCOUNT</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">fieldRef:</span></span><br><span class="line">              <span class="attr">fieldPath:</span> <span class="string">spec.serviceAccountName</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br></pre></td></tr></table></figure><p>上述配置文件中，包含了五个环境变量。字段 <code>env</code> 是 <a href="https://v1-16.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#envvar-v1-core" target="_blank" rel="noopener">EnvVars</a> 类型的数组。</p><p><strong>fieldRef</strong> 表示选择 <strong>Pod</strong> 的字段，允许使用:</p><ul><li>metadata.name</li><li>metadata.namespace</li><li>metadata.labels</li><li>metadata.annotations</li><li>spec.nodeName</li><li>spec.serviceAccountName</li><li>status.hostIP</li><li>status.podIP</li></ul><p>由 <code>command</code> 字段与 <code>args</code> 字段可以得知，这个 <code>Pod</code> 的功能为打印在 <code>env</code> 中定义的环境变量。</p><p>创建 <code>Pod</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://k8s.io/examples/pods/inject/dapi-envars-pod.yaml</span><br></pre></td></tr></table></figure><p>查看 <code>Pod</code> 是否为运行状态:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure><p>查看日志:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs dapi-envars-fieldref</span><br></pre></td></tr></table></figure><p>得到如下输出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">minikube</span><br><span class="line">dapi-envars-fieldref</span><br><span class="line">default</span><br><span class="line">172.17.0.4</span><br><span class="line">default</span><br></pre></td></tr></table></figure><h3 id="使用-Container-的字段作为环境变量"><a href="#使用-Container-的字段作为环境变量" class="headerlink" title="使用 Container 的字段作为环境变量"></a>使用 Container 的字段作为环境变量</h3><p>与上面的示例类似，除了可以将 <code>Pod</code> 的字段作为环境变量的值传入 <code>Container</code> 外，同样可以将 <code>Container</code> 的字段作为环境变量的值传入 <code>Container</code> 中。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dapi-envars-resourcefieldref</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">k8s.gcr.io/busybox:1.24</span></span><br><span class="line">      <span class="attr">command:</span> <span class="string">[</span> <span class="string">"sh"</span><span class="string">,</span> <span class="string">"-c"</span><span class="string">]</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">while</span> <span class="literal">true</span><span class="string">;</span> <span class="string">do</span></span><br><span class="line">          <span class="string">echo</span> <span class="string">-en</span> <span class="string">'\n'</span><span class="string">;</span></span><br><span class="line">          <span class="string">printenv</span> <span class="string">MY_CPU_REQUEST</span> <span class="string">MY_CPU_LIMIT;</span></span><br><span class="line">          <span class="string">printenv</span> <span class="string">MY_MEM_REQUEST</span> <span class="string">MY_MEM_LIMIT;</span></span><br><span class="line">          <span class="string">sleep</span> <span class="number">10</span><span class="string">;</span></span><br><span class="line">        <span class="string">done;</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">"32Mi"</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">"125m"</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">"64Mi"</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">"250m"</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_CPU_REQUEST</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">resourceFieldRef:</span></span><br><span class="line">              <span class="attr">containerName:</span> <span class="string">test-container</span></span><br><span class="line">              <span class="attr">resource:</span> <span class="string">requests.cpu</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_CPU_LIMIT</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">resourceFieldRef:</span></span><br><span class="line">              <span class="attr">containerName:</span> <span class="string">test-container</span></span><br><span class="line">              <span class="attr">resource:</span> <span class="string">limits.cpu</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_MEM_REQUEST</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">resourceFieldRef:</span></span><br><span class="line">              <span class="attr">containerName:</span> <span class="string">test-container</span></span><br><span class="line">              <span class="attr">resource:</span> <span class="string">requests.memory</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_MEM_LIMIT</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">resourceFieldRef:</span></span><br><span class="line">              <span class="attr">containerName:</span> <span class="string">test-container</span></span><br><span class="line">              <span class="attr">resource:</span> <span class="string">limits.memory</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br></pre></td></tr></table></figure><p><strong>resourceFieldRef</strong> 表示选择 <strong>Container</strong> 的字段，允许使用 <strong>resources.limits</strong> 和 <strong>resources.requests</strong>，具体如下:</p><ul><li>limits.cpu</li><li>limits.memory</li><li>limits.ephemeral-storage</li><li>requests.cpu</li><li>requests.memory</li><li>requests.ephemeral-storage</li></ul><p>创建 <code>Pod</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://k8s.io/examples/pods/inject/dapi-envars-container.yaml</span><br></pre></td></tr></table></figure><p>查看 <code>Pod</code> 是否为运行状态:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure><p>查看日志:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs dapi-envars-resourcefieldref</span><br></pre></td></tr></table></figure><p>得到如下输出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">33554432</span><br><span class="line">67108864</span><br></pre></td></tr></table></figure><h3 id="将-Pod-字段存储在文件中"><a href="#将-Pod-字段存储在文件中" class="headerlink" title="将 Pod 字段存储在文件中"></a>将 Pod 字段存储在文件中</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-downwardapi-volume-example</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">zone:</span> <span class="string">us-est-coast</span></span><br><span class="line">    <span class="attr">cluster:</span> <span class="string">test-cluster1</span></span><br><span class="line">    <span class="attr">rack:</span> <span class="string">rack-22</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">two</span></span><br><span class="line">    <span class="attr">builder:</span> <span class="string">john-doe</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">client-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">k8s.gcr.io/busybox</span></span><br><span class="line">      <span class="attr">command:</span> <span class="string">["sh",</span> <span class="string">"-c"</span><span class="string">]</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">while</span> <span class="literal">true</span><span class="string">;</span> <span class="string">do</span></span><br><span class="line">          <span class="string">if</span> <span class="string">[[</span> <span class="string">-e</span> <span class="string">/etc/podinfo/labels</span> <span class="string">]];</span> <span class="string">then</span></span><br><span class="line">            <span class="string">echo</span> <span class="string">-en</span> <span class="string">'\n\n'</span><span class="string">;</span> <span class="string">cat</span> <span class="string">/etc/podinfo/labels;</span> <span class="string">fi;</span></span><br><span class="line">          <span class="string">if</span> <span class="string">[[</span> <span class="string">-e</span> <span class="string">/etc/podinfo/annotations</span> <span class="string">]];</span> <span class="string">then</span></span><br><span class="line">            <span class="string">echo</span> <span class="string">-en</span> <span class="string">'\n\n'</span><span class="string">;</span> <span class="string">cat</span> <span class="string">/etc/podinfo/annotations;</span> <span class="string">fi;</span></span><br><span class="line">          <span class="string">sleep</span> <span class="number">5</span><span class="string">;</span></span><br><span class="line">        <span class="string">done;</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">podinfo</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/podinfo</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">podinfo</span></span><br><span class="line">      <span class="attr">downwardAPI:</span></span><br><span class="line">        <span class="attr">items:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">"labels"</span></span><br><span class="line">            <span class="attr">fieldRef:</span></span><br><span class="line">              <span class="attr">fieldPath:</span> <span class="string">metadata.labels</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">"annotations"</span></span><br><span class="line">            <span class="attr">fieldRef:</span></span><br><span class="line">              <span class="attr">fieldPath:</span> <span class="string">metadata.annotations</span></span><br></pre></td></tr></table></figure><p>在这个示例中，为 <code>Pod</code> 定义了 <code>downward API</code> 类型的 <code>Volume</code>，并且将这个 <code>Volume</code> 的挂载点位于 <code>/etc/podinfo</code>。</p><p><code>downwardAPI</code> 的 <code>item</code> 属性为 <a href="https://v1-16.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#downwardapivolumefile-v1-core" target="_blank" rel="noopener">DownwardAPIVolumeFile</a> 类型的数组。具体属性为:</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">fieldRef</td><td align="left"><a href="https://v1-16.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#objectfieldselector-v1-core" target="_blank" rel="noopener">ObjectFieldSelector</a></td><td align="left">必须: 从 annotations, labels, name and namespace 之中选择 <code>Pod</code> 的一个字段</td></tr><tr><td align="left">mode</td><td align="left">integer</td><td align="left">可选:文件属性，取值范围 [0, 0777]。缺省使用默认值。可能与其他影响改文件的参数产生冲突</td></tr><tr><td align="left">path</td><td align="left">string</td><td align="left">必须: 文件相对路径，要求必须是相对路径，且不能包含 <strong>..</strong></td></tr><tr><td align="left">resourceFieldRef</td><td align="left"><a href="https://v1-16.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#resourcefieldselector-v1-core" target="_blank" rel="noopener">ResourceFieldSelector</a></td><td align="left">只支持 <code>Container</code> 的 <code>resources.limit</code> 与 <code>resources.requests</code></td></tr></tbody></table><p>创建 <code>Pod</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://k8s.io/examples/pods/inject/dapi-volume.yaml</span><br></pre></td></tr></table></figure><p>查看 <code>Pod</code> 是否为运行状态:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure><p>查看日志:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs kubernetes-downwardapi-volume-example</span><br></pre></td></tr></table></figure><p>得到如下输出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cluster=<span class="string">"test-cluster1"</span></span><br><span class="line">rack=<span class="string">"rack-22"</span></span><br><span class="line">zone=<span class="string">"us-est-coast"</span></span><br><span class="line"></span><br><span class="line">build=<span class="string">"two"</span></span><br><span class="line">builder=<span class="string">"john-doe"</span></span><br></pre></td></tr></table></figure><p>进入到 <code>Pod</code> 中:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -it kubernetes-downwardapi-volume-example -- sh</span><br></pre></td></tr></table></figure><p>查看 <code>Volume</code> 文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/<span class="comment"># cat /etc/podinfo/labels</span></span><br></pre></td></tr></table></figure><p>得到如下内容:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cluster=<span class="string">"test-cluster1"</span></span><br><span class="line">rack=<span class="string">"rack-22"</span></span><br><span class="line">zone=<span class="string">"us-est-coast"</span></span><br></pre></td></tr></table></figure><p>类似地，查看 <code>annotations</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/<span class="comment"># cat /etc/podinfo/annotations</span></span><br></pre></td></tr></table></figure><h3 id="将-Container-字段存储在文件中"><a href="#将-Container-字段存储在文件中" class="headerlink" title="将 Container 字段存储在文件中"></a>将 Container 字段存储在文件中</h3><p>同样可以将 <code>Container</code> 的字段写入到文件中，并以 <code>Volume</code> 的形式挂载到 <code>Container</code> 中</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-downwardapi-volume-example-2</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">client-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">k8s.gcr.io/busybox:1.24</span></span><br><span class="line">      <span class="attr">command:</span> <span class="string">["sh",</span> <span class="string">"-c"</span><span class="string">]</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">while</span> <span class="literal">true</span><span class="string">;</span> <span class="string">do</span></span><br><span class="line">          <span class="string">echo</span> <span class="string">-en</span> <span class="string">'\n'</span><span class="string">;</span></span><br><span class="line">          <span class="string">if</span> <span class="string">[[</span> <span class="string">-e</span> <span class="string">/etc/podinfo/cpu_limit</span> <span class="string">]];</span> <span class="string">then</span></span><br><span class="line">            <span class="string">echo</span> <span class="string">-en</span> <span class="string">'\n'</span><span class="string">;</span> <span class="string">cat</span> <span class="string">/etc/podinfo/cpu_limit;</span> <span class="string">fi;</span></span><br><span class="line">          <span class="string">if</span> <span class="string">[[</span> <span class="string">-e</span> <span class="string">/etc/podinfo/cpu_request</span> <span class="string">]];</span> <span class="string">then</span></span><br><span class="line">            <span class="string">echo</span> <span class="string">-en</span> <span class="string">'\n'</span><span class="string">;</span> <span class="string">cat</span> <span class="string">/etc/podinfo/cpu_request;</span> <span class="string">fi;</span></span><br><span class="line">          <span class="string">if</span> <span class="string">[[</span> <span class="string">-e</span> <span class="string">/etc/podinfo/mem_limit</span> <span class="string">]];</span> <span class="string">then</span></span><br><span class="line">            <span class="string">echo</span> <span class="string">-en</span> <span class="string">'\n'</span><span class="string">;</span> <span class="string">cat</span> <span class="string">/etc/podinfo/mem_limit;</span> <span class="string">fi;</span></span><br><span class="line">          <span class="string">if</span> <span class="string">[[</span> <span class="string">-e</span> <span class="string">/etc/podinfo/mem_request</span> <span class="string">]];</span> <span class="string">then</span></span><br><span class="line">            <span class="string">echo</span> <span class="string">-en</span> <span class="string">'\n'</span><span class="string">;</span> <span class="string">cat</span> <span class="string">/etc/podinfo/mem_request;</span> <span class="string">fi;</span></span><br><span class="line">          <span class="string">sleep</span> <span class="number">5</span><span class="string">;</span></span><br><span class="line">        <span class="string">done;</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">"32Mi"</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">"125m"</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">"64Mi"</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">"250m"</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">podinfo</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/podinfo</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">podinfo</span></span><br><span class="line">      <span class="attr">downwardAPI:</span></span><br><span class="line">        <span class="attr">items:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">"cpu_limit"</span></span><br><span class="line">            <span class="attr">resourceFieldRef:</span></span><br><span class="line">              <span class="attr">containerName:</span> <span class="string">client-container</span></span><br><span class="line">              <span class="attr">resource:</span> <span class="string">limits.cpu</span></span><br><span class="line">              <span class="attr">divisor:</span> <span class="string">1m</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">"cpu_request"</span></span><br><span class="line">            <span class="attr">resourceFieldRef:</span></span><br><span class="line">              <span class="attr">containerName:</span> <span class="string">client-container</span></span><br><span class="line">              <span class="attr">resource:</span> <span class="string">requests.cpu</span></span><br><span class="line">              <span class="attr">divisor:</span> <span class="string">1m</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">"mem_limit"</span></span><br><span class="line">            <span class="attr">resourceFieldRef:</span></span><br><span class="line">              <span class="attr">containerName:</span> <span class="string">client-container</span></span><br><span class="line">              <span class="attr">resource:</span> <span class="string">limits.memory</span></span><br><span class="line">              <span class="attr">divisor:</span> <span class="string">1Mi</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">"mem_request"</span></span><br><span class="line">            <span class="attr">resourceFieldRef:</span></span><br><span class="line">              <span class="attr">containerName:</span> <span class="string">client-container</span></span><br><span class="line">              <span class="attr">resource:</span> <span class="string">requests.memory</span></span><br><span class="line">              <span class="attr">divisor:</span> <span class="string">1Mi</span></span><br></pre></td></tr></table></figure><p>创建 <code>Pod</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://k8s.io/examples/pods/inject/dapi-volume-resources.yaml</span><br></pre></td></tr></table></figure><p>进入到 <code>Pod</code> 中:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -it kubernetes-downwardapi-volume-example-2 -- sh</span><br></pre></td></tr></table></figure><p>查看 <code>Volume</code> 文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/<span class="comment"># cat /etc/podinfo/cpu_limit</span></span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://kubernetes.io/docs/concepts/storage/volumes/#projected" target="_blank" rel="noopener">Projected Volumes</a></li><li><a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-projected-volume-storage/" target="_blank" rel="noopener">Configure a Pod to Use a Projected Volume for Storage</a></li><li><a href="https://v1-16.docs.kubernetes.io/docs/concepts/storage/volumes/#downwardapi" target="_blank" rel="noopener">Donwload API</a></li><li><a href="https://v1-16.docs.kubernetes.io/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/" target="_blank" rel="noopener">Expose Pod Information to Containers Through Files</a></li><li><a href="https://v1-16.docs.kubernetes.io/docs/tasks/inject-data-application/environment-variable-expose-pod-information/#use-pod-fields-as-values-for-environment-variables" target="_blank" rel="noopener">Use Pod fields as values for environment variables</a></li><li><a href="https://v1-16.docs.kubernetes.io/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/#store-pod-fields" target="_blank" rel="noopener">Store Pod fields</a></li><li><a href="https://v1-16.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#envvar-v1-core" target="_blank" rel="noopener">Kubernetes API: EnvVar v1 core</a></li><li><a href="https://v1-16.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#envvarsource-v1-core" target="_blank" rel="noopener">Kubernetes API: EnvVarSource v1 core</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;投射数据卷&lt;/strong&gt; 的官方名称为: &lt;code&gt;projected volume&lt;/code&gt;。&lt;code&gt;Project&lt;/code&gt; 在这里的意思为 &lt;a href=&quot;https://cn.bing.com/dict/search?q=proj</summary>
      
    
    
    
    
    <category term="k8s" scheme="http://divinerapier.github.io/tags/k8s/"/>
    
    <category term="pod" scheme="http://divinerapier.github.io/tags/pod/"/>
    
  </entry>
  
  <entry>
    <title>Play with Kubernetes</title>
    <link href="http://divinerapier.github.io/2020/09/04/play-with-k8s/"/>
    <id>http://divinerapier.github.io/2020/09/04/play-with-k8s/</id>
    <published>2020-09-04T00:08:52.000Z</published>
    <updated>2020-09-04T11:28:29.493Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://labs.play-with-k8s.com/" target="_blank" rel="noopener">Play with Kubernetes</a> 是一个可以在浏览器使用的 <code>CentOS</code> 虚拟机环境，允许用户通过 <code>github</code> 账号登录。在这里，用户可以部署，学习使用 <code>k8s</code>。</p><p>跳过前面一些很简单的操作。在左侧添加 4 台虚拟机。每一台新创建的虚拟机控制台界面会有如下的提示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> 1. Initializes cluster master node:</span><br><span class="line"></span><br><span class="line"> kubeadm init --apiserver-advertise-address $(hostname -i) --pod-network-cidr 10.5.0.0&#x2F;16</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 2. Initialize cluster networking:</span><br><span class="line"></span><br><span class="line">kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;cloudnativelabs&#x2F;kube-router&#x2F;master&#x2F;daemonset&#x2F;kubeadm-kuberouter.yaml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 3. (Optional) Create an nginx deployment:</span><br><span class="line"></span><br><span class="line"> kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;kubernetes&#x2F;website&#x2F;master&#x2F;content&#x2F;en&#x2F;examples&#x2F;application&#x2F;nginx-app.yaml</span><br></pre></td></tr></table></figure><h2 id="搭建-Kubernetes-环境"><a href="#搭建-Kubernetes-环境" class="headerlink" title="搭建 Kubernetes 环境"></a>搭建 Kubernetes 环境</h2><p>在 <code>node-1</code> 中执行第一条命令，创建 <code>Master</code> 节点(虽然有 BLM 运动，但我不在乎)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm init --apiserver-advertise-address $(hostname -i) --pod-network-cidr 10.5.0.0/16</span><br><span class="line">...</span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run <span class="string">"kubectl apply -f [podnetwork].yaml"</span> with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 192.168.0.38:6443 --token xguam5.v5vgzeifjipno115 \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:6ea81a284c1b7a5aeec9eb01c8856602f1f3e6f2edd5593816c27224bbccb960</span><br><span class="line">Waiting <span class="keyword">for</span> api server to startup</span><br><span class="line">Warning: kubectl apply should be used on resource created by either kubectl create --save-config or kubectl apply</span><br><span class="line">daemonset.apps/kube-proxy configured</span><br><span class="line">No resources found</span><br></pre></td></tr></table></figure><p>然后，从上述命令的输出中找到 <code>Worker</code> 节点加入 <code>Master</code> 节点的命令，在 <code>node[2-4]</code> 节点分别执行命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 192.168.0.38:6443 --token xguam5.v5vgzeifjipno115 \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:6ea81a284c1b7a5aeec9eb01c8856602f1f3e6f2edd5593816c27224bbccb960</span><br></pre></td></tr></table></figure><p>执行完成之后，<code>node[2-4]</code> 就成功加入了 <code>Kubernetes</code> 集群中。在 <code>Master</code> 节点，即 <code>node-1</code> 上执行命令验证:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes</span><br><span class="line">NAME    STATUS     ROLES    AGE   VERSION</span><br><span class="line">node1   Ready      master   14m   v1.18.4</span><br><span class="line">node2   Ready      &lt;none&gt;   12m   v1.18.4</span><br><span class="line">node3   NotReady   &lt;none&gt;   13s   v1.18.4</span><br><span class="line">node4   NotReady   &lt;none&gt;   5s    v1.18.4</span><br></pre></td></tr></table></figure><p>最后部署网络插件 <code>kube-router</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f https://raw.githubusercontent.com/cloudnativelabs/kube-router/master/daemonset/kubeadm-kuberouter.yaml</span><br><span class="line">configmap/kube-router-cfg unchanged</span><br><span class="line">daemonset.apps/kube-router configured</span><br><span class="line">serviceaccount/kube-router unchanged</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/kube-router unchanged</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/kube-router unchanged</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>部署完了，用去吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://labs.play-with-k8s.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Play with Kubernetes&lt;/a&gt; 是一个可以在浏览器使用的 &lt;code&gt;CentOS&lt;/code&gt; 虚拟机环境，允</summary>
      
    
    
    
    
    <category term="k8s" scheme="http://divinerapier.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Pod 的基本概念</title>
    <link href="http://divinerapier.github.io/2020/09/02/the-basics-of-pods/"/>
    <id>http://divinerapier.github.io/2020/09/02/the-basics-of-pods/</id>
    <published>2020-09-02T13:06:17.000Z</published>
    <updated>2020-09-04T00:42:23.296Z</updated>
    
    <content type="html"><![CDATA[<p>前文提到，可以类比于虚拟机与应用程序之间的关系来理解 <code>Pod</code> 与 <code>Container</code> 之间的关系。这样就可以容易理解 <strong>凡是调度、网络、存储，以及安全相关的属性，基本都是 Pod 级别的</strong>。</p><p>这些属性有一个共同点: 描述 <strong>机器</strong> 这个整体，而不是里面运行的 <strong>程序</strong>。比如:</p><ul><li>配置这个 <strong>机器</strong> 的网卡: <code>Pod</code> 的网络定义</li><li>配置这个 <strong>机器</strong> 的磁盘: <code>Pod</code> 的存储定义</li><li>配置这个 <strong>机器</strong> 的防火墙: <code>Pod</code> 的安全定义</li><li>这台 <strong>机器</strong> 运行在哪个服务器之上: <code>Pod</code> 的调度</li></ul><h2 id="NodeSelector"><a href="#NodeSelector" class="headerlink" title="NodeSelector"></a>NodeSelector</h2><p><code>NodeSelector</code> 是一个供用户将 <code>Pod</code> 与 <code>Node</code> 进行绑定的字段，用法如下所示:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="attr">nodeSelector:</span></span><br><span class="line">   <span class="attr">disktype:</span> <span class="string">ssd</span></span><br></pre></td></tr></table></figure><p>这样的一个配置，意味着这个 <code>Pod</code> 永远只能运行在携带了 <code>disktype: ssd</code> 标签 <code>(Label)</code> 的节点上。否则，将调度失败。</p><h2 id="NodeName"><a href="#NodeName" class="headerlink" title="NodeName"></a>NodeName</h2><p>当 <code>Kubernetes</code> 将 <code>Pod</code> 调度到某个 <code>Node</code> 上之后，会自动设置 <code>Pod</code> 的 <code>NodeName</code> 字段。即，<code>Kubernetes</code> 会认为所有已被赋值 <code>NodeName</code> 字段的 <code>Pod</code> 都是被调度过的。因此，通过用户也可以设置该字段来 <strong>骗过</strong> 调度器，比如在测试或者调试阶段。</p><h2 id="HostAliases"><a href="#HostAliases" class="headerlink" title="HostAliases"></a>HostAliases</h2><p><code>HostAliases</code> 定义 <code>Pod</code> 的 <code>hosts</code> 文件 <code>(比如 /etc/hosts)</code> 里的内容。</p><p>比如，在这个 <code>Pod</code> 的 <code>YAML</code> 文件中设置了一组 <code>IP</code> 和 <code>Hostname</code> 的数据。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hostAliases:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">ip:</span> <span class="string">"10.1.2.3"</span></span><br><span class="line">    <span class="attr">hostnames:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"foo.remote"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"bar.remote"</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>在 <code>Pod</code> 启动后，<code>/etc/hosts</code> 文件的内容将如下所示:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/hosts</span><br><span class="line"><span class="comment"># Kubernetes-managed hosts file.</span></span><br><span class="line">127.0.0.1 localhost</span><br><span class="line">...</span><br><span class="line">10.244.135.10 hostaliases-pod</span><br><span class="line">10.1.2.3 foo.remote</span><br><span class="line">10.1.2.3 bar.remote</span><br></pre></td></tr></table></figure><p>其中，最下面两行记录，就是通过 <code>HostAliases</code> 字段写入的。</p><p><strong>特别注意</strong>: 在 <code>Kubernetes</code> 中，强烈建议使用这种方式设置 hosts 文件里的内容。如果使用直接修改 <code>hosts</code> 文件的方式，在 <code>Pod</code> 被删除重建之后，<code>kubelet</code> 会还原被修改的内容。</p><h2 id="ShareProcessNamespace"><a href="#ShareProcessNamespace" class="headerlink" title="ShareProcessNamespace"></a>ShareProcessNamespace</h2><p><strong>凡是跟容器的 <code>Linux Namespace</code> 相关的属性，也一定是 <code>Pod</code> 级别的</strong>。</p><p>设计 <code>Pod</code> 的初衷，就是要让里面的容器尽可能多地共享 <code>Linux Namespace</code>，仅保留必要的隔离和限制能力。这样，<code>Pod</code> 之于 <code>Container</code> 就会更近似于虚拟机之于程序。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">shareProcessNamespace:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">shell</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">stdin:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><code>shareProcessNamespace: true</code> 表示: <code>Pod</code> 里的 <code>Containers</code> 要共享 <code>PID Namespace</code>。</p><h2 id="共享宿主机的-Namespace"><a href="#共享宿主机的-Namespace" class="headerlink" title="共享宿主机的 Namespace"></a>共享宿主机的 Namespace</h2><ul><li><strong>HostPID</strong> - 控制 Pod 中容器是否可以共享宿主上的进程 ID 空间。 注意，如果与 ptrace 相结合，这种授权可能被利用，导致向容器外的特权逃逸 (默认情况下 ptrace 是被禁止的)。</li><li><strong>HostIPC</strong> - 控制 Pod 容器是否可共享宿主上的 IPC 名字空间。</li><li><strong>HostNetwork</strong> - 控制是否 Pod 可以使用节点的网络名字空间。 此类授权将允许 Pod 访问本地回路 (loopback) 设备、在本地主机 (localhost) 上监听的服务、还可能用来监听同一节点上其他 Pod 的网络活动。</li><li><strong>HostPorts</strong> -提供可以在宿主网络名字空间中可使用的端口范围列表。 该属性定义为一组 HostPortRange 对象的列表，每个对象中包含 min(含) 与 max(含) 值的设置。 默认不允许访问宿主端口。</li></ul><p>例如:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hostIPC:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hostPID:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">shell</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">stdin:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h2><p><code>Container Lifecycle Hooks</code>。顾名思义，是在容器状态发生变化时触发一系列 <strong>钩子</strong>。我们来看这样一个例子:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">lifecycle-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">lifecycle-demo-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">lifecycle:</span></span><br><span class="line">      <span class="attr">postStart:</span></span><br><span class="line">        <span class="attr">exec:</span></span><br><span class="line">          <span class="attr">command:</span> <span class="string">["/bin/sh",</span> <span class="string">"-c"</span><span class="string">,</span> <span class="string">"echo Hello from the postStart handler &gt; /usr/share/message"</span><span class="string">]</span></span><br><span class="line">      <span class="attr">preStop:</span></span><br><span class="line">        <span class="attr">exec:</span></span><br><span class="line">          <span class="attr">command:</span> <span class="string">["/usr/sbin/nginx","-s","quit"]</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>PostStart</strong>: 这个回调在创建容器之后立即执行。 但是，不能保证回调会在容器入口点 <code>(ENTRYPOINT)</code> 之前执行。没有参数传递给处理程序。</p></li><li><p><strong>PreStop</strong>: 在容器因 API 请求或者管理事件 <strong>(诸如存活态探针失败、资源抢占、资源竞争等)</strong> 而被终止之前，此回调会被调用。如果容器已经处于终止或者完成状态，则对 preStop 回调的调用将失败。此调用是阻塞的，也是同步调用，因此必须在删除容器的调用之前完成。没有参数传递给处理程序。</p></li></ul><blockquote><p><code>Kubernetes</code> 只有在 <code>Pod</code> 结束 <strong>(Terminated)</strong> 的时候才会发送 preStop 事件，这意味着在 Pod 完成 <strong>(Completed)</strong> 时 preStop 的事件处理逻辑不会被触发。这个限制在 <a href="https://github.com/kubernetes/kubernetes/issues/55807" target="_blank" rel="noopener">issue #55087</a> 中被追踪。</p></blockquote><p>有关终止行为的更详细描述，请参见 <a href="https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-lifecycle/#termination-of-pods" target="_blank" rel="noopener">终止 Pod</a>。</p><h2 id="Status"><a href="#Status" class="headerlink" title="Status"></a>Status</h2><p>Pending。Pod 已被 Kubernetes 系统接受 <strong>(YAML 文件已经提交给了 Kubernetes)</strong>，但有一个或者多个容器尚未创建亦未运行。此阶段包括等待 Pod 被调度的时间和通过网络下载镜像的时间，</p><p>Running。Pod 已经绑定到了某个节点，Pod 中所有的容器都已被创建。至少有一个容器仍在运行，或者正处于启动或重启状态。</p><p>Succeeded。Pod 中的所有容器都已成功终止，并且不会再重启。这种情况在运行一次性任务时最为常见。</p><p>Failed。Pod 中的所有容器都已终止，并且至少有一个容器是因为失败终止。也就是说，容器以非 <code>0</code> 状态退出或者被系统终止。这个状态的出现，意味着你得想办法 Debug 这个容器的应用，比如查看 Pod 的 Events 和日志。</p><p>Unknown。这是一个异常状态，意味着 Pod 的状态不能持续地被 kubelet 汇报给 kube-apiserver，这很有可能是主从节点(Master 和 Kubelet)间的通信出现了问题。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://kubernetes.io/zh/docs/tasks/configure-pod-container/share-process-namespace/" target="_blank" rel="noopener">在 Pod 中的容器之间共享进程命名空间</a></li><li><a href="https://kubernetes.io/docs/tasks/configure-pod-container/share-process-namespace/" target="_blank" rel="noopener">Share Process Namespace between Containers in a Pod</a></li><li><a href="https://kubernetes.io/zh/docs/concepts/policy/pod-security-policy/" target="_blank" rel="noopener">Pod 安全策略</a></li><li><a href="https://kubernetes.io/docs/concepts/policy/pod-security-policy/" target="_blank" rel="noopener">Pod Security Policies</a></li><li><a href="https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-lifecycle/" target="_blank" rel="noopener">Pod 的生命周期</a></li><li><a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/" target="_blank" rel="noopener">Pod Lifecycle</a></li><li><a href="https://kubernetes.io/zh/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/" target="_blank" rel="noopener">为容器的生命周期事件设置处理函数</a></li><li><a href="https://kubernetes.io/zh/docs/concepts/containers/container-lifecycle-hooks/" target="_blank" rel="noopener">容器生命周期回调</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前文提到，可以类比于虚拟机与应用程序之间的关系来理解 &lt;code&gt;Pod&lt;/code&gt; 与 &lt;code&gt;Container&lt;/code&gt; 之间的关系。这样就可以容易理解 &lt;strong&gt;凡是调度、网络、存储，以及安全相关的属性，基本都是 Pod 级别的&lt;/strong&gt;。&lt;</summary>
      
    
    
    
    
    <category term="k8s" scheme="http://divinerapier.github.io/tags/k8s/"/>
    
    <category term="pod" scheme="http://divinerapier.github.io/tags/pod/"/>
    
  </entry>
  
  <entry>
    <title>让你的 Hexo 博客支持 RSS</title>
    <link href="http://divinerapier.github.io/2020/09/02/enable-rss-on-hexo/"/>
    <id>http://divinerapier.github.io/2020/09/02/enable-rss-on-hexo/</id>
    <published>2020-09-02T12:37:46.000Z</published>
    <updated>2020-09-02T12:50:44.937Z</updated>
    
    <content type="html"><![CDATA[<p>让博客支持 <code>RSS</code> 是一种美好的品德。</p><ul><li><p>安装 <code>RSS</code> 插件</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed</span><br></pre></td></tr></table></figure></li><li><p>配置博客 <code>_config.uml</code></p>  <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="attr">plugins:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo-generator-feed</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Feed Atom</span></span><br><span class="line"><span class="attr">feed:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure></li><li><p>配置主题 <code>_config.yml</code></p>  <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RSS订阅</span></span><br><span class="line"><span class="attr">rss:</span> <span class="string">/atom.xml</span></span><br></pre></td></tr></table></figure></li><li><p>客户端订阅</p><p>  使用 <code>RSS</code> 客户端订阅 <code>http(s)://${YOUR_BLOG_HOST}/atom.xml</code>。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;让博客支持 &lt;code&gt;RSS&lt;/code&gt; 是一种美好的品德。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安装 &lt;code&gt;RSS&lt;/code&gt; 插件&lt;/p&gt;
  &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter</summary>
      
    
    
    
    
    <category term="hexo" scheme="http://divinerapier.github.io/tags/hexo/"/>
    
    <category term="rss" scheme="http://divinerapier.github.io/tags/rss/"/>
    
  </entry>
  
</feed>
